<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数字IC," />










<meta name="description" content="继APB总线协议之后再来看一下串行总线的I2C传输协议，体验一下串行总线在数据传输的复杂度">
<meta property="og:type" content="article">
<meta property="og:title" content="I2C_VIP">
<meta property="og:url" content="http://yoursite.com/2021/03/11/IC%E9%AA%8C%E8%AF%81-I2C_VIP/index.html">
<meta property="og:site_name" content="悦来客栈">
<meta property="og:description" content="继APB总线协议之后再来看一下串行总线的I2C传输协议，体验一下串行总线在数据传输的复杂度">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210810222806.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811005748.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201020201901557.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020102020201146.png#pic_center">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210810234457.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811005533.jpg">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811005330.jpg">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811005845.jpg">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811005949.jpg">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811010107.jpg">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811001743.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811002857.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811004346.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811120702.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811121740.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811145304.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811120305.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811120522.png">
<meta property="article:published_time" content="2021-03-11T06:25:30.000Z">
<meta property="article:modified_time" content="2021-09-02T08:38:20.932Z">
<meta property="article:author" content="xujunjie&#39;blog">
<meta property="article:tag" content="数字IC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/biongd/img/raw/master/img/20210810222806.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","display_updated":true,"offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/03/11/IC验证-I2C_VIP/"/>





  <title>I2C_VIP | 悦来客栈</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">悦来客栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">learn and better</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/11/IC%E9%AA%8C%E8%AF%81-I2C_VIP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xujunjie'blog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="悦来客栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">I2C_VIP</h1>
        

        <div class="post-meta">
          <span class="post-time">
              
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-11T14:25:30+08:00">
                2021-03-11
              </time>
            
            
                <span class="post-updated">
                     &nbsp; | &nbsp; 更新于
                     <time itemprop="dateUpdated" datetime="2021-09-02T16:38:20+08:00" content="2021-09-02">
                          2021-09-02
                     </time>
                 </span>
             

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%97-%E9%AA%8C%E8%AF%81%E6%8B%94%E9%AB%98-SystemVerilog-verilog%E5%9F%BA%E7%A1%80-%E6%80%BB%E7%BA%BFVIP-%E9%A1%B9%E7%9B%AE-mcdf%E5%AE%9E%E9%AA%8C-UVM/" itemprop="url" rel="index">
                    <span itemprop="name">数字-验证拔高.SystemVerilog.verilog基础.总线VIP.项目.mcdf实验.UVM.</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>继APB总线协议之后再来看一下串行总线的I2C传输协议，体验一下串行总线在数据传输的复杂度</p>
<a id="more"></a>
<h1 id="I2C总线协议"><a href="#I2C总线协议" class="headerlink" title="I2C总线协议"></a>I2C总线协议</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>只有两条同步串行总线：串行数据线（SDA）,串行时钟线（SCL）</p>
<p>主器件用于启动总线传输数据，<strong>产生时钟</strong>以开发传送的器件，此时任何被寻址的器件都被认为是从器件</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210810222806.png" alt="image-20210810222806466"></p>
<p>在总线上主和从，发和收的关系不是恒定的，而是取决于此时数据传送方向</p>
<p>主机发数据给从机：则主机寻址从器件，然后发送数据至从器件，最后由主机终止数据传送</p>
<p>主机接收从器件数据：则主机寻址从器件，然后接收从器件发送的数据，最后由主机终止数据传送</p>
<p><strong>主机负责产生定时时钟和终止数据传送</strong>，核心在主机</p>
<p>例如：控制系统就可以作为主机，传感器作为从机</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>I2C总线是一个真正的多主机总线，如果两个或多个主机同时初始化数据传输，<strong>可以通过冲突检测和仲裁防止数据破坏</strong></p>
<p>每个连接到总线上的器件都有唯一的地址，任何器件既可以作为主机也可以作为从机</p>
<p>数据传输和地址设定由软件设定，非常灵活。总线上的器件增加和删除不影响其他器件正常工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假如希望有多个微控制器（MCU）将数据记录到单个存储卡或将文本显示到单个LCD时，这个功能就非常有用。</span><br></pre></td></tr></table></figure>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>I2C总线上的每一个设备都对应一个唯一地址，主从设备直接的数据传输时建立在地址的基础上，也就是说，主设备在传输有效数据之前要先指定从设备的地址，地址指定的过程和上面数据传输的过程一样，只不过<strong>大多数从设备的地址是7位的</strong>。</p>
<p>不是1次传一个字节吗，为啥是7位的地址？</p>
<p>协议规定再给地址添加一个最低位用来表示接下来数据传输的方向，0表示主设备向从设备写数据，1表示主设备向从设备读数据。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811005748.jpg" alt="Screenshot_20210811_000123_tv.danmaku.bili" style="zoom: 50%;" /></p>
<h2 id="硬件层"><a href="#硬件层" class="headerlink" title="硬件层"></a>硬件层</h2><p>两条数据线需要接上拉电阻</p>
<p><img src="https://img-blog.csdnimg.cn/20201020201901557.png#pic_center" alt="img" style="zoom:67%;" /></p>
<p>I²C总线（<code>SDA</code>，<code>SCL</code>）内部都使用漏极开路驱动器（开漏驱动），因此<code>SDA</code>和<code>SCL</code> <strong>可以被拉低为低电平，但是不能被驱动为高电平</strong>，所以每条线上都要使用一个上拉电阻，默认情况下将其保持在高电平；</p>
<p><img src="https://img-blog.csdnimg.cn/2020102020201146.png#pic_center" alt="img" style="zoom:67%;" /></p>
<ul>
<li>连接到总线的设备的输出级必须有一个漏极开路或集电极开路来执行“线与“功能。</li>
<li>只有单个主设备时，如果总线上没有设备拉伸时钟，则主设备的SCL输出可以是推挽式设计</li>
</ul>
<h2 id="起始和截止条件"><a href="#起始和截止条件" class="headerlink" title="起始和截止条件"></a>起始和截止条件</h2><p>总线数据传输必须以一个起始信号为开始条件，一个结束信号为传输停止条件，这两个信号由主设备产生。</p>
<p>起始和结束信号产生条件：总线在空闲状态时，SCL和SDA都保持高电平</p>
<ul>
<li>当SCL为高电平而SDA由高到低跳变时，表示产生一个起始条件；</li>
<li>当SCL为高而SDA由低到高跳变时，产生一个停止条件</li>
</ul>
<p>在起始条件产生后，总线处于忙状态，由本次数据传输的主从设备独占，其他I2C器件无法访问总线；停止条件产生后，数据传输的主从设备释放总线，总线再次处于空闲</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210810234457.png" alt="image-20210810234457187"></p>
<h2 id="应答-ACK-amp-非应答-NACK"><a href="#应答-ACK-amp-非应答-NACK" class="headerlink" title="应答(ACK)&amp;非应答(NACK)"></a>应答(ACK)&amp;非应答(NACK)</h2><p><strong>响应应答信号</strong></p>
<p>主设备在SCL线上产生每个时钟脉冲的过程中将在SDA线上传输一个数据位，当一个字节数据位从高到低传输完后，从设备拉低SDA线，即应答位（ACK），表明字节已成功接收，可以发送下一个字节；</p>
<p>主设备产生所有时钟脉冲，包括第九个确认（ACK）时钟脉冲。</p>
<p>在第九个确认脉冲时钟脉冲期间，发送方将释放SDA总线，从而接收方可以把SDA拉低, 而且在脉冲高电平期间，SDA需持续拉低，定义为应答信号（ACK）</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811005533.jpg" alt="Screenshot_20210810_235506_tv.danmaku.bili" style="zoom:50%;" /></p>
<p><strong>非响应应答信号</strong></p>
<p>当SDA在第九个时钟脉冲期间保持为高时，定义为非应答信号（NACK）。</p>
<p>从端没有对该请求做出响应，主服务器可以生成终止传输的停止条件，或者生成启动新传输的重复启动条件。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811005330.jpg" alt="Screenshot_20210810_235456_tv.danmaku.bili" style="zoom: 50%;" /></p>
<h2 id="传输操作"><a href="#传输操作" class="headerlink" title="传输操作"></a>传输操作</h2><p>主设备往从设备中写数据</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811005845.jpg" alt="Screenshot_20210811_000842_tv.danmaku.bili" style="zoom:50%;" /></p>
<p>主设备在从设备中读数据</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811005949.jpg" alt="Screenshot_20210811_000911_tv.danmaku.bili" style="zoom:50%;" /></p>
<p>主设备往从设备中写数据，然后重启起始条件，紧接着在从设备中读取数据</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811010107.jpg" alt="Screenshot_20210811_000921_tv.danmaku.bili" style="zoom:50%;" /></p>
<p>主设备在从设备中读数据，然后重启起始条件，紧接着往从设备中写数据</p>
<p>为啥要重启起始条件呢？</p>
<p>因为每次起始的第一个8拍，第8位的读写位就定死了数据的传输方向，只能重启</p>
<h2 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h2><ul>
<li>SDA线上的数据在SCL高电平必须是稳定的。</li>
<li>只有当SCL时钟信号为低时，SDA的数据才可以发生变化。</li>
<li>每传输一个数据位产生一个时钟脉冲。</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811001743.png" alt="image-20210811001743880" style="zoom:80%;" /></p>
<h2 id="时钟同步和仲裁"><a href="#时钟同步和仲裁" class="headerlink" title="时钟同步和仲裁"></a>时钟同步和仲裁</h2><p><strong>同步</strong></p>
<p>两个主设备可以同时在空闲的总线上开始传送数据，必须有一种方法来决定哪一个来控制总线并完成它的数据传送，这是通过时钟同步和仲裁完成的。</p>
<p>时钟同步是连接到SCL总线的I2C接口的“线与”实现的；</p>
<p>当SCL总线从高电平拉低时，主设备将计数他们的低电平时钟，一旦一个主设备时钟拉低，其将把SCL总线也拉低，直到主设备时钟再次拉高；</p>
<p>然而如果另一个主设备的时钟仍旧是拉低的，SCL总线将保持拉低状态；因此，SCL总线被有最长低周期的主设备保持在低电平。<strong>在此期间，低周期较短的主设备将进入高电平等待状态。</strong></p>
<p>当所有相关的主设备时钟拉高时，主设备时钟和SCL总线的状态就没有区别了，所有的主时钟开始计算它们的高周期；第一个结束高周期的主设备会将SCL线再次拉低。 这样就产生了一个同步的SCL时钟，它的<strong>低周期由低电平最长的主设备时钟确定</strong>，而<strong>它的高周期由高电平最短的主设备时钟确定。</strong></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811002857.png" alt="image-20210811002857044"></p>
<p><strong>仲裁</strong></p>
<p>仲裁和同步一样，只有在系统中使用多个主设备时才需要；从设备不参与仲裁程序。</p>
<ul>
<li><p>只有在总线空闲的情况下，主设备才可以发起传送。</p>
</li>
<li><p>两个主机可以在启动条件的最小保持时间(tHD;STA)内生成一个启动条件，从而在总线上生成一个有效的启动条件。然后仲裁程序决定哪一个主设备来完成它的传输。</p>
</li>
<li><p>一个主机每发送1个bit数据，在scl处于高电平时，就检查看SDA的电平是否和发送的数据一致，如果不一致，这个主机便知道自己输掉仲裁，然后停止向SDA写数据。也就是说，如果主机一直检查到总线上数据和自己发送的数据一致，则继续传输，这样在仲裁过程中就保证了赢得仲裁的master不会丢失数据。</p>
<p>仲裁输掉的主机在检测到自己输了后也不再产生时钟脉冲，并且在总线空闲时才能重写传输</p>
</li>
<li><p>仲裁的过程可能要经过多个bit的发送和检查，实际上如果两个主机发送的时序和数据完全一致，则两个主机都能正常完成整个数据传输</p>
</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811004346.png" alt="image-20210811004346655"></p>
<p>显示了两个主设备的仲裁过程；</p>
<ul>
<li><p>当产生DATA1的主设备数据与SDA线上的实际数据有差异时，DATA1输出被关闭。这并不影响获胜主设备发起的数据传输。</p>
</li>
<li><p>由于I2C总线的控制完全取决于竞争主设备发送的地址和数据，因此没有中央主设备，总线上也没有任何优先级顺序</p>
</li>
</ul>
<h2 id="总线清零"><a href="#总线清零" class="headerlink" title="总线清零"></a>总线清零</h2><ul>
<li><p>在一些概率极低的情况中，时钟(SCL)会一直卡在低电平，如果I2C设备有硬件复位输入，优先考虑用硬件复位信号重置总线，如果I2C设备没有硬件复位输入，</p>
<p>则激活强制的内部通电复位(POR)电路。</p>
</li>
<li><p>如果数据线(SDA)一直卡在低电平，主设备应该发送9个时钟脉冲。控制总线拉低的设备应该在这9个时钟内释放它。如果没有效果，则使用硬件复位或循环电源来清除总线。</p>
</li>
</ul>
<h2 id="时钟拉伸"><a href="#时钟拉伸" class="headerlink" title="时钟拉伸"></a>时钟拉伸</h2><p>时钟拉伸通过保持SCL行较低来暂停事务；期间传输不能继续，直到SCL再次被拉高。</p>
<p>在字节传输级别，设备可能能够以较快的速度接收字节数据，但是需要更多的时间来存储收到的字节或准备传输另一个字节。在字节发送的（ACK）位之后，从设备</p>
<p>可以拉低SCL总线，迫使主设备进入等待状态,直到从设备准备好下一个字节的传输(参见图7)。</p>
<p>在比特级别，诸如微控制器这样的设备，无论是否为i2c总线提供有限的硬件，都可以通过延长每个时钟的低周期来降低总线时钟的速度。</p>
<p>在高速模式下，这个握手功能只能在字节级使用。</p>
<h2 id="保留地址"><a href="#保留地址" class="headerlink" title="保留地址"></a>保留地址</h2><p>两组8地址(0000 XXX和1111 XXX)是被保留的为了实现下面的功能</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811120702.png" alt="image-20210811120702489" style="zoom:80%;" /></p>
<h2 id="广播寻址（0000-0000）"><a href="#广播寻址（0000-0000）" class="headerlink" title="广播寻址（0000 0000）"></a>广播寻址（0000 0000）</h2><p>广播寻址用于同时寻址连接到i2c总线的每个设备；如果设备不需要广播提供的任何数据，它可以NACK来忽略广播地址；如果设备确实需要来自广播的数据，它就会对广播地址进行ACK，并作为一个从接收设备。</p>
<p>如果多个设备都发出了响应，主设备实际上并不知道有多少设备回应；每个能够处理此数据的从接收设备都会对第二个和后面的字节ACK；一般广播地址的含义总是在第二个字节中指定。</p>
<p>有两种情况需要考虑:当最低有效位B为零时。当最低有效位B为1时。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811121740.png" alt="image-20210811121740400"></p>
<h3 id="LSB-0"><a href="#LSB-0" class="headerlink" title="LSB=0"></a>LSB=0</h3><p>0000 0110 (06h):通过硬件复位和写从设备可编程部分；当接收到这2字节序列时，从设备回应广播地址复位，并接收其地址可编程部分。</p>
<p>必须采取预防措施，以确保设备在施加电源电压后不会拉低SDA或SCL，因为这些低电平会阻塞总线。</p>
<p>0000 0100 (04h):通过硬件编写从地址的可编程部分。行为如上述，但设备不重置。</p>
<p>0000 0000 (00h):此代码不允许用作第二个字节。</p>
<h3 id="LSB-1"><a href="#LSB-1" class="headerlink" title="LSB=1"></a>LSB=1</h3><p>当第B位为1时，2字节序列是一个硬件通用调用。</p>
<p>这意味着序列是由硬件主设备传输的，例如键盘扫描器，它可以通过编程传输所需的从地址。</p>
<p>由于硬件主设备事先不知道消息必须传输到哪个设备，因此它只能生成这个硬件通用调用和它自己的地址，并将其标识给系统。</p>
<p>第二个字节中剩下的7位包含硬件主设备地址；这个地址被一个连接到总线的智能设备(例如，一个微控制器)识别，然后总线接受来自硬件设备的信息。</p>
<h2 id="start-byte（0000-0001）"><a href="#start-byte（0000-0001）" class="headerlink" title="start byte（0000 0001）"></a>start byte（0000 0001）</h2><p>存在原因：</p>
<p>并不是每个连接到I2C总线的微控制器都有集成的I2C控制器。这些微控制器必须永久观察I2C线路，以检测I2C传输。这将消耗(主要由轮询完成)大量的CPU时间。为了减少这种CPU功率的浪费，可以用较慢的仲裁方法建立I2C传输。</p>
<p>start byte有何作用</p>
<p>为此，主机发送启动条件，然后是 start byte (’ 00000001 ‘)，一个虚拟的应答脉冲和一个重复的启动条件。观察微控制器只能检测SDA上的七个零中的一个来检测I2C传输。这可以通过一个相对缓慢的轮询率来实现。一旦控制器检测到SDA是低的，它就可以切换到一个更高的轮询速率，以便等待重复的启动条件和接下来的I2C传输。</p>
<p>传输结束后，它可以切换回节省cpu功耗的慢轮询速率，以便检测下一次传输。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811145304.png" alt="image-20210811145304888" style="zoom: 80%;" /></p>
<p>在开始字节之后产生一个与ACK相关的时钟脉冲，这样做只是为了与总线上使用的字节处理格式相一致，不允许任何设备确认开始字节</p>
<h2 id="Device-ID（1111-1xx1）"><a href="#Device-ID（1111-1xx1）" class="headerlink" title="Device ID（1111 1xx1）"></a>Device ID（1111 1xx1）</h2><p>概念：</p>
<p>设备ID字段是一个可选的3字节只读字(24位)，提供以下信息：</p>
<ul>
<li>12位带有制造商名称，每个制造商都是唯一的(例如NXP)； 9位带有零件标识，由制造商指定(例如PCA9698) ；3位带有模具修订，由制造商指定(例如RevX)</li>
</ul>
<p>设备ID是只读的，在设备中硬连接，可以按如下方式访问：</p>
<ul>
<li><p>开始条件（S）&amp; 主设备发送预留的设备ID I2C-bus地址，后面跟着设置为0的R/W位(写):11111000。</p>
</li>
<li><p>主设备发送从设备可以识别I2C-bus从地址；LSB是一个Don ‘ t care值；只有一个设备可以识别这个字节(具有i2c总线从地址的那个)。</p>
</li>
<li><p>主设备发送一个重新启动条件(Sr)。主设备发送预留的设备ID I2C-bus地址，后面跟着R/W位，设置为1(读):1111 1001。</p>
</li>
<li><p>接着读设备ID,首先是12制造商比特(第一个字节+第二个字节的高四比特)，紧随其后的是九个部分标识位(第二个字节的低四比特+ 第三个字节的高五比特),然后是</p>
<p>三个模具修改部分(第三个字节低四比特)。主设备通过对最后一个字节NACK来结束读取序列，从而重新设置从设备状态并允许主设备发送停止条件</p>
</li>
</ul>
<h2 id="10bit地址"><a href="#10bit地址" class="headerlink" title="10bit地址"></a>10bit地址</h2><p>10位地址扩展了地址位数；7位和10位地址的设备可以连接到相同的I2C总线，并且7位和10位地址可以在所有总线速度模式中使用。</p>
<p>10位从地址由开始条件或重复开始条件后的前两个字节组成。第一个字节的前7位是组合1111 0XX，其中最后2位(XX)是10位地址的两个最高有效位(MSB);</p>
<p>第一个字节的第8位是决定传输方向的R/W位。前面描述的7位寻址的所有读/写格式组合都可以用10位寻址实现。</p>
<h3 id="10-bit-地址写"><a href="#10-bit-地址写" class="headerlink" title="10-bit 地址写"></a>10-bit 地址写</h3><p>开始条件后跟着10位从地址，每个从设备将从地址(1111 0XX)第一个字节的前7位与它自己的地址进行比较，并检测第八位(R/W方向位)是否为0。</p>
<p>有可能有多个从设备匹配并生成应答信号(A1)。</p>
<p>把以上所有匹配从设备的地址与从地址(XXXX XXXX)第二个字节的8位进行比较，只有一个从设备地址匹配并生成应答信号(A2)。</p>
<p>匹配的从设备地址一直由主地址寻址，直到它接收到一个停止条件(P)或一个重复启动条件(Sr)，并且其后面跟着一个不同的从属地址</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811120305.png" alt="image-20210811120305309"></p>
<h3 id="10-bit-地址读"><a href="#10-bit-地址读" class="headerlink" title="10-bit 地址读"></a>10-bit 地址读</h3><p>传输方向在第二个R/W位之后改变；在确认位A2之前，其过程和读相同；重复启动条件(Sr)之后，匹配的从设备会记住它之前被寻址过。</p>
<p>然后这个从设备检查Sr之后的第一个字节的前7位是否与开始条件之后的第一个字节相同，并检测第8位(R/W)是否为1；如果匹配，从设备认为它已经作为一个发送器被寻址并生成确认A3。</p>
<p>从发送设备保持寻址，直到它收到一个停止条件(P)或直到它收到另一个重复启动条件(Sr)，且后面跟着一个不同的从设备地址。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811120522.png" alt="image-20210811120522640"></p>
<h1 id="VIP开发"><a href="#VIP开发" class="headerlink" title="VIP开发"></a>VIP开发</h1><h2 id="接口及功能分析"><a href="#接口及功能分析" class="headerlink" title="接口及功能分析"></a>接口及功能分析</h2><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifndef</span> LVC_I2C_IF_SV</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> LVC_I2C_IF_SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> lvc_i2c_if (<span class="keyword">input</span> <span class="keyword">bit</span> CLK);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   线与类型的SCL</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">wand</span>  SCL;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   线与类型的SDA</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">wand</span>  SDA;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * This signal is connected to the SMBALRT (serial data) of</span></span><br><span class="line"><span class="comment">   * all connected masters/slaves. All masters/slaves drive their</span></span><br><span class="line"><span class="comment">   * SMBALRT on this signal of the corresponding instance of this port interface.</span></span><br><span class="line"><span class="comment">   * The output SMBALRT from all masters/slaves is wired AND by this signal.</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">wand</span>  SMBALRT;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Reset signal </span></span><br><span class="line"><span class="comment">   * Reset is generated from the testbench. This reset is used to</span></span><br><span class="line"><span class="comment">   * reset master/slave bfm, monitor and checker.</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">bit</span> RST ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Determines whether to pullup the SCL &amp; SDA from Master &amp; Slave. </span></span><br><span class="line"><span class="comment">   * When the value is 1 then SCL &amp; SDA will be pulled up to '1'.</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">bit</span> enable_pullup_resistor = <span class="number">1'b1</span>;   </span><br><span class="line"></span><br><span class="line">  <span class="keyword">logic</span> scl_master;</span><br><span class="line">  <span class="keyword">logic</span> smbalrt_master;</span><br><span class="line">  <span class="keyword">logic</span> sda_master;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 空闲状态下，将总线驱动为高阻态</span></span><br><span class="line">  <span class="keyword">assign</span> SCL = scl_master === <span class="number">0</span> ? <span class="number">1'b0</span> : <span class="number">1'bz</span>;</span><br><span class="line">  <span class="keyword">assign</span> SDA = sda_master === <span class="number">0</span> ? <span class="number">1'b0</span> : <span class="number">1'bz</span>;</span><br><span class="line">  <span class="keyword">assign</span> SMBALRT = smbalrt_master === <span class="number">0</span> ? <span class="number">1'b0</span> : <span class="number">1'bz</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">logic</span> scl_slave;</span><br><span class="line">  <span class="keyword">logic</span> smbalrt_slave;</span><br><span class="line">  <span class="keyword">logic</span> sda_slave;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assign</span> SCL = scl_slave === <span class="number">0</span> ? <span class="number">1'b0</span> : <span class="number">1'bz</span>;</span><br><span class="line">  <span class="keyword">assign</span> SDA = sda_slave === <span class="number">0</span> ? <span class="number">1'b0</span> : <span class="number">1'bz</span>;</span><br><span class="line">  <span class="keyword">assign</span> SMBALRT = smbalrt_slave === <span class="number">0</span> ? <span class="number">1'b0</span> : <span class="number">1'bz</span>;</span><br><span class="line">  <span class="comment">//类似于时钟块</span></span><br><span class="line">  <span class="keyword">modport</span> lvc_i2c_master_modport (</span><br><span class="line">    <span class="keyword">input</span>  RST,</span><br><span class="line">    <span class="keyword">input</span>  CLK,</span><br><span class="line">    <span class="keyword">inout</span>  SCL,</span><br><span class="line">    <span class="keyword">inout</span>  SMBALRT,</span><br><span class="line">    <span class="keyword">inout</span>  SDA</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"> <span class="keyword">modport</span> lvc_i2c_slave_modport (</span><br><span class="line">    <span class="keyword">input</span>  RST,</span><br><span class="line">    <span class="keyword">input</span>  CLK,</span><br><span class="line">    <span class="keyword">inout</span>  SCL,</span><br><span class="line">    <span class="keyword">inout</span>  SMBALRT,</span><br><span class="line">    <span class="keyword">inout</span>  SDA</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">modport</span> lvc_i2c_monitor_modport (</span><br><span class="line">    <span class="keyword">input</span>  RST,</span><br><span class="line">    <span class="keyword">input</span>  CLK,</span><br><span class="line">    <span class="keyword">inout</span>  SCL,</span><br><span class="line">    <span class="keyword">inout</span>  SMBALRT,</span><br><span class="line">    <span class="keyword">inout</span>  SDA</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">//定义各类型时间，启动条件，截止条件，应答和非应答位生成，应答和非应答位接收，重复启动条件，扩展地址（开始位，广播的两次发送）</span></span><br><span class="line">  <span class="keyword">event</span> event_master_start_generated          ;</span><br><span class="line">  <span class="keyword">event</span> event_master_stop_generated           ;</span><br><span class="line">  <span class="keyword">event</span> event_master_ack_generated            ;</span><br><span class="line">  <span class="keyword">event</span> event_master_nack_generated           ;</span><br><span class="line">  <span class="keyword">event</span> event_master_ack_received             ;</span><br><span class="line">  <span class="keyword">event</span> event_master_nack_received            ;</span><br><span class="line">  <span class="keyword">event</span> event_master_repeated_start_generated ;</span><br><span class="line">  <span class="keyword">event</span> event_master_start_byte_transmited    ;</span><br><span class="line">  <span class="keyword">event</span> event_master_general_call_addr_sent   ;</span><br><span class="line">  <span class="keyword">event</span> event_master_general_call_sec_byte_sent   ;</span><br><span class="line">  <span class="keyword">event</span> event_master_arbitration_loss_detected;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assign</span> (<span class="keyword">weak0</span>, <span class="keyword">weak1</span>) SCL = enable_pullup_resistor ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">assign</span> (<span class="keyword">weak0</span>, <span class="keyword">weak1</span>) SDA = enable_pullup_resistor ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">assign</span> (<span class="keyword">weak0</span>, <span class="keyword">weak1</span>) SMBALRT = enable_pullup_resistor ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endinterface</span> : lvc_i2c_if</span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span> // LVC_I2C_IF_SV</span></span><br></pre></td></tr></table></figure>
<h3 id="transcation"><a href="#transcation" class="headerlink" title="transcation"></a>transcation</h3><p>考虑总线的特性状态，进行功能特性提取</p>
<p>核心就4个变量：命令cmd，地址adress，data数组，选择是否使用10bit地址</p>
<p>当然还有很多其他的状态：开始和截止位状态，重启状态，响应位状态</p>
<h4 id="base-transcation"><a href="#base-transcation" class="headerlink" title="base_transcation"></a>base_transcation</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifndef</span> LVC_I2C_TRANSACTION_SV</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> LVC_I2C_TRANSACTION_SV</span></span><br><span class="line"><span class="keyword">class</span> lvc_i2c_transaction <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line"></span><br><span class="line">  lvc_i2c_agent_configuration cfg = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * - I2C_WRITE     :  写命令</span></span><br><span class="line"><span class="comment">   * - I2C_READ      :  读命令</span></span><br><span class="line"><span class="comment">   * - I2C_GEN_CALL  :  广播</span></span><br><span class="line"><span class="comment">   * - I2C_DEVICE_ID :  请求设备id</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">rand</span> command_enum cmd = I2C_WRITE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在defines.svh中定义，LVC_I2C_SLA_ADD_WIDTH为10bit地址；LVC_I2C_SLAVE0_ADDRESS为10'b1100110011</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="meta">`LVC_I2C_SLA_ADD_WIDTH-1:0] addr = `LVC_I2C_SLAVE0_ADDRESS;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1BYTE数据构成的数组</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data [];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 主端是否使能10bit地址</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> addr_10bit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用10bit地址的权重，通过约束对addr_10bit进行控制</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> ADDR_10BIT_ON_wt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> ADDR_10BIT_OFF_wt = <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * - 1 : Start detected</span></span><br><span class="line"><span class="comment">   * - 0 : Start not detected  </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">bit</span> start_detected;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * - 1 : Stop detected</span></span><br><span class="line"><span class="comment">   * - 0 : Stop not detected  </span></span><br><span class="line"><span class="comment">   */</span>      </span><br><span class="line">  <span class="keyword">bit</span> stop_detected;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * - 1 : ACK detected</span></span><br><span class="line"><span class="comment">   * - 0 : NACK detected  </span></span><br><span class="line"><span class="comment">   */</span>      </span><br><span class="line">  <span class="keyword">bit</span> ack_detected [];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * - 1 : Repeated Start detected</span></span><br><span class="line"><span class="comment">   * - 0 : Repeated Start not detected  </span></span><br><span class="line"><span class="comment">   */</span>      </span><br><span class="line">  <span class="keyword">bit</span> rep_start_detected;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  双向数据线，读和写均要进行监测</span></span><br><span class="line"><span class="comment">   * - 1 : Read command detected</span></span><br><span class="line"><span class="comment">   * - 0 : Write command detected  </span></span><br><span class="line"><span class="comment">   */</span>      </span><br><span class="line">  <span class="keyword">bit</span> read_write; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Stores start time of START condition sent by Master.&lt;br/&gt;</span></span><br><span class="line"><span class="comment">   * Time is represented in timescale used (100ps by default).&lt;br/&gt;</span></span><br><span class="line"><span class="comment">   */</span>      </span><br><span class="line">  <span class="keyword">int</span> start_detected_st;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//存储启动条件结束时间     </span></span><br><span class="line">  <span class="keyword">int</span> start_detected_et;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//存储截止条件开始时间 </span></span><br><span class="line">  <span class="keyword">int</span> stop_detected_st;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  存储截止条件结束时间 </span></span><br><span class="line">  <span class="keyword">int</span> stop_detected_et;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//确认位    </span></span><br><span class="line">  <span class="keyword">int</span> ack_detected_st [];     </span><br><span class="line">  <span class="keyword">int</span> ack_detected_et [];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//复启位</span></span><br><span class="line">  <span class="keyword">int</span> rep_start_detected_st;</span><br><span class="line">  <span class="keyword">int</span> rep_start_detected_et;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//读写命令位</span></span><br><span class="line">  <span class="keyword">int</span> read_write_st;  </span><br><span class="line">  <span class="keyword">int</span> read_write_et;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//地址位  </span></span><br><span class="line">  <span class="keyword">int</span> addr_st;     </span><br><span class="line">  <span class="keyword">int</span> addr_et;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每个bit位    </span></span><br><span class="line">  <span class="keyword">int</span> data_st [];    </span><br><span class="line">  <span class="keyword">int</span> data_et [];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Enable/Disable the command fired from Master. Possible values are :</span></span><br><span class="line"><span class="comment">   * 1 : Command is sent to BFM. &lt;br/&gt; </span></span><br><span class="line"><span class="comment">   * 0 : Command is not sent to BFM. &lt;br/&gt; </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">bit</span> enable_cmd = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * sequence是否使用</span></span><br><span class="line"><span class="comment">   * 1 : Agent Driver uses sequence data &lt;br/&gt;</span></span><br><span class="line"><span class="comment">   * 0 : Agent Driver ignores the sequence data &lt;br/&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">bit</span> enable_pkt = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Enable/disable configuration driving. Possible values are :</span></span><br><span class="line"><span class="comment">   * 1 : Configuration is sent to BFM. &lt;br/&gt;</span></span><br><span class="line"><span class="comment">   * 0 : Configuration is not sent to BFM. &lt;br/&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">bit</span> enable_cfg = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">constraint</span> valid_ranges &#123;</span><br><span class="line">      <span class="keyword">if</span>((cfg!=<span class="literal">null</span>)&amp;&amp;(cfg<span class="variable">.bus_type</span> == I2C_BUS ))   cmd <span class="keyword">inside</span> &#123;I2C_READ,    I2C_WRITE ,    I2C_GEN_CALL,   I2C_DEVICE_ID&#125;;</span><br><span class="line">      <span class="keyword">if</span>((cfg!=<span class="literal">null</span>)&amp;&amp;(cfg<span class="variable">.bus_type</span> == I2C_BUS ))   data<span class="variable">.size</span>() <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">5120</span>]&#125;;</span><br><span class="line">      <span class="keyword">else</span> data<span class="variable">.size</span>() <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">1024</span>]&#125;;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">constraint</span> reasonable_cmd &#123;</span><br><span class="line">      <span class="keyword">if</span>((cfg!=<span class="literal">null</span>)&amp;&amp;(cfg<span class="variable">.bus_type</span> == I2C_BUS ))  cmd <span class="keyword">inside</span> &#123;I2C_READ,    I2C_WRITE &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">constraint</span> reasonable_data &#123;</span><br><span class="line">      <span class="keyword">if</span>((cfg!=<span class="literal">null</span>)&amp;&amp;(cfg<span class="variable">.bus_type</span> == I2C_BUS ))   data<span class="variable">.size</span>() <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">10</span>]&#125;;</span><br><span class="line">      <span class="keyword">else</span> data<span class="variable">.size</span>() <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">1024</span>]&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">constraint</span> reasonable_addr &#123;  	  </span><br><span class="line">    addr <span class="keyword">inside</span> &#123;<span class="number">10'b1100110011</span>, <span class="number">10'b1100110000</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constraint</span> reasonable_addr_10bit &#123;</span><br><span class="line">    addr_10bit <span class="keyword">dist</span> &#123;</span><br><span class="line">                      <span class="number">0</span> :/ADDR_10BIT_OFF_wt,</span><br><span class="line">                      <span class="number">1</span> :/ADDR_10BIT_ON_wt</span><br><span class="line">                    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * UVM field automation macros </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_begin(lvc_i2c_transaction)</span></span><br><span class="line">    <span class="meta">`uvm_field_enum(command_enum, cmd , UVM_ALL_ON|UVM_ENUM)</span></span><br><span class="line">    <span class="meta">`uvm_field_object(cfg                 , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(addr                   , UVM_ALL_ON|UVM_HEX)</span></span><br><span class="line">    <span class="meta">`uvm_field_array_int(data             , UVM_ALL_ON|UVM_HEX)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(addr_10bit             , UVM_ALL_ON)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(start_detected         , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(stop_detected          , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(rep_start_detected     , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(read_write             , UVM_ALL_ON)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(start_detected_st      , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(start_detected_et      , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(stop_detected_st       , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(stop_detected_et       , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_array_int(ack_detected     , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_array_int(ack_detected_st  , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_array_int(ack_detected_et  , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(rep_start_detected_st  , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(rep_start_detected_et  , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(read_write_st          , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(read_write_et          , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(addr_st                , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(addr_et                , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_array_int(data_st          , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_array_int(data_et          , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(enable_cmd             , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(enable_pkt             , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(enable_cfg             , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(ADDR_10BIT_ON_wt       , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(ADDR_10BIT_OFF_wt      , UVM_ALL_ON|UVM_NOPRINT)</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * CONSTRUCTOR : Create a new transaction instance, passing the appropriate </span></span><br><span class="line"><span class="comment">   * argument values to the parent class.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param name Instance name of the transaction</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">string</span> name = <span class="string">"lvc_i2c_transaction"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 决定reasonable_cmd，reasonable_data等是否有效</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">int</span> reasonable_constraint_mode (<span class="keyword">bit</span> on_off);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * slient决定是否异常要输出warning</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">bit</span> is_valid (<span class="keyword">bit</span> silent = <span class="number">1</span>);</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lvc_i2c_transaction::<span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">"lvc_i2c_transaction"</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一旦启动, reasonable_constraint就可以对valid_ranges_constraint进行覆盖</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> lvc_i2c_transaction::reasonable_constraint_mode (<span class="keyword">bit</span> on_off);</span><br><span class="line">  reasonable_cmd<span class="variable">.constraint_mode</span>(on_off);</span><br><span class="line">  reasonable_addr<span class="variable">.constraint_mode</span>(on_off);</span><br><span class="line">  <span class="keyword">return</span> on_off;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> lvc_i2c_transaction::is_valid (<span class="keyword">bit</span> silent = <span class="number">1</span>);</span><br><span class="line">  is_valid = <span class="number">1</span>;</span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(addr,0,10'b11_1111_1111)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(addr_10bit,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(ADDR_10BIT_ON_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(ADDR_10BIT_OFF_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(start_detected,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(stop_detected,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(rep_start_detected,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(read_write,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(start_detected_st,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(start_detected_et,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(stop_detected_st,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(stop_detected_et,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(rep_start_detected_st,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(rep_start_detected_et,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(read_write_st,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(read_write_et,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(addr_st,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(addr_et,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(enable_cmd,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(enable_pkt,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(enable_cfg,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(gnrl_arp_arg,0,8'hFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(drct_arp_arg,0,1)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h4 id="master-transaction"><a href="#master-transaction" class="headerlink" title="master_transaction"></a>master_transaction</h4><p>总线按bit传输且存在开始、结束、重启、失去仲裁、非响应、时钟拉伸等情况</p>
<p>主端多出的对于事件的可能处理：</p>
<ul>
<li><p>主端在发送完一个transcation后是重启还是结束：sr_or_p_gen</p>
</li>
<li><p>主端仲裁：</p>
<ul>
<li>失去仲裁后，是否完成当前transcation发送：abort_if_arb_lost</li>
<li>失去仲裁后，要重新尝试几次来完成当前的transcation传输：num_of_retry</li>
<li>是否等待别的主端开始，以进入仲裁状态：arbitrate</li>
</ul>
</li>
<li><p>主端是否发送start byte：send_start_byte</p>
</li>
<li><p>对于非应答做何处理：</p>
<ul>
<li><p>是否放弃当前传输：retry_if_nack</p>
</li>
<li><p>尝试几次来完成当前的transcation传输：num_of_retry</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifndef</span> LVC_I2C_MASTER_TRANSACTION_SV</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> LVC_I2C_MASTER_TRANSACTION_SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> lvc_i2c_master_transaction <span class="keyword">extends</span> lvc_i2c_transaction;</span><br><span class="line">  <span class="comment">/**   当前的transcation发送完后是重启还是截止	   </span></span><br><span class="line"><span class="comment">   * - 1 : Generates Repeated START (Sr) condition.&lt;br/&gt;</span></span><br><span class="line"><span class="comment">   * - 0 : Generates STOP (P) condition.&lt;br/&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> sr_or_p_gen = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果没有收到ACK，或者失去仲裁，主端要尝试几次来完成当前的transcation传输</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] num_of_retry = <span class="number">3'b001</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//gen_call模式的第二个byte值，参考响应内容</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] sec_byte_gen_call = <span class="number">8'h04</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//主端是否发送开始位</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> send_start_byte = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 一次传输结束到下一次传输开始的空闲时间</span></span><br><span class="line"><span class="comment">   * Time is represented in timescale used (100ps by default).&lt;br/&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] idle_time = <span class="number">32'h0001</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 失去仲裁的时候，主端应该如何做</span></span><br><span class="line"><span class="comment">   * - 1 : Dump the current transaction.&lt;br/&gt;</span></span><br><span class="line"><span class="comment">   * - 0 : Retry to complete the current transaction </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">rand</span>  <span class="keyword">bit</span> abort_if_arb_lost = <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 设置为1时，等待别的master的开始条件，然后开始传输任务，并进行仲裁</span></span><br><span class="line"><span class="comment">   * - 1 : Wait for START condition before Starting the next transaction on the bus.&lt;br/&gt;  </span></span><br><span class="line"><span class="comment">   * - 0 : Does not wait for START from another Master to start the next transaction.&lt;br/&gt; </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> arbitrate = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 非应答时是继续传完还是直接放弃当前任务</span></span><br><span class="line"><span class="comment">   * - 1 : Retry to complete the current transaction&lt;br/&gt; </span></span><br><span class="line"><span class="comment">   * - 0 : Abort (dump) the current transaction.&lt;br/&gt; </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> retry_if_nack = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> SR_OR_P_GEN_REPEATED_wt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> SR_OR_P_GEN_STOP_wt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> START_BYTE_ON_wt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> START_BYTE_OFF_wt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> ABORT_IF_ARB_LOST_ON_wt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> ABORT_IF_ARB_LOST_OFF_wt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> ARBITRATE_ON_wt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> ARBITRATE_OFF_wt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> RETRY_IF_NACK_ON_wt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> RETRY_IF_NACK_OFF_wt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否在传输一个字节后进行时钟拉伸</span></span><br><span class="line">  <span class="keyword">bit</span> enable_clk_stretch_after_byte = <span class="number">1'b0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 字节等级进行时钟拉伸的位置</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] clk_stretch_byte_level_pos = <span class="number">32'h0000</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// device_id是先写，重启，再读id，通过将该参数设为1，可以中断重启，改为停止</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> m_device_id_gen_stop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">int</span> nack_at_device_id_byte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">int</span> device_id_rollback_iteration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">constraint</span> master_valid_ranges &#123;</span><br><span class="line">     idle_time <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">1000</span>]&#125;;</span><br><span class="line">     num_of_retry <span class="keyword">inside</span> &#123; [<span class="number">0</span>:<span class="number">7</span>]&#125;;</span><br><span class="line">     sec_byte_gen_call <span class="keyword">inside</span> &#123; <span class="number">8'h04</span>, <span class="number">8'h06</span> &#125;;</span><br><span class="line">     clk_stretch_byte_level_pos &lt;= data<span class="variable">.size</span>();</span><br><span class="line">     nack_at_device_id_byte <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="meta">`LVC_I2C_NACK_AT_DEVICE_ID_BYTE_MAX_VALID]&#125;;</span></span><br><span class="line">     device_id_rollback_iteration <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="meta">`LVC_I2C_DEVICE_ID_ROLLBACK_ITER_MAX_VALID]&#125;;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">constraint</span> reasonable_sr_or_p_gen &#123;</span><br><span class="line">     sr_or_p_gen <span class="keyword">dist</span> &#123;</span><br><span class="line">                        <span class="number">0</span> :/SR_OR_P_GEN_STOP_wt,</span><br><span class="line">                        <span class="number">1</span> :/SR_OR_P_GEN_REPEATED_wt</span><br><span class="line">                      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">constraint</span> reasonable_idle_time &#123;</span><br><span class="line">     idle_time <span class="keyword">dist</span> &#123; </span><br><span class="line">                      <span class="number">0</span> := <span class="number">1</span>,</span><br><span class="line">                      [<span class="number">1</span>:<span class="number">10</span>] := <span class="number">100000</span>,</span><br><span class="line">                      [<span class="number">11</span>:<span class="number">1000</span>] := <span class="number">1</span></span><br><span class="line">                    &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">constraint</span> reasonable_sec_byte_gen_call &#123;</span><br><span class="line">     sec_byte_gen_call <span class="keyword">inside</span> &#123;<span class="number">8'h04</span>, <span class="number">8'h06</span>&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">constraint</span> reasonable_send_start_byte &#123;</span><br><span class="line">     send_start_byte <span class="keyword">dist</span> &#123;</span><br><span class="line">                            <span class="number">0</span> :/START_BYTE_OFF_wt,</span><br><span class="line">                            <span class="number">1</span> :/START_BYTE_ON_wt</span><br><span class="line">                          &#125;;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">constraint</span> reasonable_abort_if_arb_lost &#123;</span><br><span class="line">     abort_if_arb_lost <span class="keyword">dist</span> &#123;</span><br><span class="line">                              <span class="number">0</span> :/ABORT_IF_ARB_LOST_OFF_wt,</span><br><span class="line">                              <span class="number">1</span> :/ABORT_IF_ARB_LOST_ON_wt</span><br><span class="line">                            &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">constraint</span> reasonable_arbitrate &#123;</span><br><span class="line">     arbitrate <span class="keyword">dist</span> &#123;</span><br><span class="line">                      <span class="number">0</span> :/ARBITRATE_OFF_wt,</span><br><span class="line">                      <span class="number">1</span> :/ARBITRATE_ON_wt</span><br><span class="line">                    &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">constraint</span> reasonable_retry_if_nack &#123;</span><br><span class="line">     retry_if_nack <span class="keyword">dist</span> &#123;</span><br><span class="line">                          <span class="number">0</span> :/RETRY_IF_NACK_OFF_wt,</span><br><span class="line">                          <span class="number">1</span> :/RETRY_IF_NACK_ON_wt</span><br><span class="line">                        &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">constraint</span> reasonable_m_device_id_gen_stop &#123;</span><br><span class="line">     m_device_id_gen_stop <span class="keyword">dist</span> &#123;</span><br><span class="line">                                 <span class="number">0</span> := <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">1</span> := <span class="number">0</span></span><br><span class="line">                               &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">constraint</span> reasonable_nack_at_device_id_byte &#123;</span><br><span class="line">     nack_at_device_id_byte <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">20</span>]&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">constraint</span> reasonable_device_id_rollback_iteration &#123;</span><br><span class="line">     device_id_rollback_iteration <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">5</span>]&#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_object_utils_begin(lvc_i2c_master_transaction)</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">string</span> name = <span class="string">"lvc_i2c_master_transaction"</span>);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">bit</span> is_valid (<span class="keyword">bit</span> silent =<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lvc_i2c_master_transaction::<span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">"lvc_i2c_master_transaction"</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">function</span>  <span class="keyword">bit</span> lvc_i2c_master_transaction::is_valid(<span class="keyword">bit</span> silent =<span class="number">1</span>);</span><br><span class="line">  is_valid = <span class="keyword">super</span><span class="variable">.is_valid</span>(silent);</span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(sr_or_p_gen,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(num_of_retry,0,3'b111)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(sec_byte_gen_call,0,8'hFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(send_start_byte,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(idle_time,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(abort_if_arb_lost,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(arbitrate,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(retry_if_nack,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(SR_OR_P_GEN_REPEATED_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(SR_OR_P_GEN_STOP_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(START_BYTE_ON_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(START_BYTE_OFF_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(ABORT_IF_ARB_LOST_ON_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(ABORT_IF_ARB_LOST_OFF_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(ARBITRATE_ON_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(ARBITRATE_OFF_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(RETRY_IF_NACK_ON_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(RETRY_IF_NACK_OFF_wt,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(enable_clk_stretch_after_byte,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(clk_stretch_byte_level_pos,0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(m_device_id_gen_stop,0,1)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(nack_at_device_id_byte,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(device_id_rollback_iteration,32'h0,32'hFFFF_FFFF)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span> // LVC_I2C_MASTER_TRANSACTION_SV</span></span><br></pre></td></tr></table></figure>
<h4 id="slave-transcation"><a href="#slave-transcation" class="headerlink" title="slave_transcation"></a>slave_transcation</h4><p>从端决定回复的应答信号以及时钟拉伸</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifndef</span> LVC_I2C_SLAVE_TRANSACTION_SV</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> LVC_I2C_SLAVE_TRANSACTION_SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> lvc_i2c_slave_transaction <span class="keyword">extends</span> lvc_i2c_transaction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Object used to hold exceptions for a transaction */</span></span><br><span class="line">  <span class="comment">//lvc_i2c_slave_transaction_exception_list exception_list = null;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从端选择响应还是非响应</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> nack_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从端来几次非响应</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] nack_addr_count = <span class="number">32'h0000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//每个byte传输后的拉伸周期</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> clk_stretch_time_after_byte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在传输地址时进行bit等级的拉伸</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> clk_stretch_time_addr_byte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在传输数据时进行bit等级的拉伸</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> clk_stretch_time_data_byte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否对上述变量进行随机</span></span><br><span class="line">  <span class="keyword">bit</span> enable_random_clk_stretch_time_after_byte = <span class="number">1'b0</span>;</span><br><span class="line">  <span class="keyword">bit</span> enable_random_clk_stretch_time_addr_byte = <span class="number">1'b0</span>;</span><br><span class="line">  <span class="keyword">bit</span> enable_random_clk_stretch_time_data_byte = <span class="number">1'b0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择bit等级的时钟拉伸在时钟的哪一个bit位做</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] clk_stretch_bit_level_addr_pos  = <span class="number">4'b0000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//data</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] clk_stretch_bit_level_data_pos  = <span class="number">4'b0000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//byte</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] clk_stretch_byte_level_pos = <span class="number">32'h0000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Dumps the EEPROM memory in Slave BFM from the file specified by files</span></span><br><span class="line"><span class="comment">   * handle passed&lt; as second argument.</span></span><br><span class="line"><span class="comment">   * &lt;u&gt;Note&lt;/u&gt;: &lt;i&gt;This configuration takes effect if Slave is configured</span></span><br><span class="line"><span class="comment">   * as an EEPROM Slave.&lt;/i&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] eeprom_mem_dump = <span class="number">32'h0000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Loads the EEPROM memory in Slave BFM with the data specified in files</span></span><br><span class="line"><span class="comment">   * handle passed as second argument. Note: This configuration occurs</span></span><br><span class="line"><span class="comment">   * only if Slave is configured as an EEPROM Slave.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] eeprom_mem_load = <span class="number">32'h0000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每隔几个数据byte发送1个非应答信号</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] nack_data = <span class="number">32'h0000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> NACK_ADDRESS_ON_wt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> NACK_ADDRESS_OFF_wt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> slave_valid_ranges &#123;</span><br><span class="line">    nack_addr_count <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">31</span>]&#125;;</span><br><span class="line">    clk_stretch_bit_level_addr_pos <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">8</span>]&#125;;</span><br><span class="line">    clk_stretch_bit_level_data_pos <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">8</span>]&#125;;</span><br><span class="line">    clk_stretch_byte_level_pos &lt;= data<span class="variable">.size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constraint</span> reasonable_nack_addr &#123;</span><br><span class="line">    nack_addr <span class="keyword">dist</span> &#123;</span><br><span class="line">      <span class="number">0</span>  :/NACK_ADDRESS_OFF_wt,</span><br><span class="line">      <span class="number">1</span>  :/NACK_ADDRESS_ON_wt</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> reasonable_nack_data &#123;</span><br><span class="line">    <span class="keyword">soft</span> nack_data == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constraint</span> reasonable_clk_stretch_bit_level_addr_pos &#123;</span><br><span class="line">    clk_stretch_bit_level_addr_pos <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">8</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constraint</span> reasonable_clk_stretch_bit_level_data_pos &#123;</span><br><span class="line">    clk_stretch_bit_level_data_pos <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">8</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constraint</span> reasonable_clk_stretch_byte_level_pos &#123;</span><br><span class="line">    clk_stretch_byte_level_pos <span class="keyword">inside</span> &#123;[<span class="number">1</span>:data<span class="variable">.size</span>()]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_object_utils_begin(lvc_i2c_slave_transaction)</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">string</span> name = <span class="string">"lvc_i2c_slave_transaction"</span>);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">bit</span> is_valid (<span class="keyword">bit</span> silent =<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lvc_i2c_slave_transaction::<span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">"lvc_i2c_slave_transaction"</span>);</span><br><span class="line">  <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">function</span>  <span class="keyword">bit</span> lvc_i2c_slave_transaction::is_valid(<span class="keyword">bit</span> silent =<span class="number">1</span>);</span><br><span class="line">  is_valid = <span class="keyword">super</span><span class="variable">.is_valid</span>(silent);</span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(nack_addr,0,1);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(nack_addr_count,0,32'hFFFF_FFFF);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(clk_stretch_time_after_byte,0,32'hFFFF_FFFF);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(clk_stretch_time_addr_byte,0,32'hFFFF_FFFF);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(clk_stretch_time_data_byte,0,32'hFFFF_FFFF);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(enable_random_clk_stretch_time_after_byte,0,1);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(enable_random_clk_stretch_time_addr_byte,0,1);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(enable_random_clk_stretch_time_data_byte,0,1);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(clk_stretch_bit_level_addr_pos,0,4'b1111);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(clk_stretch_bit_level_data_pos,0,4'b1111);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(clk_stretch_byte_level_pos,0,32'hFFFF_FFFF);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(eeprom_mem_dump,0,32'hFFFF_FFFF);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(eeprom_mem_load,0,32'hFFFF_FFFF);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(nack_data,0,32'hFFFF_FFFF);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(NACK_ADDRESS_ON_wt,0,32'hFFFF_FFFF);</span></span><br><span class="line">  <span class="meta">`LVC_DATA_UTIL_IS_VALID_BV_W_RANGE(NACK_ADDRESS_OFF_wt,0,32'hFFFF_FFFF);</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span> // LVC_I2C_SLAVE_TRANSACTION_SV</span></span><br></pre></td></tr></table></figure>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="driver"><a href="#driver" class="headerlink" title="driver"></a>driver</h3><p>和apb相比，驱动的思想应该用串行的方式来理解，按bit位进行分析</p>
<p>比如apb的一次传输需要用两拍或者更多拍来完成，setup和trans这两个状态就要依次驱动</p>
<p>i2c明显更加复杂，需要考虑地址位，读写位，响应位，结束位等等，但归根结底还是串行的，一样用串行的驱动方式</p>
<h3 id="bfm-common"><a href="#bfm-common" class="headerlink" title="bfm_common"></a>bfm_common</h3><p>核心方法：clk_low_offset_gen()</p>
<p>对不同模式驱动的参数进行配置</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifndef</span> LVC_I2C_BFM_COMMON_SV</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> LVC_I2C_BFM_COMMON_SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> lvc_i2c_bfm_common <span class="keyword">extends</span> uvm_object;</span><br><span class="line"></span><br><span class="line">  lvc_i2c_vif i2c_if;</span><br><span class="line">  uvm_component comp;</span><br><span class="line">  lvc_i2c_configuration cfg;</span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_object_utils_begin(lvc_i2c_bfm_common)</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_end</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span>   i2c_clk_high=<span class="number">0</span>;  <span class="comment">//clk high level time</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span>   i2c_clk_low=<span class="number">0</span>;   <span class="comment">//clk low level time</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span>   re_sta_su=<span class="number">0</span>;     <span class="comment">//repeat start setup time</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span>   sto_su=<span class="number">0</span>;        <span class="comment">//stop setup time</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span>   sta_hd=<span class="number">0</span>;        <span class="comment">//start or repeat start hold time</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span>   dat_hd=<span class="number">0</span>;        <span class="comment">//data hold time,</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span>   tbuf_time=<span class="number">0</span>;     <span class="comment">//bus free time between a stop and</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">"lvc_i2c_bfm_common"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> assign_vif(lvc_i2c_vif i2c_if);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> source_event(<span class="keyword">event</span> sv_e, uvm_event uvm_e);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> reconfigure_via_task(lvc_i2c_configuration cfg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> wait_data_hd_time();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> clk_low_offset_gen(); </span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> wait_for_reset();</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lvc_i2c_bfm_common::<span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">"lvc_i2c_bfm_common"</span>);</span><br><span class="line">  <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> lvc_i2c_bfm_common::assign_vif(lvc_i2c_vif i2c_if);</span><br><span class="line">  <span class="keyword">this</span><span class="variable">.i2c_if</span> = i2c_if;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_bfm_common::source_event(<span class="keyword">event</span> sv_e, uvm_event uvm_e);</span><br><span class="line">  <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">    @(sv_e);</span><br><span class="line">    uvm_e<span class="variable">.trigger</span>();</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_bfm_common::reconfigure_via_task(lvc_i2c_configuration cfg);</span><br><span class="line">  <span class="keyword">this</span><span class="variable">.cfg</span> = cfg;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span>  lvc_i2c_bfm_common::clk_low_offset_gen();</span><br><span class="line">    <span class="keyword">case</span> (cfg<span class="variable">.bus_speed</span>)</span><br><span class="line">    STANDARD_MODE:  </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            i2c_clk_high = cfg<span class="variable">.scl_high_time_ss</span>;</span><br><span class="line">            i2c_clk_low  = cfg<span class="variable">.scl_low_time_ss</span>;</span><br><span class="line">            re_sta_su    = cfg<span class="variable">.min_su_sta_time_ss</span>;</span><br><span class="line">            sto_su       = cfg<span class="variable">.min_su_sto_time_ss</span>;</span><br><span class="line">            sta_hd       = cfg<span class="variable">.min_hd_sta_time_ss</span>;</span><br><span class="line">            dat_hd       = cfg<span class="variable">.min_hd_dat_time_ss</span>;</span><br><span class="line">            tbuf_time    = cfg<span class="variable">.tbuf_time_ss</span>;        </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    FAST_MODE: </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            i2c_clk_high = cfg<span class="variable">.scl_high_time_fs</span>;</span><br><span class="line">            i2c_clk_low  = cfg<span class="variable">.scl_low_time_fs</span>;</span><br><span class="line">            re_sta_su    = cfg<span class="variable">.min_su_sta_time_fs</span>;</span><br><span class="line">            sto_su       = cfg<span class="variable">.min_su_sto_time_fs</span>;</span><br><span class="line">            sta_hd       = cfg<span class="variable">.min_hd_sta_time_fs</span>;</span><br><span class="line">            dat_hd       = cfg<span class="variable">.min_hd_dat_time_fs</span>;</span><br><span class="line">            tbuf_time    = cfg<span class="variable">.tbuf_time_fs</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    HIGHSPEED_MODE:  </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            i2c_clk_high = cfg<span class="variable">.scl_high_time_hs</span>;</span><br><span class="line">            i2c_clk_low  = cfg<span class="variable">.scl_low_time_hs</span>;  </span><br><span class="line">            re_sta_su    = cfg<span class="variable">.min_su_sta_time_hs</span>;</span><br><span class="line">            sto_su       = cfg<span class="variable">.min_su_sto_time_hs</span>;</span><br><span class="line">            sta_hd       = cfg<span class="variable">.min_hd_sta_time_hs</span>;</span><br><span class="line">            dat_hd       = cfg<span class="variable">.min_hd_dat_time_hs</span>;</span><br><span class="line">            tbuf_time    = cfg<span class="variable">.tbuf_time_hs</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    FAST_MODE_PLUS:  </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            i2c_clk_high = cfg<span class="variable">.scl_high_time_fm_plus</span>;</span><br><span class="line">            i2c_clk_low  = cfg<span class="variable">.scl_low_time_fm_plus</span>;</span><br><span class="line">            re_sta_su    = cfg<span class="variable">.min_su_sta_time_fm_plus</span>;</span><br><span class="line">            sto_su       = cfg<span class="variable">.min_su_sto_time_fm_plus</span>;</span><br><span class="line">            sta_hd       = cfg<span class="variable">.min_hd_sta_time_fm_plus</span>;</span><br><span class="line">            dat_hd       = cfg<span class="variable">.min_hd_dat_time_fm_plus</span>;</span><br><span class="line">            tbuf_time    = cfg<span class="variable">.tbuf_time_fm_plus</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            i2c_clk_high = cfg<span class="variable">.scl_high_time_ss</span>;</span><br><span class="line">            i2c_clk_low  = cfg<span class="variable">.scl_low_time_ss</span>;</span><br><span class="line">            re_sta_su    = cfg<span class="variable">.min_su_sta_time_ss</span>;</span><br><span class="line">            sto_su       = cfg<span class="variable">.min_su_sto_time_ss</span>;</span><br><span class="line">            sta_hd       = cfg<span class="variable">.min_hd_sta_time_ss</span>;</span><br><span class="line">            dat_hd       = cfg<span class="variable">.min_hd_dat_time_ss</span>;</span><br><span class="line">            tbuf_time    = cfg<span class="variable">.tbuf_time_ss</span>;      </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endtask</span> : clk_low_offset_gen</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span>  lvc_i2c_bfm_common::wait_data_hd_time(); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=dat_hd;i++)</span><br><span class="line">    @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line"><span class="keyword">endtask</span> : wait_data_hd_time</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_bfm_common::wait_for_reset();</span><br><span class="line">  <span class="comment">// wait for reset release</span></span><br><span class="line">  @(<span class="keyword">negedge</span> i2c_if<span class="variable">.RST</span>);</span><br><span class="line">  <span class="comment">//wait(i2c_if.`I2C_MASTER_MODPORT.RST === 'b0);</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span> // LVC_I2C_BFM_COMMON_SV</span></span><br></pre></td></tr></table></figure>
<h3 id="master-driver-common"><a href="#master-driver-common" class="headerlink" title="master_driver_common"></a>master_driver_common</h3><p>核心方法：send_xact(lvc_i2c_master_transaction trans)</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifndef</span> LVC_I2C_MASTER_DRIVER_COMMON_SV</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> LVC_I2C_MASTER_DRIVER_COMMON_SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> lvc_i2c_master_driver_common <span class="keyword">extends</span> lvc_i2c_bfm_common;</span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_object_utils_begin(lvc_i2c_master_driver_common)</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_end</span></span><br><span class="line">  semaphore      lock;            <span class="comment">//if current send the restart cmd, next transaction need not to send start cmd</span></span><br><span class="line">  <span class="keyword">bit</span>            nack_flag=<span class="number">0</span>;     <span class="comment">// flag about nack generated by slave</span></span><br><span class="line">  <span class="keyword">bit</span> is10bits_again=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bit</span> same_slv_addr_in10bit=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] pre_addr=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">"lvc_i2c_master_driver_common"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> send_xact(lvc_i2c_master_transaction trans);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> collect_response_from_vif(lvc_i2c_master_transaction trans);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> start_gen();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> stop_gen();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> rw_slave_7bit_addr(<span class="keyword">bit</span>[<span class="number">6</span>:<span class="number">0</span>] addr, <span class="keyword">bit</span> rw);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> rw_slave_10bit_addr(<span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] addr, <span class="keyword">bit</span> rw);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> send_byte(<span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] send_byte);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> recv_byte(<span class="keyword">output</span> <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] recv_data);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> recv_byte_noack(<span class="keyword">output</span> <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] recv_data);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> send_start_byte();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> pre_hs_in_fm_send_byte(<span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] send_byte);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> pre_hs_in_fm_plus_send_byte(<span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] send_byte);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> pre_hs_in_fm_start_gen();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> pre_hs_in_fm_plus_start_gen();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> re_start_gen();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> drive_data(lvc_i2c_master_transaction trans);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> rw_same_slave_10bit_addr(<span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] addr, <span class="keyword">bit</span> rw);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lvc_i2c_master_driver_common::<span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">"lvc_i2c_master_driver_common"</span>);</span><br><span class="line">  <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">  lock = <span class="keyword">new</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::send_xact(lvc_i2c_master_transaction trans);</span><br><span class="line">  lvc_i2c_master_transaction trans_temp;</span><br><span class="line">    clk_low_offset_gen();</span><br><span class="line">    drive_data(trans);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::drive_data(lvc_i2c_master_transaction trans);</span><br><span class="line">  <span class="keyword">bit</span>       rw;   <span class="comment">//0--write, 1--read</span></span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>]  recv_data;</span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>]  gen_call_first_byte = <span class="number">8'b0000_0000</span>;</span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>]  gen_call_second_byte = trans<span class="variable">.sec_byte_gen_call</span>;</span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>]  device_id_w = <span class="number">8'b1111_1000</span>;</span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>]  device_id_r = <span class="number">8'b1111_1001</span>;</span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>]  hs_code     = &#123;<span class="number">5'b00001</span>,cfg<span class="variable">.master_code</span>&#125;;</span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">2</span>:<span class="number">0</span>]  num_of_retry=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(trans<span class="variable">.retry_if_nack</span>) </span><br><span class="line">      num_of_retry = trans<span class="variable">.num_of_retry</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      num_of_retry=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span>(trans<span class="variable">.cmd</span>)</span><br><span class="line">    I2C_WRITE:</span><br><span class="line">      </span><br><span class="line">    I2C_READ: </span><br><span class="line">      </span><br><span class="line">    I2C_GEN_CALL: </span><br><span class="line">      </span><br><span class="line">    I2C_DEVICE_ID: </span><br><span class="line">     </span><br><span class="line">  <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endtask</span> : drive_data</span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span> // LVC_I2C_MASTER_DRIVER_COMMON_SV</span></span><br></pre></td></tr></table></figure>
<h4 id="start-gen"><a href="#start-gen" class="headerlink" title="start_gen()"></a>start_gen()</h4><ul>
<li>mos管导通，将scl和sda两根线拉高</li>
<li>等待1000个外部时钟，将sda置低</li>
<li>已经完成启动，但是需要等待sta_hd个外部时钟，将scl置低，因为scl为高时，数据不能变，为低时才真正把数据放到总线上</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::start_gen();</span><br><span class="line">  <span class="keyword">if</span>(lock<span class="variable">.try_get</span>()) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//repeat(1000) @(posedge i2c_if.CLK);</span></span><br><span class="line">    i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">    i2c_if<span class="variable">.sda_master</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeat</span>(<span class="number">1000</span>) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">    i2c_if<span class="variable">.sda_master</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">repeat</span>(sta_hd) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">    i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//-&gt;i2c_if.event_master_start_generated;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="meta">`uvm_info("start", "Because The Last Transaction Have Generate Restart CMD, This Transation Need Not Generate Start CMD", UVM_DEBUG);</span></span><br><span class="line"><span class="keyword">endtask</span> : start_gen</span><br></pre></td></tr></table></figure>
<h4 id="stop-gen"><a href="#stop-gen" class="headerlink" title="stop_gen()"></a>stop_gen()</h4><p>等待4个时间</p>
<ul>
<li>wait_data_hd_time()：数据的hold time，在子类中定义；将sda置为0</li>
<li>i2c_clk_low个外部时钟，将scl置为1</li>
<li>sto_su个外部时钟，将sda拉高</li>
<li>再等待tbuf_time个外部时钟，释放锁，此时其他master可以通过start_gen来获取锁</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::stop_gen();</span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          wait_data_hd_time();</span><br><span class="line">          i2c_if<span class="variable">.sda_master</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">          i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">wait</span>(i2c_if<span class="variable">.SCL</span> == <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line">  <span class="keyword">repeat</span>(sto_su) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">  i2c_if<span class="variable">.sda_master</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeat</span>(tbuf_time) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line"><span class="comment">//  i2c_if.scl_master = 1'bz;</span></span><br><span class="line"><span class="comment">//  i2c_if.sda_master = 1'bz;</span></span><br><span class="line">  <span class="comment">//-&gt;i2c_if.event_master_stop_generated;</span></span><br><span class="line">  lock<span class="variable">.put</span>();</span><br><span class="line"><span class="keyword">endtask</span> : stop_gen</span><br></pre></td></tr></table></figure>
<h4 id="re-start-gen"><a href="#re-start-gen" class="headerlink" title="re_start_gen()"></a>re_start_gen()</h4><p>和start非常类似，但是需要考虑当前两根线的状态，不能直接置为1</p>
<p>scl在每次传输结束时都置为0，等待i2c_clk_low个外部时钟后，再将其拉高</p>
<p>在低电平期间将sda置1，比scl置1早re_sta_su个外部时钟</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::re_start_gen();</span><br><span class="line">  <span class="comment">//bus free time, hs mode no this parameter.</span></span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">          i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">repeat</span>(i2c_clk_low-re_sta_su) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">          i2c_if<span class="variable">.sda_master</span> = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeat</span>(re_sta_su) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">  i2c_if<span class="variable">.sda_master</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">repeat</span>(sta_hd) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">  i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//-&gt;i2c_if.event_master_repeated_start_generated;</span></span><br><span class="line"><span class="keyword">endtask</span> : re_start_gen</span><br></pre></td></tr></table></figure>
<h4 id="send-byte"><a href="#send-byte" class="headerlink" title="send_byte"></a>send_byte</h4><p>8位bit的发送+判断是否响应</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::send_byte(<span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] send_byte);</span><br><span class="line">  <span class="comment">// i2c_if.scl_master = 0;</span></span><br><span class="line"> <span class="comment">//  wait(i2c_if.SCL&amp;i2c_if.SDA != 1'bz); //stretch release</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          wait_data_hd_time();</span><br><span class="line">          i2c_if<span class="variable">.sda_master</span>=send_byte[i];</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">          i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">wait</span>(i2c_if<span class="variable">.SCL</span> == <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line">  <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">  i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line"> <span class="comment">//         wait_data_hd_time();</span></span><br><span class="line"><span class="comment">//          i2c_if.sda_master = 1'bz;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">          i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(i2c_if<span class="variable">.sda_master</span> != <span class="number">0</span>)</span><br><span class="line">            nack_flag=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            nack_flag=<span class="number">0</span>;</span><br><span class="line">          <span class="comment">//`uvm_error("master driver sent byte to slave","slave send no ack to master.")</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line">  <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">  i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endtask</span> : send_byte</span><br></pre></td></tr></table></figure>
<h4 id="接收byte发送应答"><a href="#接收byte发送应答" class="headerlink" title="接收byte发送应答"></a>接收byte发送应答</h4><p>和写一样，每次scl为1时采集数据；</p>
<p>8个数据读完后要发送1个应答位</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::recv_byte(<span class="keyword">output</span> <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] recv_data);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">    i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">    recv_data[i] = i2c_if<span class="variable">.SDA</span>;</span><br><span class="line">    <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">    i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      wait_data_hd_time();</span><br><span class="line">      i2c_if<span class="variable">.sda_master</span> = <span class="number">0</span>;   <span class="comment">//send ack to slave</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">      i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line">  <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">  i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// wait_data_hd_time();</span></span><br><span class="line"><span class="comment">//  i2c_if.sda_master = 1'bz;</span></span><br><span class="line"><span class="keyword">endtask</span> : recv_byte</span><br></pre></td></tr></table></figure>
<h4 id="接收byte发送非应答"><a href="#接收byte发送非应答" class="headerlink" title="接收byte发送非应答"></a>接收byte发送非应答</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::recv_byte_noack(<span class="keyword">output</span> <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] recv_data);  <span class="comment">//the last data received, master will sent out a n-ack to slave</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">    i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">    recv_data[i] = i2c_if<span class="variable">.SDA</span>;</span><br><span class="line">    <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">    i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      wait_data_hd_time();</span><br><span class="line">      i2c_if<span class="variable">.sda_master</span> = <span class="number">1</span>;   <span class="comment">//send n-ack to slave</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">      i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line">  <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">  i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//  wait_data_hd_time();</span></span><br><span class="line"><span class="comment">//  i2c_if.sda_master = 1'bz;</span></span><br><span class="line"><span class="keyword">endtask</span> : recv_byte_noack</span><br></pre></td></tr></table></figure>
<h4 id="send-start-byte"><a href="#send-start-byte" class="headerlink" title="send_start_byte"></a>send_start_byte</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::send_start_byte();</span><br><span class="line">    <span class="keyword">bit</span>[<span class="number">8</span>:<span class="number">0</span>]  start_byte = <span class="number">9'b000000011</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">8</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">fork</span></span><br><span class="line">          <span class="keyword">begin</span></span><br><span class="line">              wait_data_hd_time();</span><br><span class="line">              i2c_if<span class="variable">.sda_master</span>=start_byte[i];</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">begin</span></span><br><span class="line">              <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">              i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">    i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//-&gt;i2c_if.event_master_start_byte_transmited;</span></span><br><span class="line">    re_start_gen();</span><br><span class="line"><span class="keyword">endtask</span> : send_start_byte</span><br></pre></td></tr></table></figure>
<h4 id="7bit地址传输"><a href="#7bit地址传输" class="headerlink" title="7bit地址传输"></a>7bit地址传输</h4><ul>
<li><p>一个bit位的传输逻辑</p>
<p>前面start开启的时候scl已经置0了，数据可以直接放上来；</p>
<p>因为wait_data_hd_time()等待dat_hd个外部时钟，远小于i2c_clk_low。所以在scl低电平期间，数据已经建立；</p>
<p>然后将scl置1，高电平维持i2c_clk_high个外部时钟；</p>
<p>最后将scl置0，一次bit传输结束</p>
<p>可以看到：每次开始，或者1bit传输结束后，scl都置为0，以等待下一个bit的传输</p>
</li>
<li><p>一个byte的传输逻辑</p>
<p>传完7bit地址和1bit的rw，在下一个高电平期间采样，采样sda判断是否为1</p>
<p>为1则有应答，为0则无应答</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::rw_slave_7bit_addr(<span class="keyword">bit</span>[<span class="number">6</span>:<span class="number">0</span>] addr, <span class="keyword">bit</span> rw);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">6</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          wait_data_hd_time();</span><br><span class="line">          i2c_if<span class="variable">.sda_master</span> = addr[i];</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">          i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">    i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          wait_data_hd_time();</span><br><span class="line">          i2c_if<span class="variable">.sda_master</span> = rw;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">          i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line">  <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">  i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//          wait_data_hd_time();</span></span><br><span class="line"><span class="comment">//          i2c_if.sda_master = 1'bz;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">          i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(i2c_if<span class="variable">.sda_master</span> !=<span class="number">0</span>)</span><br><span class="line">            nack_flag = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            nack_flag = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">//`uvm_error("master driver sent 7 bit slave addr","slave send no ack to master.")</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">  i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endtask</span> : rw_slave_7bit_addr</span><br></pre></td></tr></table></figure>
<h4 id="10bit地址传输"><a href="#10bit地址传输" class="headerlink" title="10bit地址传输"></a>10bit地址传输</h4><p>两个字节，明显要复杂一些，但是串行驱动的本质不变</p>
<p>和7位地址的区别在于：10位地址的读需要重启</p>
<p>写的话类似：</p>
<ul>
<li>先组装第一个字节数组，传第一个字节，然后再传第二个low_address字节</li>
</ul>
<p>读的话有点意思：</p>
<ul>
<li>第一个字节的读写位同样是0（写），然后再传第二个low_address字节</li>
<li>想要修改读写位只能重启re_start_gen()，只需要重传高8位，将读写位改为1</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver_common::rw_slave_10bit_addr(<span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] addr, <span class="keyword">bit</span> rw);</span><br><span class="line">   <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] wr_fst_byte = &#123;<span class="number">5'b11110</span>,addr[<span class="number">9</span>:<span class="number">8</span>],<span class="number">1'b0</span>&#125;; </span><br><span class="line">   <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] rd_fst_byte = &#123;<span class="number">5'b11110</span>,addr[<span class="number">9</span>:<span class="number">8</span>],<span class="number">1'b1</span>&#125;; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(rw == <span class="number">0</span>)  <span class="keyword">begin</span>  <span class="comment">//write data to 10bits address slave</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span>   <span class="comment">//write 10bits address high 2bit</span></span><br><span class="line">       <span class="keyword">fork</span></span><br><span class="line">           <span class="keyword">begin</span></span><br><span class="line">               wait_data_hd_time();</span><br><span class="line">               i2c_if<span class="variable">.sda_master</span> = wr_fst_byte[i];</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">           <span class="keyword">begin</span></span><br><span class="line">               <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">               i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">join</span></span><br><span class="line">       <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">       i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">fork</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//         wait_data_hd_time();</span></span><br><span class="line"><span class="comment">//         i2c_if.sda_master = 1'bz;</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">         i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(i2c_if<span class="variable">.sda_master</span> !=<span class="number">0</span>)</span><br><span class="line">           nack_flag=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           nack_flag=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//`uvm_error("master driver sent 10 bit slave addr","slave send no ack to master.")</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">join</span></span><br><span class="line">     <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);   </span><br><span class="line">     i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">////////////   </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span>   <span class="comment">//write 10bits address low 8bit</span></span><br><span class="line">       <span class="keyword">fork</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">           wait_data_hd_time();</span><br><span class="line">           i2c_if<span class="variable">.sda_master</span> = addr[i];</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">           <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">           i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">join</span></span><br><span class="line">       <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">       i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">fork</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line"> <span class="comment">//        wait_data_hd_time();</span></span><br><span class="line"><span class="comment">//         i2c_if.sda_master = 1'bz;</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">         i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(i2c_if<span class="variable">.sda_master</span> !=<span class="number">0</span>)</span><br><span class="line">           nack_flag=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           nack_flag=<span class="number">0</span>;</span><br><span class="line">          <span class="comment">//`uvm_error("master driver sent 10 bit slave addr","slave send no ack to master.")</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">join</span>      </span><br><span class="line">       <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">       i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">end</span> </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span>          <span class="comment">//read data from 10bits address slave</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span>   <span class="comment">//write 10bits address high 2bit</span></span><br><span class="line">       <span class="keyword">fork</span></span><br><span class="line">           <span class="keyword">begin</span></span><br><span class="line">               wait_data_hd_time();</span><br><span class="line">               i2c_if<span class="variable">.sda_master</span> = wr_fst_byte[i];</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">           <span class="keyword">begin</span></span><br><span class="line">               <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">               i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">join</span></span><br><span class="line">       <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">       i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">fork</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line"> <span class="comment">//        wait_data_hd_time();</span></span><br><span class="line"><span class="comment">//         i2c_if.sda_master = 1'bz;</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">         i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(i2c_if<span class="variable">.sda_master</span> !=<span class="number">0</span>)</span><br><span class="line">           nack_flag=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           nack_flag=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//`uvm_error("master driver sent 10 bit slave addr","slave send no ack to master.")</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">join</span></span><br><span class="line">     <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">     i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span>   <span class="comment">//write 10bits address low 8bit</span></span><br><span class="line">       <span class="keyword">fork</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">           wait_data_hd_time();</span><br><span class="line">           i2c_if<span class="variable">.sda_master</span> = addr[i];</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">           <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">           i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">join</span></span><br><span class="line">       <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">       i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">fork</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line"> <span class="comment">//        wait_data_hd_time();</span></span><br><span class="line"> <span class="comment">//        i2c_if.sda_master = 1'bz;</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">         i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(i2c_if<span class="variable">.sda_master</span> !=<span class="number">0</span>)</span><br><span class="line">           nack_flag=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           nack_flag=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//`uvm_error("master driver sent 10 bit slave addr","slave send no ack to master.")</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">join</span></span><br><span class="line">      <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">      i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">     re_start_gen();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span>   <span class="comment">//write 10bits address high 2bit</span></span><br><span class="line">       <span class="keyword">fork</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">           wait_data_hd_time();</span><br><span class="line">           i2c_if<span class="variable">.sda_master</span> = rd_fst_byte[i];</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">           <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">            i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">       <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">       i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">fork</span></span><br><span class="line">     <span class="keyword">begin</span></span><br><span class="line"> <span class="comment">//      wait_data_hd_time();</span></span><br><span class="line"> <span class="comment">//      i2c_if.sda_master = 1'bz;</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">begin</span></span><br><span class="line">       <span class="keyword">repeat</span>(i2c_clk_low) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">       i2c_if<span class="variable">.scl_master</span> = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>(i2c_if<span class="variable">.sda_master</span> !=<span class="number">0</span>)</span><br><span class="line">         nack_flag=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         nack_flag=<span class="number">0</span>;</span><br><span class="line">          <span class="comment">//`uvm_error("master driver sent 10 bit slave addr","slave send no ack to master.")</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">join</span></span><br><span class="line">       <span class="keyword">repeat</span>(i2c_clk_high) @(<span class="keyword">posedge</span> i2c_if<span class="variable">.CLK</span>);</span><br><span class="line">       i2c_if<span class="variable">.scl_master</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span> : rw_slave_10bit_addr</span><br></pre></td></tr></table></figure>
<h4 id="I2C-WRITE"><a href="#I2C-WRITE" class="headerlink" title="I2C_WRITE:"></a>I2C_WRITE:</h4><ul>
<li>判断模式是标准还是快速，标准模式直接执行start_gen()，判断是否发送start_byte。快速模式需要先来一套二连，然后执行re_start_gen() </li>
<li>选择地址模式并发送地址，处理非应答情况</li>
<li>发送transcation中的数据，每个字节都要处理非应答情况</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">I2C_WRITE:</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> retry_num=<span class="number">0</span>; retry_num&lt;=num_of_retry; ) <span class="keyword">begin</span></span><br><span class="line">          nack_flag = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(cfg<span class="variable">.bus_speed</span> == HIGHSPEED_MODE) <span class="keyword">begin</span></span><br><span class="line">              <span class="keyword">if</span>(cfg<span class="variable">.start_hs_in_fm_plus</span>==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                  pre_hs_in_fm_start_gen();</span><br><span class="line">                  pre_hs_in_fm_send_byte(hs_code);</span><br><span class="line">              <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                  pre_hs_in_fm_plus_start_gen();</span><br><span class="line">                  pre_hs_in_fm_plus_send_byte(hs <span class="number">_</span>code);</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">              re_start_gen();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(trans<span class="variable">.addr_10bit</span> ==<span class="number">1</span>)</span><br><span class="line">                  rw_slave_10bit_addr(trans<span class="variable">.addr</span>, <span class="number">0</span>);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  rw_slave_7bit_addr(trans<span class="variable">.addr</span>[<span class="number">6</span>:<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// check and response when addr/send_start_byte nack generated by slave    </span></span><br><span class="line">              <span class="keyword">if</span>(nack_flag==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                  <span class="keyword">if</span>(num_of_retry==<span class="number">0</span> | !trans<span class="variable">.retry_if_nack</span>) <span class="keyword">begin</span></span><br><span class="line">                      stop_gen();</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(retry_num==num_of_retry) <span class="keyword">begin</span></span><br><span class="line">                      retry_num++; </span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                      retry_num++;</span><br><span class="line">                      <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                          stop_gen();</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          re_start_gen();</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">end</span>  <span class="comment">//if(nack_flag==1)</span></span><br><span class="line">            </span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;trans<span class="variable">.data</span><span class="variable">.size</span>();i++)</span><br><span class="line">              <span class="keyword">begin</span></span><br><span class="line">                  send_byte(trans<span class="variable">.data</span>[i]);</span><br><span class="line">                  <span class="comment">// check and response when data nack generated by slave    </span></span><br><span class="line">                  <span class="keyword">if</span>(nack_flag==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                      <span class="keyword">if</span>(num_of_retry==<span class="number">0</span> | !trans<span class="variable">.retry_if_nack</span>) <span class="keyword">begin</span></span><br><span class="line">                          stop_gen();</span><br><span class="line">                          <span class="keyword">return</span>;</span><br><span class="line">                      <span class="keyword">end</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span>(retry_num==num_of_retry) <span class="keyword">begin</span></span><br><span class="line">                          retry_num++;</span><br><span class="line">                          <span class="keyword">continue</span>;</span><br><span class="line">                      <span class="keyword">end</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                          retry_num++;</span><br><span class="line">                          <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                              stop_gen();</span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              re_start_gen();</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">end</span></span><br><span class="line">                     <span class="comment">// if(trans.retry_if_nack) begin</span></span><br><span class="line">                     <span class="comment">//     re_start_gen();</span></span><br><span class="line">                     <span class="comment">//     break;</span></span><br><span class="line">                     <span class="comment">// end</span></span><br><span class="line">                     <span class="comment">// else begin</span></span><br><span class="line">                     <span class="comment">//     stop_gen();</span></span><br><span class="line">                     <span class="comment">//     return;</span></span><br><span class="line">                     <span class="comment">// end</span></span><br><span class="line">                  <span class="keyword">end</span> <span class="comment">//if(nack_flag==1)</span></span><br><span class="line">              <span class="keyword">end</span><span class="comment">//for(int i=0; i&lt;trans.data.size();i++)</span></span><br><span class="line">              </span><br><span class="line">              <span class="keyword">if</span>(nack_flag==<span class="number">0</span> | retry_num==num_of_retry+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                  <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                      stop_gen();</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      re_start_gen();</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">end</span> <span class="comment">//if(nack_flag==0)</span></span><br><span class="line">          <span class="keyword">end</span> <span class="comment">//if(cfg.bus_speed == HIGHSPEED_MODE)</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">              start_gen();</span><br><span class="line">            </span><br><span class="line">              <span class="keyword">if</span>(trans<span class="variable">.send_start_byte</span> == <span class="number">1</span>)</span><br><span class="line">                  send_start_byte();</span><br><span class="line">           </span><br><span class="line">              <span class="keyword">if</span>(trans<span class="variable">.addr_10bit</span> ==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                  is10bits_again=<span class="number">1</span>;</span><br><span class="line">                  pre_addr=trans<span class="variable">.addr</span>;</span><br><span class="line"></span><br><span class="line">                  rw_slave_10bit_addr(trans<span class="variable">.addr</span>, <span class="number">0</span>);</span><br><span class="line">              <span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">                  rw_slave_7bit_addr(trans<span class="variable">.addr</span>[<span class="number">6</span>:<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">              <span class="comment">// check and response when addr/send_byte nack generated by slave    </span></span><br><span class="line">              <span class="keyword">if</span>(nack_flag==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                  <span class="keyword">if</span>(num_of_retry==<span class="number">0</span> | !trans<span class="variable">.retry_if_nack</span>) <span class="keyword">begin</span></span><br><span class="line">                      stop_gen();</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(retry_num==num_of_retry) <span class="keyword">begin</span></span><br><span class="line">                      retry_num++;</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                      retry_num++;</span><br><span class="line">                      <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                          stop_gen();</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          re_start_gen();                      </span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                 <span class="comment">// if(retry_num==trans.num_of_retry | !trans.retry_if_nack) begin</span></span><br><span class="line">                 <span class="comment">//     stop_gen();</span></span><br><span class="line">                 <span class="comment">//     return;</span></span><br><span class="line">                 <span class="comment">// end</span></span><br><span class="line">                 <span class="comment">// else begin</span></span><br><span class="line">                 <span class="comment">//     re_start_gen();</span></span><br><span class="line">                 <span class="comment">//     continue;</span></span><br><span class="line">                 <span class="comment">// end</span></span><br><span class="line">              <span class="keyword">end</span> <span class="comment">//if(nack_flag==1)</span></span><br><span class="line">            </span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;trans<span class="variable">.data</span><span class="variable">.size</span>();i++)</span><br><span class="line">              <span class="keyword">begin</span></span><br><span class="line">                  send_byte(trans<span class="variable">.data</span>[i]);</span><br><span class="line">                  <span class="comment">// check and response when data nack generated by slave    </span></span><br><span class="line">                  <span class="keyword">if</span>(nack_flag==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                      <span class="keyword">if</span>(num_of_retry==<span class="number">0</span> | !trans<span class="variable">.retry_if_nack</span>) <span class="keyword">begin</span></span><br><span class="line">                          stop_gen();</span><br><span class="line">                          <span class="keyword">return</span>;</span><br><span class="line">                      <span class="keyword">end</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span>(retry_num==num_of_retry) <span class="keyword">begin</span></span><br><span class="line">                          retry_num++;</span><br><span class="line">                          <span class="keyword">continue</span>;</span><br><span class="line">                      <span class="keyword">end</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                          retry_num++;</span><br><span class="line">                          <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                              stop_gen();</span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              re_start_gen();</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">end</span>  <span class="comment">//for(int i=0; i&lt;trans.data.size();i++)</span></span><br><span class="line">            </span><br><span class="line">              <span class="keyword">if</span>(nack_flag==<span class="number">0</span> | retry_num==num_of_retry+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                  <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                      stop_gen();</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      re_start_gen();</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">end</span>  <span class="comment">//if(nack_flag==0)</span></span><br><span class="line">          <span class="keyword">end</span>  <span class="comment">//else high_speed</span></span><br><span class="line">      <span class="keyword">end</span> <span class="comment">//for(int i=0; i&lt;=trans.num_of_retry; i++)</span></span><br></pre></td></tr></table></figure>
<h4 id="I2C-READ"><a href="#I2C-READ" class="headerlink" title="I2C_READ:"></a>I2C_READ:</h4><p>和I2C_WRITE完全一致</p>
<h4 id="I2C-GEN-CALL"><a href="#I2C-GEN-CALL" class="headerlink" title="I2C_GEN_CALL:"></a>I2C_GEN_CALL:</h4><p>只需要考虑标准模式:</p>
<ul>
<li>执行start_gen()；</li>
<li>判断是否发送start_byte</li>
<li>发送第一个字节+非应答处理+发送第二个信号+非应答处理</li>
<li>循环发送data字节+非应答处理</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">I2C_GEN_CALL: </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> retry_num=<span class="number">0</span>; retry_num&lt;=num_of_retry;) <span class="keyword">begin</span>  </span><br><span class="line">          start_gen();</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span>(trans<span class="variable">.send_start_byte</span>==<span class="number">1</span>)</span><br><span class="line">              send_start_byte();</span><br><span class="line">          </span><br><span class="line">          send_byte(gen_call_first_byte);</span><br><span class="line">          <span class="comment">// check and response when addr/send_start_byte nack generated by slave    </span></span><br><span class="line">          <span class="keyword">if</span>(nack_flag==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">              <span class="keyword">if</span>(num_of_retry==<span class="number">0</span> | !trans<span class="variable">.retry_if_nack</span>) <span class="keyword">begin</span></span><br><span class="line">                  stop_gen();</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(retry_num==num_of_retry) <span class="keyword">begin</span></span><br><span class="line">                  retry_num++;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                  retry_num++;</span><br><span class="line">                  <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                      stop_gen();</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      re_start_gen();                      </span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">end</span> <span class="comment">//if(nack_flag==1)</span></span><br><span class="line">          <span class="comment">//-&gt;i2c_if.event_master_general_call_addr_sent;</span></span><br><span class="line">          send_byte(gen_call_second_byte);</span><br><span class="line">          <span class="comment">// check and response when addr/send_start_byte nack generated by slave    </span></span><br><span class="line">          <span class="keyword">if</span>(nack_flag==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">              <span class="keyword">if</span>(num_of_retry==<span class="number">0</span> | !trans<span class="variable">.retry_if_nack</span>) <span class="keyword">begin</span></span><br><span class="line">                  stop_gen();</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(retry_num==num_of_retry) <span class="keyword">begin</span></span><br><span class="line">                  retry_num++;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                  retry_num++;</span><br><span class="line">                  <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                      stop_gen();</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      re_start_gen();                      </span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">          <span class="comment">//-&gt;i2c_if.event_master_general_call_sec_byte_sent;</span></span><br><span class="line">          <span class="comment">//if(gen_call_second_byte[0]==1'b1) begin</span></span><br><span class="line">          <span class="comment">//if send_start_byte==1,send start byte.</span></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;trans<span class="variable">.data</span><span class="variable">.size</span>();i++)</span><br><span class="line">          <span class="keyword">begin</span></span><br><span class="line">              send_byte(trans<span class="variable">.data</span>[i]);</span><br><span class="line">              <span class="comment">// check and response when data nack generated by slave    </span></span><br><span class="line">              <span class="keyword">if</span>(nack_flag==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                  <span class="keyword">if</span>(num_of_retry==<span class="number">0</span> | !trans<span class="variable">.retry_if_nack</span>) <span class="keyword">begin</span></span><br><span class="line">                      stop_gen();</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(retry_num==num_of_retry) <span class="keyword">begin</span></span><br><span class="line">                      retry_num++;</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                      retry_num++;</span><br><span class="line">                      <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                          stop_gen();</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          re_start_gen();</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">end</span>     </span><br><span class="line">              <span class="keyword">end</span>  <span class="comment">//  if(nack_flag==1)           </span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span>(nack_flag==<span class="number">0</span> | retry_num==num_of_retry+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">              <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                  stop_gen();</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  re_start_gen();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">end</span>  <span class="comment">//if(nack_flag==0)</span></span><br><span class="line">      <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="I2C-DEVICE-ID"><a href="#I2C-DEVICE-ID" class="headerlink" title="I2C_DEVICE_ID:"></a>I2C_DEVICE_ID:</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">I2C_DEVICE_ID: </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> retry_num=<span class="number">0</span>; retry_num&lt;=num_of_retry; ) <span class="keyword">begin</span>  </span><br><span class="line">          start_gen();</span><br><span class="line">          send_byte(device_id_w);</span><br><span class="line">          <span class="comment">// check and response when addr/send_start_byte nack generated by slave    </span></span><br><span class="line">          <span class="keyword">if</span>(nack_flag==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">              <span class="keyword">if</span>(num_of_retry==<span class="number">0</span> | !trans<span class="variable">.retry_if_nack</span>) <span class="keyword">begin</span></span><br><span class="line">                  stop_gen();</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(retry_num==num_of_retry) <span class="keyword">begin</span></span><br><span class="line">                  retry_num++; </span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                  retry_num++;</span><br><span class="line">                  <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                      stop_gen();</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      re_start_gen();</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(trans<span class="variable">.addr_10bit</span> ==<span class="number">1</span>)</span><br><span class="line">              rw_slave_10bit_addr(trans<span class="variable">.addr</span>, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              rw_slave_7bit_addr(trans<span class="variable">.addr</span>[<span class="number">6</span>:<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">          <span class="comment">//ack/noack don't care</span></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span>(trans<span class="variable">.m_device_id_gen_stop</span>==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">              re_start_gen();</span><br><span class="line">              send_byte(device_id_r);</span><br><span class="line">              <span class="comment">// check and response when addr/send_start_byte nack generated by slave    </span></span><br><span class="line">              <span class="keyword">if</span>(nack_flag==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                  <span class="keyword">if</span>(num_of_retry==<span class="number">0</span> | !trans<span class="variable">.retry_if_nack</span>) <span class="keyword">begin</span></span><br><span class="line">                      stop_gen();</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(retry_num==num_of_retry) <span class="keyword">begin</span></span><br><span class="line">                      retry_num++; </span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                      retry_num++;</span><br><span class="line">                      <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>) <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                          stop_gen();</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          re_start_gen();</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">end</span> <span class="comment">//if(nack_flag==1)</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(trans<span class="variable">.device_id_rollback_iteration</span> ==<span class="number">0</span>)  <span class="keyword">begin</span>   <span class="comment">//no rollback</span></span><br><span class="line">                  <span class="keyword">case</span>(trans<span class="variable">.nack_at_device_id_byte</span>)</span><br><span class="line">                    <span class="number">1</span>:</span><br><span class="line">                      <span class="keyword">begin</span></span><br><span class="line">                          recv_byte_noack(recv_data);</span><br><span class="line">                          trans<span class="variable">.data</span>[<span class="number">0</span>] = recv_data;</span><br><span class="line">                          </span><br><span class="line">                          <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>  | retry_num==num_of_retry+<span class="number">1</span>  | retry_num==<span class="number">0</span>) <span class="keyword">begin</span> <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                              retry_num++;</span><br><span class="line">                              stop_gen();</span><br><span class="line">                          <span class="keyword">end</span></span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              re_start_gen();</span><br><span class="line">                          <span class="keyword">break</span>;                            </span><br><span class="line">                      <span class="keyword">end</span></span><br><span class="line">                    <span class="number">2</span>:</span><br><span class="line">                      <span class="keyword">begin</span></span><br><span class="line">                          recv_byte(recv_data);</span><br><span class="line">                          trans<span class="variable">.data</span>[<span class="number">0</span>] = recv_data;</span><br><span class="line">                          recv_byte_noack(recv_data);</span><br><span class="line">                          trans<span class="variable">.data</span>[<span class="number">1</span>] = recv_data;</span><br><span class="line">                          </span><br><span class="line">                          <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>  | retry_num==num_of_retry+<span class="number">1</span>  | retry_num==<span class="number">0</span>) <span class="keyword">begin</span> <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                              retry_num++;</span><br><span class="line">                              stop_gen();</span><br><span class="line">                          <span class="keyword">end</span></span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              re_start_gen();</span><br><span class="line">                          </span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                      <span class="keyword">begin</span></span><br><span class="line">                          recv_byte(recv_data);</span><br><span class="line">                          trans<span class="variable">.data</span>[<span class="number">0</span>] = recv_data;</span><br><span class="line">                          recv_byte(recv_data);</span><br><span class="line">                          trans<span class="variable">.data</span>[<span class="number">1</span>] = recv_data;</span><br><span class="line">                          recv_byte_noack(recv_data);</span><br><span class="line">                          trans<span class="variable">.data</span>[<span class="number">2</span>] = recv_data;</span><br><span class="line">                          </span><br><span class="line">                          <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>  | retry_num==num_of_retry+<span class="number">1</span>  | retry_num==<span class="number">0</span>) <span class="keyword">begin</span> <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                              retry_num++;</span><br><span class="line">                              stop_gen();</span><br><span class="line">                          <span class="keyword">end</span></span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              re_start_gen();</span><br><span class="line">                          </span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">              <span class="keyword">end</span>  <span class="comment">//if(trans.device_id_rollback_iteration ==0)</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">begin</span>    <span class="comment">//rollback</span></span><br><span class="line">                  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;trans<span class="variable">.nack_at_device_id_byte</span>-<span class="number">1</span>;i++) <span class="keyword">begin</span></span><br><span class="line">                      recv_byte(recv_data);</span><br><span class="line">                      trans<span class="variable">.data</span>[i] = recv_data;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  recv_byte_noack(recv_data);</span><br><span class="line">                  trans<span class="variable">.data</span>[trans<span class="variable">.nack_at_device_id_byte</span>-<span class="number">1</span>] = recv_data;</span><br><span class="line">                </span><br><span class="line">                  <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>  | retry_num==num_of_retry+<span class="number">1</span>  | retry_num==<span class="number">0</span>) <span class="keyword">begin</span> <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                      retry_num++;</span><br><span class="line">                      stop_gen();</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      re_start_gen();</span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">break</span>;                  </span><br><span class="line">              <span class="keyword">end</span><span class="comment">//else begin    //rollback</span></span><br><span class="line">          <span class="keyword">end</span><span class="comment">//if(trans.m_device_id_gen_stop==0)</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">              <span class="keyword">if</span>(trans<span class="variable">.sr_or_p_gen</span>==<span class="number">0</span>  | retry_num==num_of_retry+<span class="number">1</span>  | retry_num==<span class="number">0</span>) <span class="keyword">begin</span> <span class="comment">//0--gen sotp, 1--gen re-start</span></span><br><span class="line">                  retry_num++;</span><br><span class="line">                  stop_gen();</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  re_start_gen();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="master-driver"><a href="#master-driver" class="headerlink" title="master_driver"></a>master_driver</h3><p>核心方法是 ： run_phase中的consume_from_seq_item_port()</p>
<p>调用的核心驱动方式是子类的：common.send_xact(trans);</p>
<p>没有通过seq_item_port.item_done(rsp)的方式返回rsp，而是调用方法put_response_to_seq_item_port(lvc_i2c_master_transaction xact, int drop = 0);</p>
<p>该方法内部声明了一个带锁线程，当多个master同时驱动时</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifndef</span> LVC_I2C_MASTER_DRIVER_SVH</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> LVC_I2C_MASTER_DRIVER_SVH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> lvc_i2c_master_driver <span class="keyword">extends</span> uvm_driver <span class="variable">#(lvc_i2c_master_transaction)</span>;</span><br><span class="line"></span><br><span class="line">  uvm_analysis_port <span class="variable">#(lvc_i2c_master_transaction)</span>   trans_port;</span><br><span class="line"></span><br><span class="line">  lvc_i2c_master_driver_common common;</span><br><span class="line"></span><br><span class="line">  lvc_i2c_agent_configuration cfg_snapshot;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">local</span> semaphore collect_xact;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">local</span> lvc_i2c_agent_configuration  cfg;</span><br><span class="line"></span><br><span class="line">  uvm_event_pool event_pool;</span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_register_cb(lvc_i2c_master_driver, lvc_i2c_master_driver_callback)</span></span><br><span class="line">  <span class="comment">// This macro performs UVM object creation, type control manipulation, and </span></span><br><span class="line">  <span class="comment">// factory registration</span></span><br><span class="line">  <span class="meta">`uvm_component_utils_begin(lvc_i2c_master_driver)</span></span><br><span class="line">     <span class="comment">// USER: Register fields here</span></span><br><span class="line">     <span class="meta">`uvm_field_object(cfg, UVM_ALL_ON)</span></span><br><span class="line">  <span class="meta">`uvm_component_utils_end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> reconfigure_via_task(lvc_i2c_configuration cfg);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">protected</span> <span class="keyword">task</span> source_events();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> consume_from_seq_item_port();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> post_seq_item_get_cb_exec(lvc_i2c_master_transaction xact, <span class="keyword">ref</span> <span class="keyword">bit</span> drop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> put_response_to_seq_item_port(lvc_i2c_master_transaction xact, <span class="keyword">int</span> drop = <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * This task assign the virtual interfaces to #common</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">void</span> assign_vif();</span><br><span class="line">  <span class="comment">/** @endcond */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Run phase of UVM which calls consume_from_seq_item_port task */</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span> : lvc_i2c_master_driver</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lvc_i2c_master_driver::<span class="keyword">new</span> (<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">  <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">  collect_xact = <span class="keyword">new</span>(<span class="number">1</span>);</span><br><span class="line">  trans_port = <span class="keyword">new</span>(<span class="string">"trans_port"</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> lvc_i2c_master_driver::build_phase(uvm_phase phase);</span><br><span class="line">  <span class="meta">`uvm_info("build_phase", $sformatf("%s: starting...",get_type_name()), UVM_LOW)</span></span><br><span class="line">  <span class="keyword">if</span>(!uvm_config_db<span class="variable">#(lvc_i2c_agent_configuration)::get(this, "", "cfg", cfg))</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">`uvm_fatal("build_phase", "Unable to get the master agent configuration and failed to extract config info from the object")</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(cfg<span class="variable">.i2c_if</span> == <span class="literal">null</span>) <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">`uvm_fatal("build_phase", "A virtual interface was not received through the config object")</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  common = lvc_i2c_master_driver_common::type_id::create(<span class="string">"common"</span>); </span><br><span class="line">  common<span class="variable">.cfg</span> = <span class="keyword">this</span><span class="variable">.cfg</span>;</span><br><span class="line">  <span class="keyword">this</span><span class="variable">.assign_vif</span>();</span><br><span class="line"></span><br><span class="line">  event_pool = <span class="keyword">new</span>(<span class="string">"event_pool"</span>);</span><br><span class="line">  <span class="keyword">if</span>(cfg<span class="variable">.enable_driver_events</span> == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">    TX_XACT_CONSUMED = event_pool<span class="variable">.get</span>(<span class="string">"TX_XACT_CONSUMED"</span>);</span><br><span class="line">    EVENT_START_GENERATED = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_START_GENERATED"</span>);</span><br><span class="line">    EVENT_STOP_GENERATED = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_STOP_GENERATED"</span>);</span><br><span class="line">    EVENT_ACK_GENERATED = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_ACK_GENERATED"</span>);</span><br><span class="line">    EVENT_NACK_GENERATED = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_NACK_GENERATED"</span>);</span><br><span class="line">    EVENT_ACK_RECEIVED = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_ACK_RECEIVED"</span>);</span><br><span class="line">    EVENT_NACK_RECEIVED = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_NACK_RECEIVED"</span>);</span><br><span class="line">    EVENT_REPEATED_START_GENERATED = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_REPEATED_START_GENERATED"</span>);</span><br><span class="line">    EVENT_START_BYTE_TRANSMITED = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_START_BYTE_TRANSMITED"</span>);</span><br><span class="line">    EVENT_GENERAL_CALL_ADDR_SENT = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_GENERAL_CALL_ADDR_SENT"</span>);</span><br><span class="line">    EVENT_GENERAL_CALL_SEC_BYTE_SENT = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_GENERAL_CALL_SEC_BYTE_SENT"</span>);</span><br><span class="line">    EVENT_ARBITRATION_LOSS_DETECTED = event_pool<span class="variable">.get</span>(<span class="string">"EVENT_ARBITRATION_LOSS_DETECTED"</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="meta">`uvm_info("build_phase", $sformatf("%s: finishing...",get_type_name()), UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver::reconfigure_via_task(lvc_i2c_configuration cfg);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">$cast</span>(<span class="keyword">this</span><span class="variable">.cfg</span>, cfg))</span><br><span class="line">    <span class="meta">`uvm_fatal("CASTFAIL", "I2C configuration handle type inconsistence")</span></span><br><span class="line">  common<span class="variable">.reconfigure_via_task</span>(cfg);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> lvc_i2c_master_driver::post_seq_item_get(lvc_i2c_master_transaction xact, <span class="keyword">ref</span> <span class="keyword">bit</span> drop);</span><br><span class="line">  <span class="comment">// EMPTY</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver::source_events();</span><br><span class="line">  <span class="keyword">if</span>(cfg<span class="variable">.enable_driver_events</span> == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver::consume_from_seq_item_port();</span><br><span class="line">  lvc_i2c_master_transaction trans;</span><br><span class="line">  lvc_i2c_master_transaction trans_out;</span><br><span class="line">  <span class="keyword">bit</span> success = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bit</span> drop = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">    trans = <span class="keyword">new</span>();</span><br><span class="line">    <span class="meta">`uvm_info("consume_from_seq_item_port", "Get request item from sequencer...", UVM_DEBUG)</span></span><br><span class="line">    seq_item_port<span class="variable">.get_next_item</span>(trans);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">`uvm_info("consume_from_seq_item_port", "Got request item from sequencer...", UVM_DEBUG)</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>: if trans.exception_list or randomized_transaction_exception_list ??</span></span><br><span class="line">    <span class="comment">// branches open here</span></span><br><span class="line">    drop = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// callback called for loading exceptions from callbacks</span></span><br><span class="line">    post_seq_item_get_cb_exec(trans, drop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(drop) <span class="keyword">begin</span></span><br><span class="line">      <span class="meta">`uvm_info("consume_from_seq_item_port", "Drop bit set through post_seq_item_get callback. Transaction dropped", UVM_DEBUG)</span></span><br><span class="line">      <span class="comment">// put response to seq_item_port</span></span><br><span class="line">      seq_item_port<span class="variable">.put_response</span>(trans);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      <span class="comment">// Fatal if transaction received from sequencer is not valid</span></span><br><span class="line">      <span class="keyword">if</span>(!trans<span class="variable">.is_valid</span>()) <span class="keyword">begin</span></span><br><span class="line">        <span class="meta">`uvm_fatal("consume_from_seq_item_port", "Transaction received from the sequencer failed the is_valid() check")</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="comment">// Drive transaction to bus</span></span><br><span class="line">      <span class="comment">//common.send_xact(trans, trans.get_type_name());</span></span><br><span class="line">      common<span class="variable">.send_xact</span>(trans);</span><br><span class="line">      <span class="comment">// Put response object to seq_item_port</span></span><br><span class="line">      put_response_to_seq_item_port(trans);</span><br><span class="line">      <span class="meta">`uvm_info("consume_from_seq_item_port", $sformatf("lvc_i2c_master_driver: Driving transaction with cmd %s", trans.cmd), UVM_LOW)</span></span><br><span class="line">      <span class="built_in">$cast</span>(trans_out,trans<span class="variable">.clone</span>());</span><br><span class="line">      trans_port<span class="variable">.write</span>(trans_out);</span><br><span class="line">      <span class="keyword">if</span>(trans_out != <span class="literal">null</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"mater driver get trans from seq, print_driver_trans"</span>);</span><br><span class="line">        trans_out<span class="variable">.print</span>();</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      drop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// Acknowledge item_done() to sequencer</span></span><br><span class="line">    seq_item_port<span class="variable">.item_done</span>();</span><br><span class="line">    <span class="meta">`uvm_info("consume_from_seq_item_port", "Transaction Process in Driver Complete...", UVM_DEBUG)</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver::post_seq_item_get_cb_exec(lvc_i2c_master_transaction xact, <span class="keyword">ref</span> <span class="keyword">bit</span> drop);</span><br><span class="line">  post_seq_item_get(xact, drop);</span><br><span class="line">  <span class="meta">`uvm_do_callbacks(lvc_i2c_master_driver, lvc_i2c_master_driver_callback, post_seq_item_get(this, xact, drop)) </span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver::put_response_to_seq_item_port(lvc_i2c_master_transaction xact, <span class="keyword">int</span> drop = <span class="number">0</span>);</span><br><span class="line">  lvc_i2c_master_transaction resp;</span><br><span class="line">  <span class="keyword">if</span>(cfg<span class="variable">.enable_put_response</span>) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">      <span class="keyword">begin</span> : collect_and_put_response_thread</span><br><span class="line">        <span class="comment">// Grap semaphore</span></span><br><span class="line">        collect_xact<span class="variable">.get</span>();</span><br><span class="line">        <span class="comment">// Cast received xact to local resp</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">$cast</span>(resp, xact<span class="variable">.clone</span>()))</span><br><span class="line">          <span class="meta">`uvm_error("put_response_to_seq_item_port", "Failed attempting to cast response object in Master Driver")</span></span><br><span class="line">        <span class="comment">// Collect response attributes values from virtual interface</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        common<span class="variable">.collect_response_from_vif</span>(resp);  </span><br><span class="line">        resp<span class="variable">.set_id_info</span>(xact);</span><br><span class="line">        <span class="comment">// Put response to seq_item_port</span></span><br><span class="line">        seq_item_port<span class="variable">.put_response</span>(resp);</span><br><span class="line">        <span class="comment">// Release semphore</span></span><br><span class="line">        collect_xact<span class="variable">.put</span>();</span><br><span class="line">      <span class="keyword">end</span> <span class="comment">// collect_and_put_response_thread</span></span><br><span class="line">    <span class="keyword">join_none</span></span><br><span class="line">  <span class="keyword">end</span> <span class="comment">// if(cfg.enable_put_response)</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> lvc_i2c_master_driver::assign_vif();</span><br><span class="line">  common<span class="variable">.assign_vif</span>(cfg<span class="variable">.i2c_if</span>); </span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> lvc_i2c_master_driver::run_phase(uvm_phase phase);</span><br><span class="line">  <span class="meta">`uvm_info("run_phase", "lvc_i2c_master_driver::Starting...", UVM_LOW)</span></span><br><span class="line">  <span class="meta">`uvm_info("run_phase", "Wait for Reset...", UVM_DEBUG)</span></span><br><span class="line">  common<span class="variable">.wait_for_reset</span>(); </span><br><span class="line">  <span class="meta">`uvm_info("run_phase", "Wait for Observed...", UVM_DEBUG)</span></span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">    source_events();</span><br><span class="line">  <span class="comment">//join_none</span></span><br><span class="line">  consume_from_seq_item_port();</span><br><span class="line">  <span class="meta">`uvm_info("run_phase", "lvc_i2c_master_driver::Finishing...", UVM_LOW)</span></span><br><span class="line">  <span class="keyword">join_none</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span> // LVC_I2C_MASTER_DRIVER_SVH</span></span><br></pre></td></tr></table></figure>
<h3 id="slave-driver-commom"><a href="#slave-driver-commom" class="headerlink" title="slave_driver_commom"></a>slave_driver_commom</h3><p>相对清晰很多</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> lvc_i2c_slave_driver_common <span class="keyword">extends</span> lvc_i2c_bfm_common;</span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_object_utils_begin(lvc_i2c_slave_driver_common)</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_end</span></span><br><span class="line">  <span class="keyword">logic</span>   start_flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">logic</span>   end_flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">logic</span>   rs_flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>     m=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> nack_addr_count;</span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">9</span>:<span class="number">0</span>] tmp_data;</span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] mon_data[$];</span><br><span class="line">  <span class="keyword">int</span>      j=<span class="number">0</span>;</span><br><span class="line">  semaphore      lock;             <span class="comment">//if current send the restart cmd, next transaction need not to send start cmd</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">"lvc_i2c_slave_driver_common"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> slave_start();    <span class="comment">//SLAVE start generation</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> slave_end(lvc_i2c_slave_transaction trans);      <span class="comment">//SLAVE end generation</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">task</span> data_ana(lvc_i2c_slave_transaction trans);  <span class="comment">//analysis collected data from sda line.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> send_xact(lvc_i2c_slave_transaction trans);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> collect_response_from_vif(lvc_i2c_slave_transaction trans);</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h4 id="slave-start"><a href="#slave-start" class="headerlink" title="slave_start()"></a>slave_start()</h4><p>对总线进行采样，满足开始条件就尝试上锁，由当前slave执行；</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_slave_driver_common::slave_start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">    @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SDA</span>);</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span>(i2c_if<span class="variable">.SCL</span>==<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(lock<span class="variable">.try_get</span>())  <span class="keyword">begin</span></span><br><span class="line">          start_flag = <span class="number">1</span>;</span><br><span class="line">          @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line"></span><br><span class="line">          end_flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//rs_flag=0;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">          <span class="comment">// @(negedge i2c_if.SDA);</span></span><br><span class="line">          rs_flag = <span class="number">1</span>;</span><br><span class="line">          end_flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//start_flag = 0;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span> : slave_start</span><br></pre></td></tr></table></figure>
<h4 id="slave-end"><a href="#slave-end" class="headerlink" title="slave_end()"></a>slave_end()</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_slave_driver_common::slave_end(lvc_i2c_slave_transaction trans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">    @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SDA</span>);</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span>(i2c_if<span class="variable">.SCL</span>==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        trans<span class="variable">.data</span>= mon_data;</span><br><span class="line">        mon_data= &#123;&#125;;</span><br><span class="line">        j=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//   @(posedge i2c_if.SDA);</span></span><br><span class="line">        lock<span class="variable">.put</span>();</span><br><span class="line">        end_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span> : slave_end</span><br></pre></td></tr></table></figure>
<h4 id="data-ana-trans"><a href="#data-ana-trans" class="headerlink" title="data_ana(trans)"></a>data_ana(trans)</h4><p>从端驱动的核心方法</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> lvc_i2c_slave_driver_common::data_ana(lvc_i2c_slave_transaction trans);  <span class="comment">//check all protocol and collect write/read data to transaction</span></span><br><span class="line">  <span class="keyword">bit</span>      ack_nak;</span><br><span class="line">  <span class="keyword">int</span>      n=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>      deviceid=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bit</span>    flag_1=<span class="number">0</span>;</span><br><span class="line">  nack_addr_count=trans<span class="variable">.nack_addr_count</span>;</span><br><span class="line">  <span class="keyword">forever</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">wait</span>(start_flag|rs_flag);</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span>(rs_flag)</span><br><span class="line">        rs_flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    start_flag =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span></span><br><span class="line">      @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">      mon_data[j][i] = i2c_if<span class="variable">.SDA</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">casex</span>(mon_data[j])    <span class="comment">//check first byte</span></span><br><span class="line">      <span class="number">8'b0000_001x</span>,<span class="number">8'b0000_010x</span>,<span class="number">8'b0000_011x</span>:</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="meta">`uvm_error("slave driver common","slave driver receive reserved address")</span></span><br><span class="line">        <span class="comment">//send nack to master</span></span><br><span class="line">        @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">        wait_data_hd_time();</span><br><span class="line">        i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b1</span>;</span><br><span class="line">        @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">      <span class="comment">//                 i2c_if.sda_slave = 1'bz;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="number">8'b0000_0000</span>:  <span class="comment">//general call address   --done</span></span><br><span class="line">     </span><br><span class="line">      <span class="number">8'b0000_0001</span>:   <span class="comment">//start byte-done</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        j=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//  flag_1=0;</span></span><br><span class="line">        start_flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="number">8'b0000_1xxx</span>:  <span class="comment">//hs-mode slave code-done</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//send nack to master</span></span><br><span class="line">        @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">        wait_data_hd_time();</span><br><span class="line">        i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b1</span>;</span><br><span class="line">        @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">        <span class="comment">//                  i2c_if.sda_slave = 1'bz;</span></span><br><span class="line">        j=<span class="number">0</span>; <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="number">8'b1111_1xxx</span>:   <span class="comment">//device ID, --done</span></span><br><span class="line">     </span><br><span class="line">      <span class="number">8'b1111_0xxx</span>:   <span class="comment">//10-bit slave addressing--done</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(mon_data[j][<span class="number">2</span>:<span class="number">1</span>] == cfg<span class="variable">.slave_address</span>[<span class="number">9</span>:<span class="number">8</span>])   <span class="keyword">begin</span>     <span class="comment">//10bit address high two bits match</span></span><br><span class="line">          <span class="comment">//send ack and continue receive or transmit data</span></span><br><span class="line">          @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">          wait_data_hd_time();</span><br><span class="line">          i2c_if<span class="variable">.sda_slave</span> = trans<span class="variable">.nack_addr</span>;</span><br><span class="line">          <span class="keyword">if</span>(mon_data[j][<span class="number">0</span>]==<span class="number">0</span>)  <span class="keyword">begin</span>  <span class="comment">//10bit address first byte,write cmd, coutinue receive the second byte, low 8 bits address</span></span><br><span class="line">            @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">            wait_data_hd_time();</span><br><span class="line">            i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'bz</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//   j++;</span></span><br><span class="line">            <span class="comment">//receive the second byte and check if it's available</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span></span><br><span class="line">              @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">              mon_data[j][i] = i2c_if<span class="variable">.SDA</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mon_data[j] == cfg<span class="variable">.slave_address</span>[<span class="number">7</span>:<span class="number">0</span>])  <span class="keyword">begin</span>   <span class="comment">//slave low 8 bits address match,continue receive data</span></span><br><span class="line">              @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">              wait_data_hd_time();</span><br><span class="line">              i2c_if<span class="variable">.sda_slave</span> = trans<span class="variable">.nack_addr</span>;</span><br><span class="line">              @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">              wait_data_hd_time();</span><br><span class="line">              i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'bz</span>;</span><br><span class="line">              m=<span class="number">8</span>;</span><br><span class="line">              <span class="comment">//j++;</span></span><br><span class="line">              <span class="keyword">while</span>((!end_flag) &amp; (!rs_flag)) <span class="keyword">begin</span></span><br><span class="line">                @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                tmp_data[m] = i2c_if<span class="variable">.SDA</span>;</span><br><span class="line">                @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                m--;</span><br><span class="line">                <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                  wait_data_hd_time();</span><br><span class="line">                  i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b0</span>;</span><br><span class="line">                  mon_data[j] = tmp_data[<span class="number">8</span>:<span class="number">1</span>];</span><br><span class="line">                  m=<span class="number">8</span>;</span><br><span class="line">                  j++;</span><br><span class="line">                  @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                  wait_data_hd_time();</span><br><span class="line">                  i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'bz</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">if</span>(rs_flag &amp; j!=<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                trans<span class="variable">.data</span>=mon_data;</span><br><span class="line">                mon_data=&#123;&#125;;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"slv_driver trans data is %p"</span>,trans<span class="variable">.data</span>);</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">end</span> <span class="comment">//second byte match end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">              <span class="comment">//send nack and break</span></span><br><span class="line">              @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">              wait_data_hd_time();</span><br><span class="line">              i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b1</span>;</span><br><span class="line">              @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">              wait_data_hd_time();</span><br><span class="line">              i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'bz</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span>  <span class="comment">//second byte not match end</span></span><br><span class="line">          <span class="keyword">end</span>   <span class="comment">//10 bits address write end</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(mon_data[j][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">begin</span>     <span class="comment">//10bit address read</span></span><br><span class="line">            <span class="comment">//trans.data=new[3];</span></span><br><span class="line">            m=<span class="number">8</span>;n=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((!end_flag) &amp; (!rs_flag)) <span class="keyword">begin</span></span><br><span class="line">              <span class="comment">//send data to master</span></span><br><span class="line">              @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">              wait_data_hd_time();</span><br><span class="line">              i2c_if<span class="variable">.sda_slave</span>=trans<span class="variable">.data</span>[n][m-<span class="number">1</span>];</span><br><span class="line">              @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">              m--;</span><br><span class="line">              <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                m=<span class="number">8</span>;</span><br><span class="line">                n++;</span><br><span class="line">                @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                wait_data_hd_time();</span><br><span class="line">                i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'bz</span>; <span class="comment">// release bus to mst,</span></span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span>   <span class="comment">//while end</span></span><br><span class="line">          <span class="keyword">end</span>   <span class="comment">//10 bits address read end</span></span><br><span class="line">        <span class="keyword">end</span>   <span class="comment">//match end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span>  <span class="comment">//higt two bits not match</span></span><br><span class="line">          <span class="comment">//send nack and break;</span></span><br><span class="line">          @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">          wait_data_hd_time();</span><br><span class="line">          i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b1</span>;</span><br><span class="line">          @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">          wait_data_hd_time();</span><br><span class="line">          i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'bz</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">default</span>:  <span class="comment">//7bit slave address read or write, should seperate read and write, --done</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(mon_data[j][<span class="number">7</span>:<span class="number">1</span>] == cfg<span class="variable">.slave_address</span>[<span class="number">6</span>:<span class="number">0</span>]) <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">if</span>(nack_addr_count&gt;<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//send ack to master</span></span><br><span class="line">            @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">            <span class="comment">//                         wait_data_hd_time();</span></span><br><span class="line">            i2c_if<span class="variable">.sda_slave</span> = trans<span class="variable">.nack_addr</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// release bus for sr from mst</span></span><br><span class="line">            @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">            <span class="comment">//                        i2c_if.sda_slave = 1'bz;</span></span><br><span class="line">            <span class="comment">//till end of sr, then sample addr again</span></span><br><span class="line">            <span class="comment">// @(negedge i2c_if.SCL);</span></span><br><span class="line">            <span class="comment">// end_flag=0;</span></span><br><span class="line">            nack_addr_count--;</span><br><span class="line">          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>  <span class="comment">//nack_addr_count!&gt;0</span></span><br><span class="line">            <span class="comment">//send ack to master</span></span><br><span class="line">            @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">            wait_data_hd_time();</span><br><span class="line">            i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b0</span>;</span><br><span class="line">            <span class="keyword">if</span>(mon_data[j][<span class="number">0</span>]==<span class="number">0</span>)  <span class="keyword">begin</span>    <span class="comment">//write</span></span><br><span class="line">              @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">              wait_data_hd_time();</span><br><span class="line">              i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'bz</span>;</span><br><span class="line">              m=<span class="number">8</span>; j=<span class="number">0</span>;mon_data = &#123;&#125;;</span><br><span class="line">              <span class="keyword">while</span>((!end_flag) &amp; (!rs_flag)) <span class="keyword">begin</span></span><br><span class="line">                @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                tmp_data[m] = i2c_if<span class="variable">.SDA</span>;</span><br><span class="line">                @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                m--;</span><br><span class="line">                <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                  wait_data_hd_time();</span><br><span class="line">                  i2c_if<span class="variable">.sda_slave</span> = (trans<span class="variable">.nack_data</span>==j+<span class="number">1</span>) ? <span class="number">1'b1</span> : <span class="number">1'b0</span>;    <span class="comment">//send ack to master driver</span></span><br><span class="line">                  mon_data[j] = tmp_data[<span class="number">8</span>:<span class="number">1</span>];</span><br><span class="line">                  m=<span class="number">8</span>;</span><br><span class="line">                  j++;</span><br><span class="line">                  @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                  wait_data_hd_time();</span><br><span class="line">                  i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'bz</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">              <span class="keyword">end</span>  <span class="comment">//end while</span></span><br><span class="line">              <span class="keyword">if</span>(rs_flag &amp; j!=<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                trans<span class="variable">.data</span>=mon_data;</span><br><span class="line">                mon_data=&#123;&#125;;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"slv_driver trans data is %p"</span>,trans<span class="variable">.data</span>);</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span>   <span class="comment">//end write</span></span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>(mon_data[j][<span class="number">0</span>]==<span class="number">1</span>)  <span class="keyword">begin</span>    <span class="comment">//read</span></span><br><span class="line">              <span class="keyword">if</span>(deviceid==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">//send ack and continue receive or transmit data</span></span><br><span class="line">                <span class="comment">//@(negedge i2c_if.SCL);</span></span><br><span class="line">                <span class="comment">//i2c_if.sda_slave = trans.nack_addr;</span></span><br><span class="line">                @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                wait_data_hd_time();</span><br><span class="line">                i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'bz</span>; <span class="comment">// release bus to mst,</span></span><br><span class="line">                @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">              <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">                m=<span class="number">8</span>;n=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>((!end_flag) &amp; (!rs_flag)) <span class="keyword">begin</span></span><br><span class="line">                  <span class="comment">//send data to master</span></span><br><span class="line">                  @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                  wait_data_hd_time();</span><br><span class="line">                  i2c_if<span class="variable">.sda_slave</span>=trans<span class="variable">.data</span>[n][m-<span class="number">1</span>];</span><br><span class="line">                  @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                  m--;</span><br><span class="line">                  <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                    m=<span class="number">8</span>;</span><br><span class="line">                    n++;</span><br><span class="line">                    @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                    wait_data_hd_time();</span><br><span class="line">                    i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'bz</span>; <span class="comment">// release bus to mst,</span></span><br><span class="line">                    @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">                    <span class="keyword">if</span>(i2c_if<span class="variable">.SDA</span>==<span class="number">0</span>)</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span>   <span class="comment">//while end</span></span><br><span class="line">              <span class="keyword">end</span>   <span class="comment">// end</span></span><br><span class="line">            <span class="keyword">end</span>   <span class="comment">//read end</span></span><br><span class="line">          <span class="keyword">end</span> <span class="comment">// nack_addr_count end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">end</span>  <span class="comment">//address is valid end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">          <span class="comment">//send nack to master</span></span><br><span class="line">          @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">          wait_data_hd_time();</span><br><span class="line">          i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b1</span>;</span><br><span class="line">          @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">          <span class="comment">//                     i2c_if.sda_slave = 1'bz;</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span>    <span class="comment">//default end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span> : data_ana</span><br></pre></td></tr></table></figure>
<h4 id="8’b-0000-0000-广播"><a href="#8’b-0000-0000-广播" class="headerlink" title="8’b 0000_0000(广播)"></a>8’b 0000_0000(广播)</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">       trans<span class="variable">.cmd</span> = I2C_GEN_CALL;</span><br><span class="line">       <span class="comment">//send ack to master</span></span><br><span class="line">       @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">       wait_data_hd_time();</span><br><span class="line">       i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b0</span>;</span><br><span class="line">       @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">       <span class="comment">//                  i2c_if.sda_slave = 1'bz;</span></span><br><span class="line">       <span class="comment">//collect second byte</span></span><br><span class="line">       j++;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">begin</span></span><br><span class="line">         @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">         mon_data[j][i] = i2c_if<span class="variable">.SDA</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="comment">//send ack to master</span></span><br><span class="line">       @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">       wait_data_hd_time();</span><br><span class="line">       i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b0</span>;</span><br><span class="line">       @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">       <span class="comment">//                    i2c_if.sda_slave = 1'bz;</span></span><br><span class="line">       m=<span class="number">8</span>; j=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>((!end_flag) &amp; (!rs_flag)) <span class="keyword">begin</span></span><br><span class="line">         @(<span class="keyword">posedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">         tmp_data[m] = i2c_if<span class="variable">.SDA</span>;</span><br><span class="line">         @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">         m--;</span><br><span class="line">         <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">           mon_data[j] = tmp_data[<span class="number">8</span>:<span class="number">1</span>];</span><br><span class="line">           wait_data_hd_time();</span><br><span class="line">           i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b0</span>;</span><br><span class="line">           m=<span class="number">8</span>;</span><br><span class="line">           j++;</span><br><span class="line">           @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">         <span class="comment">//                              i2c_if.sda_slave = 1'bz;</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">if</span>(rs_flag &amp; j!=<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">         trans<span class="variable">.data</span>=mon_data;  <span class="comment">//if rs_flag==1 in this step, should sent data to trans</span></span><br><span class="line">         mon_data = &#123;&#125;;</span><br><span class="line">         j=<span class="number">0</span>;</span><br><span class="line">         <span class="built_in">$display</span>(<span class="string">"slv_driver trans data is %p"</span>,trans<span class="variable">.data</span>);</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="8’b1111-1xxx（device-id）"><a href="#8’b1111-1xxx（device-id）" class="headerlink" title="8’b1111_1xxx（device_id）"></a>8’b1111_1xxx（device_id）</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">       deviceid=<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//send ack and continue receive or transmit data</span></span><br><span class="line">       @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">       wait_data_hd_time();</span><br><span class="line">       i2c_if<span class="variable">.sda_slave</span> = <span class="number">1'b0</span>;</span><br><span class="line">       @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">       <span class="comment">//                   i2c_if.sda_slave = 1'bz;</span></span><br><span class="line">       trans<span class="variable">.cmd</span> = I2C_DEVICE_ID;</span><br><span class="line">       <span class="keyword">if</span>(mon_data[j][<span class="number">0</span>]==<span class="number">0</span>)  <span class="keyword">begin</span>  <span class="comment">//devide ID first byte, write slave address followed</span></span><br><span class="line">         <span class="comment">//continue receive slave address, the address is 7 bits or 10 bits</span></span><br><span class="line">         j=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(mon_data[j][<span class="number">0</span>]==<span class="number">1</span>)  <span class="keyword">begin</span>  <span class="comment">//device ID byte followed re-start, read 3 bytes ID</span></span><br><span class="line">         j=<span class="number">8</span>;</span><br><span class="line">         <span class="keyword">while</span>((!end_flag) &amp; (!rs_flag)) <span class="keyword">begin</span></span><br><span class="line">           <span class="comment">//for(int i=7; i&gt;=0; i--) begin</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">23</span>; i&gt;=<span class="number">0</span>; i--) <span class="keyword">begin</span></span><br><span class="line">             wait_data_hd_time();</span><br><span class="line">             i2c_if<span class="variable">.sda_slave</span> = cfg<span class="variable">.device_id</span>[i];</span><br><span class="line">             @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">             j--;</span><br><span class="line">             <span class="keyword">if</span>(j==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">               j=<span class="number">8</span>;</span><br><span class="line">               <span class="comment">//                                 i2c_if.sda_slave = 1'bz; // release bus to mst,</span></span><br><span class="line">               @(<span class="keyword">negedge</span> i2c_if<span class="variable">.SCL</span>);</span><br><span class="line">             <span class="keyword">end</span></span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E5%AD%97IC/" rel="tag"># 数字IC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/09/java-Maven/" rel="next" title="java-Maven">
                <i class="fa fa-chevron-left"></i> java-Maven
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/30/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/" rel="prev" title="排序专题">
                排序专题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="xujunjie'blog" />
            
              <p class="site-author-name" itemprop="name">xujunjie'blog</p>
              <p class="site-description motion-element" itemprop="description">使一个人有限的生命更加有效也即等于延长了人的生命</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">77</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#I2C总线协议"><span class="nav-text">I2C总线协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特征"><span class="nav-text">特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址"><span class="nav-text">地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件层"><span class="nav-text">硬件层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#起始和截止条件"><span class="nav-text">起始和截止条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应答-ACK-amp-非应答-NACK"><span class="nav-text">应答(ACK)&amp;非应答(NACK)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传输操作"><span class="nav-text">传输操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据有效性"><span class="nav-text">数据有效性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时钟同步和仲裁"><span class="nav-text">时钟同步和仲裁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总线清零"><span class="nav-text">总线清零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时钟拉伸"><span class="nav-text">时钟拉伸</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保留地址"><span class="nav-text">保留地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#广播寻址（0000-0000）"><span class="nav-text">广播寻址（0000 0000）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LSB-0"><span class="nav-text">LSB&#x3D;0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LSB-1"><span class="nav-text">LSB&#x3D;1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start-byte（0000-0001）"><span class="nav-text">start byte（0000 0001）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Device-ID（1111-1xx1）"><span class="nav-text">Device ID（1111 1xx1）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10bit地址"><span class="nav-text">10bit地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-bit-地址写"><span class="nav-text">10-bit 地址写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-bit-地址读"><span class="nav-text">10-bit 地址读</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VIP开发"><span class="nav-text">VIP开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#接口及功能分析"><span class="nav-text">接口及功能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#interface"><span class="nav-text">interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transcation"><span class="nav-text">transcation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#base-transcation"><span class="nav-text">base_transcation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#master-transaction"><span class="nav-text">master_transaction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slave-transcation"><span class="nav-text">slave_transcation</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环境搭建"><span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#driver"><span class="nav-text">driver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bfm-common"><span class="nav-text">bfm_common</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#master-driver-common"><span class="nav-text">master_driver_common</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#start-gen"><span class="nav-text">start_gen()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stop-gen"><span class="nav-text">stop_gen()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#re-start-gen"><span class="nav-text">re_start_gen()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#send-byte"><span class="nav-text">send_byte</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收byte发送应答"><span class="nav-text">接收byte发送应答</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收byte发送非应答"><span class="nav-text">接收byte发送非应答</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#send-start-byte"><span class="nav-text">send_start_byte</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7bit地址传输"><span class="nav-text">7bit地址传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10bit地址传输"><span class="nav-text">10bit地址传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I2C-WRITE"><span class="nav-text">I2C_WRITE:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I2C-READ"><span class="nav-text">I2C_READ:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I2C-GEN-CALL"><span class="nav-text">I2C_GEN_CALL:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I2C-DEVICE-ID"><span class="nav-text">I2C_DEVICE_ID:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#master-driver"><span class="nav-text">master_driver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slave-driver-commom"><span class="nav-text">slave_driver_commom</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#slave-start"><span class="nav-text">slave_start()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slave-end"><span class="nav-text">slave_end()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data-ana-trans"><span class="nav-text">data_ana(trans)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8’b-0000-0000-广播"><span class="nav-text">8’b 0000_0000(广播)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8’b1111-1xxx（device-id）"><span class="nav-text">8’b1111_1xxx（device_id）</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xujunjie'blog</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>


  
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
