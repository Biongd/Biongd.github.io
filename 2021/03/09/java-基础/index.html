<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java," />










<meta name="description" content="又到了快要考计算机二级的日子，本来不想报名的，毕竟用处不大。但是犹豫再三还是报了名，就当做是弥补大学时的遗憾了。 目标：20天完成java基础的系统学习；教材：java核心技术（清华大学出版社）">
<meta property="og:type" content="article">
<meta property="og:title" content="java-基础">
<meta property="og:url" content="http://yoursite.com/2021/03/09/java-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="悦来客栈">
<meta property="og:description" content="又到了快要考计算机二级的日子，本来不想报名的，毕竟用处不大。但是犹豫再三还是报了名，就当做是弥补大学时的遗憾了。 目标：20天完成java基础的系统学习；教材：java核心技术（清华大学出版社）">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210219212028.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210219212149.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210228132157.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210228135618.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210307142127.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210306104251.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210307101812.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20201103090237.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210307151440.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210308110454.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210311222549.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210315152157.jpeg">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210321223354.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210321160610.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210325221450.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210326101228.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210326103308.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210326103439.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210326104315.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210329145433.png">
<meta property="article:published_time" content="2021-03-09T06:54:02.000Z">
<meta property="article:modified_time" content="2021-08-29T02:12:48.551Z">
<meta property="article:author" content="xujunjie&#39;blog">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/biongd/img/raw/master/img/20210219212028.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","display_updated":true,"offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/03/09/java-基础/"/>





  <title>java-基础 | 悦来客栈</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">悦来客栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">learn and better</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/09/java-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xujunjie'blog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="悦来客栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java-基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
              
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-09T14:54:02+08:00">
                2021-03-09
              </time>
            
            
                <span class="post-updated">
                     &nbsp; | &nbsp; 更新于
                     <time itemprop="dateUpdated" datetime="2021-08-29T10:12:48+08:00" content="2021-08-29">
                          2021-08-29
                     </time>
                 </span>
             

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%AD%A6%E4%B9%A0-JVM-spring-Maven-IDEA-web-%E9%9B%86%E5%90%88-%E6%95%B0%E7%BB%84-String%E4%B8%93%E9%A2%98-%E5%89%8D%E7%AB%AF-web%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80-redis-%E6%A6%82%E5%BF%B5/" itemprop="url" rel="index">
                    <span itemprop="name">java学习-JVM.spring.Maven.IDEA.web.集合/数组/String专题.前端.web实战.基础.redis.概念.</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>又到了快要考计算机二级的日子，本来不想报名的，毕竟用处不大。但是犹豫再三还是报了名，就当做是弥补大学时的遗憾了。</p>
<p>目标：20天完成java基础的系统学习；教材：java核心技术（清华大学出版社）</p>
<a id="more"></a>
<h1 id="1-变量、操作符和语句"><a href="#1-变量、操作符和语句" class="headerlink" title="1. 变量、操作符和语句"></a>1. 变量、操作符和语句</h1><h2 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h2><p>系统为程序分配的一块内存单元，用来存储各种类型的数据。因为该存储单元的数据可能发生改变，因此称为变量</p>
<ul>
<li><p>变量分类：</p>
<ul>
<li><p>按所属数据类型划分：</p>
<p>基本数据类型</p>
<p>引用数据类型</p>
</li>
<li><p>按声明位置划分：</p>
<p>局部变量：方法或语句块内部定义的变量</p>
<p>成员变量：方法外部、类的内部定义的变量</p>
</li>
</ul>
</li>
</ul>
<font color="red" size="5">注意：类的外面不能有变量的声明</font>

<h2 id="1-2-数据类型"><a href="#1-2-数据类型" class="headerlink" title="1.2 数据类型"></a>1.2 数据类型</h2><p>由于记录的数据内容大小不同，所需的存储单元大小也不同，因此使用数据类型类描述</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210219212028.png" alt="image-20210219212028378"></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210219212149.png" alt="image-20210219212149269" style="zoom:67%;" /></p>
<h2 id="1-3-数据类型转换"><a href="#1-3-数据类型转换" class="headerlink" title="1.3 数据类型转换"></a>1.3 数据类型转换</h2><p>boolean类型不能转换为任何其他类型</p>
<ul>
<li><p>自动类型转换：容量小的转换成容量大的数据类型</p>
<p>byte，short，int》long》float》double</p>
<p>byte,short,int 不会互相转换，它们三者在计算时会转换成 int 类型</p>
</li>
<li><p>强制类型转换：容量大的类型转换成容量小的数据类型时，要加上强制转换符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">100L</span>;</span><br><span class="line"><span class="keyword">int</span> b = (<span class="keyword">int</span>)a;</span><br></pre></td></tr></table></figure>
<p>注意：强制转换可能造成精度降低或数据溢出，使用时要小心</p>
</li>
<li><p>float变量定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">10</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">float</span> b = <span class="number">10.1</span>; <span class="comment">//报错，why？</span></span><br></pre></td></tr></table></figure>
<p>float类型变量在定义时需注意：我们直接写出的浮点数字，默认类型是double，会提示需要强转</p>
<p>解决：在浮点数字后加入f，表示写出的数字是float类型</p>
</li>
<li><p>long变量定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">2200000000</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<p>long类型类型变量在定义时需注意：我们直接写出的整形数字，默认类型是int，值超出int范围（稍大于20亿）时报错；</p>
<p>解决：值后加l</p>
</li>
<li><p>问题：float转long是否可行？</p>
<p>答：可行，简而言之</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型			存储				取值范围</span><br><span class="line"><span class="built_in">float</span>		<span class="number">4</span>字节		±<span class="number">3.403E38</span>  有效位数为<span class="number">6</span>~<span class="number">7</span>位</span><br><span class="line">doube		<span class="number">8</span>字节		±<span class="number">1.78E308</span>	有效位数为<span class="number">15</span>位</span><br><span class="line">long		<span class="number">8</span>字节		±<span class="number">2</span>^<span class="number">63</span> （大概是±<span class="number">9E18</span>）</span><br></pre></td></tr></table></figure>
<p>虽然float只有4字节而long有8字节，但是可以看到float的取值范围远大于long（整型依靠位数确定范围，浮点型的位数不直接表示大小，而是以公式的形式计算），注意long类型转float可能存在精度丢失</p>
<p>float第一位符号位后跟着8位指数域，对应科学计数法的形式，也即float的取值范围是$-2^{128}-2^{128}$。</p>
</li>
<li><p>char和int的相互转化： </p>
<ul>
<li><p>方法1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">'9'</span>;</span><br><span class="line"><span class="keyword">if</span> (Character.isDigit(ch))&#123;  <span class="comment">// 判断是否是数字</span></span><br><span class="line">	<span class="keyword">int</span> num = Integer.parseInt(String.valueOf(ch));</span><br><span class="line">	System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">'9'</span>;</span><br><span class="line"><span class="keyword">if</span> (Character.isDigit(ch))&#123;  <span class="comment">// 判断是否是数字</span></span><br><span class="line">	<span class="keyword">int</span> num = (<span class="keyword">int</span>)ch - (<span class="keyword">int</span>)(<span class="string">'0'</span>);</span><br><span class="line">	System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="1-4-语句"><a href="#1-4-语句" class="headerlink" title="1.4 语句"></a>1.4 语句</h2><ul>
<li><p>if判断语句</p>
<p>else if的含义：if判断通过则不再执行，if没通过才进行else判断，且此时前面的if或else if已经将条件进行筛除</p>
</li>
<li><p>switch分支语句</p>
<ul>
<li>表达式的返回值必须是下述几种类型之一：int, byte, char, short,String；</li>
<li>case 子句中的取值必须是常量，且所有 case 子句中的取值应是不同的；</li>
<li>case后面跟着的执行体可写可不写</li>
<li>default 子句可写可不写</li>
<li>break 语句用来在执行完一个 case 分支后使程序跳出 switch 语句块；如果 case 后面没有写 break 则直接往下面执行！</li>
</ul>
</li>
<li><p>while循环和do-while循环的区别</p>
<p>do-while先执行再判断，while先判断再执行</p>
</li>
<li><p>for循环的格式for（一次性执行语句；判断语句；每次都执行的语句）{}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(System.out.println(<span class="number">1</span>);System.out.println(<span class="number">2</span>);System.out.println(<span class="number">3</span>);)&#123;&#125;</span><br><span class="line"><span class="comment">//for循环的执行结果：1只输出一次；之后2,3交替输出</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>退出多重循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">haha: <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j=<span class="number">2</span>) <span class="keyword">break</span> haha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="1-5-基本输入输出"><a href="#1-5-基本输入输出" class="headerlink" title="1.5 基本输入输出"></a>1.5 基本输入输出</h2><h3 id="1-5-1-Scanner-类实现键盘输入"><a href="#1-5-1-Scanner-类实现键盘输入" class="headerlink" title="1.5.1 Scanner 类实现键盘输入"></a>1.5.1 Scanner 类实现键盘输入</h3><p>java.util.Scanner</p>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInpotScanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    	<span class="comment">//定义变量，接受用户输入</span></span><br><span class="line">        String key ;</span><br><span class="line">        <span class="keyword">int</span> keyInt;</span><br><span class="line">        <span class="keyword">float</span> keyFloat;</span><br><span class="line">        Scanner stdin = <span class="keyword">new</span> Scanner(System.in); <span class="comment">//创建一个扫描器stdin对象</span></span><br><span class="line">        System.out.println(<span class="string">"学生的姓名为："</span>);</span><br><span class="line">        key = stdin.nextLine();                 <span class="comment">//收集用户输入</span></span><br><span class="line">        System.out.println(<span class="string">"学生的姓名为:"</span>+key);</span><br><span class="line">        System.out.println(<span class="string">"学生的年龄为："</span>);</span><br><span class="line">        keyInt = stdin.nextInt();<span class="comment">//获取输入的整形</span></span><br><span class="line">        System.out.println(<span class="string">"学生的年龄为："</span>+keyInt);</span><br><span class="line">        System.out.println(<span class="string">"学生的成绩为："</span>);</span><br><span class="line">        keyFloat = stdin.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">"学生的成绩为："</span>+keyFloat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-2-JOptionPane对话框输入"><a href="#1-5-2-JOptionPane对话框输入" class="headerlink" title="1.5.2 JOptionPane对话框输入"></a>1.5.2 JOptionPane对话框输入</h3><p>JOptionPane是javax.swing中的类，是可视化的对话框。限制了只能输入字符串数据。</p>
<p>实例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package test01;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JOptionpane;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInputJoptionpane</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> testInt;</span><br><span class="line">		<span class="keyword">String</span> dataStr;</span><br><span class="line">		dataStr = JOptionpane.showInputDialog(<span class="string">"输入"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-各类型数组的默认值"><a href="#1-6-各类型数组的默认值" class="headerlink" title="1.6 各类型数组的默认值"></a>1.6 各类型数组的默认值</h2><p>1、int类型定义的数组，初始化默认是0</p>
<p>2、String类型定义的数组，默认值是null</p>
<p>3、char类型定义的数组，使用UTF8字符集 给出的结果是’0’</p>
<p>4、double类型定义的数组，默认值是0.0</p>
<p>5、float类型定义的数组，默认值是0.0</p>
<p>6、boolean类型定义的数组，默认值是false</p>
<h1 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2. 面向对象"></a><a href="D:\biongd\source\_posts\java-面向对象.md">2. 面向对象</a></h1><h1 id="3-异常"><a href="#3-异常" class="headerlink" title="3. 异常"></a>3. 异常</h1><p>目标：</p>
<ul>
<li>明确什么异常</li>
<li>能辨识出常见的异常及其含义</li>
<li>理解异常产生的原理</li>
<li>能处理异常</li>
<li>能够自定义异常类型</li>
</ul>
<h2 id="3-1-异常体系结构"><a href="#3-1-异常体系结构" class="headerlink" title="3.1 异常体系结构"></a>3.1 异常体系结构</h2><p>异常是在程序中导致程序中断运行的一种指令流。</p>
<p>异常指的是Exception ， Exception类， 在Java中存在一个父类Throwable（可能的抛出）</p>
<p>Throwable存在两个子类：</p>
<ul>
<li>Error：表示的是错误，是JVM发出的错误操作,只能尽量避免，无法用代码处理。</li>
<li>Exception：一般表示所有程序中的错误，所以一般在程序中将进行try…catch的处理。</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210228132157.png" alt="image-20210228132103430"  /></p>
<p>受检和非受检的关系：</p>
<ul>
<li><p>非受检的代码：写出来不报错，运行时（比如参数给的不对）就可能报错</p>
<ul>
<li>Exception类的子类：RuntimeException类</li>
</ul>
</li>
<li><p>受检的代码：写出来就飘红（编译是就报错）</p>
<ul>
<li>除RuntimeException类之外的其他子类</li>
</ul>
</li>
</ul>
<blockquote>
<p>面试问：java的异常类型</p>
<p>答：受检和非受检</p>
</blockquote>
<p>注意观察如下方法的源码：</p>
<p>Integer类： <code>public static int parseInt(String text)throws NumberFormatException</code></p>
<p>此方法抛出了异常， 但是使用时却不需要进行try。。。catch捕获处理</p>
<p>原因：因为NumberFormatException并不是Exception的直接子类，而是RuntimeException的子类，只要是RuntimeException的子类，则表示程序在操作的时候可以不必使用try…catch进行处理，如果有异常发生，则由JVM进行处理。当然，也可以通过try catch处理</p>
<h2 id="3-2-异常处理"><a href="#3-2-异常处理" class="headerlink" title="3.2 异常处理"></a>3.2 异常处理</h2><p>try-catch-finally：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果要想对异常进行处理，则必须采用标准的处理格式，处理格式语法如下：</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 有可能发生异常的代码段</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 对象名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 异常的处理操作</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 对象名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 异常的处理操作</span></span><br><span class="line">&#125; ...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">// 异常的统一出口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-finally的必然执行和常见题目"><a href="#3-2-1-finally的必然执行和常见题目" class="headerlink" title="3.2.1 finally的必然执行和常见题目"></a>3.2.1 finally的必然执行和常见题目</h3><p>在进行异常的处理之后，在异常的处理格式中还有一个finally语句，那么此语句将作为异常的统一出口，不管是否产生<br>了异常，最终都要执行此段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">haha</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	p.age = <span class="number">10</span>;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	p.age = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问：调用haha方法，上面的finally代码块执行吗？</p>
<p>执行，除了电脑关机断电等直接清空内存的操作，finally必然执行。在return 语句执行结束会等待finally代码块执行，再返回值</p>
<p>输出结果p=20</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">haha</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时的返回结果：a = 10；</p>
<p>return a语句执行时会产生一个a的复制最为备份等待返回，尽管执行完finally后a的值为20，但返回的值仍为10。</p>
</blockquote>
<p>如何用代码的方式让finally无法执行：<code>System.exit()</code></p>
<p>在try或catch语句中执行，直接退出JVM，则finally不会执行，这是唯一用代码屏蔽finally的形式</p>
<h3 id="3-2-2-实际的处理流程："><a href="#3-2-2-实际的处理流程：" class="headerlink" title="3.2.2 实际的处理流程："></a>3.2.2 <strong>实际的处理流程：</strong></h3><ol>
<li><p>一旦产生异常，则系统会自动产生一个异常类的实例化对象。</p>
</li>
<li><p>那么，此时如果异常发生在try语句，则会自动找到匹配的catch语句执行，如果没有在try语句中，则会将异常抛出。</p>
<font color="red">**抛给调用产生异常的方法的代码位置**</font>

<p><img src="https://gitee.com/biongd/img/raw/master/img/20210228135618.png" alt="image-20210228135618027" style="zoom:67%;" /></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果main方法中调用了一个f（）方法，且因为传入的参数错误导致f（）方法内出现异常，则此时的异常抛给调用f（）方法的main方法</span><br><span class="line">main方法可以通过<span class="keyword">try</span>—catch代码块捕获并处理</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(arr<span class="literal">[<span class="number">10</span>]</span>);</span><br><span class="line">&#125;catch(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"数组没这么长啊"</span>);</span><br><span class="line">&#125;</span><br><span class="line">如果不处理，则会继续向上抛出给调用main方法的JVM处理</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.ArrayIndexOutOfBoundsException: Index <span class="number">10</span> out <span class="keyword">of</span> bounds for length <span class="number">10</span></span><br><span class="line">	at com.java.demo1.<span class="module-access"><span class="module"><span class="identifier">Test</span>.</span></span>main(<span class="module-access"><span class="module"><span class="identifier">Test</span>.</span></span>java:<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有的catch根据方法的参数匹配异常类的实例化对象，如果匹配成功，则表示由此catch进行处理</p>
</li>
</ol>
<h3 id="3-2-3-多异常捕获"><a href="#3-2-3-多异常捕获" class="headerlink" title="3.2.3 多异常捕获"></a>3.2.3 多异常捕获</h3><p>多异常捕获的注意点：</p>
<ul>
<li>捕获更粗的异常不能放在捕获更细的异常之前。</li>
<li>如果为了方便，则可以将所有的异常都使用Exception进行捕获。(利用多态思想)</li>
</ul>
<p>特殊的多异常捕获写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">1</span> |异常类型<span class="number">2</span> 对象名)&#123;</span><br><span class="line">	<span class="comment">//表示此块用于处理异常类型1 和 异常类型2 的异常信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-throws和throw"><a href="#3-3-throws和throw" class="headerlink" title="3.3 throws和throw"></a>3.3 throws和throw</h2><h3 id="3-3-1-throws"><a href="#3-3-1-throws" class="headerlink" title="3.3.1 throws"></a>3.3.1 throws</h3><p>异常是抛出还是处理，这是一个问题</p>
<p>对于受检异常，如果能确保正常执行，应该通过throws将异常抛出去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(String text)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    Runtime.getRuntime().exec(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-throw"><a href="#3-3-2-throw" class="headerlink" title="3.3.2 throw"></a>3.3.2 throw</h3><p>throw关键字表示在程序中人为的抛出一个异常，因为从异常处理机制来看，所有的异常一旦产生之后，实际上抛出的就是一个异常类的</p>
<p>实例化对象，那么此对象也可以由throw直接抛出。</p>
<p>代码： <code>throw new Exception(&quot;抛着玩的。&quot;)</code>;</p>
<p>很少需要人为的抛出异常，往往通过判断就能避免异常</p>
<h2 id="3-4-自定义异常类-了解"><a href="#3-4-自定义异常类-了解" class="headerlink" title="3.4 自定义异常类 了解"></a>3.4 自定义异常类 了解</h2><h1 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4. 泛型"></a>4. 泛型</h1><p><strong>概念：</strong>泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）</p>
<p><strong>作用：</strong></p>
<p>1、 提高代码复用率</p>
<p>2、 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型），比如JDK1.4以前在集合中用Object来接收数据，在调用时又需要强转回原类型</p>
<p><strong>与传参的区别：</strong>Java编码惯例，只使用少量的类型参数名称</p>
<ul>
<li>K：键，比如映射的键</li>
<li>V：值，比如List和Set的内容</li>
<li>E：元素，比如<code>Vector&lt;E&gt;</code></li>
<li>T：泛型，比如上面的Person类</li>
</ul>
<h2 id="4-1-泛型的使用"><a href="#4-1-泛型的使用" class="headerlink" title="4.1 泛型的使用"></a>4.1 泛型的使用</h2><h3 id="4-1-1-泛型类"><a href="#4-1-1-泛型类" class="headerlink" title="4.1.1 泛型类"></a>4.1.1 泛型类</h3><p>泛型在类中的使用是最常见的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">定义一个泛型类：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化时可以将第二个泛型名省略，一个类也可以使用多个泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName&lt;String&gt; c = <span class="keyword">new</span> ClassName&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-泛型接口"><a href="#4-1-2-泛型接口" class="headerlink" title="4.1.2 泛型接口"></a>4.1.2 泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntercaceName</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">实现接口时，可以选择指定泛型类型，也可以选择不指定， 如下：</span><br><span class="line">指定类型：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> <span class="keyword">implements</span> <span class="title">IntercaceName</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不指定类型：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interface1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IntercaceName</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-泛型方法"><a href="#4-1-3-泛型方法" class="headerlink" title="4.1.3 泛型方法"></a>4.1.3 泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有返回值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T 方法名(T a, T b) &#123;&#125;</span><br><span class="line"><span class="comment">//无返回值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> 方法名(T a, T b) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出泛型方法的泛型位置在返回值类型声明前，可以作为返回值类型使用，也可以作为参数类型使用</p>
<h2 id="4-2-泛型限制类型"><a href="#4-2-泛型限制类型" class="headerlink" title="4.2 泛型限制类型"></a>4.2 泛型限制类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在使用泛型时，可以指定泛型的限定区域，</span><br><span class="line">例如：必须是某某类的子类或 某某接口的实现类，格式：</span><br><span class="line">  &lt;T extends 类或接口<span class="number">1</span> &amp; 接口<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>
<p>注意：这里无论是继承类还是实现接口都使用extends关键字，“&amp;”字符连接多个接口</p>
<h2 id="4-3-泛型中的通配符-？"><a href="#4-3-泛型中的通配符-？" class="headerlink" title="4.3 泛型中的通配符 ？"></a>4.3 泛型中的通配符 ？</h2><p>类型通配符是使用？代替方法具体的类型<strong>实参</strong>。</p>
<ul>
<li><code>&lt;? extends Parent&gt;</code>指定了泛型类型的上届</li>
<li><code>&lt;? super Child&gt;</code> 指定了泛型类型的下届</li>
<li><code>&lt;?&gt;</code>指定了没有限制的泛型类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型限制类型的使用</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">Plate&lt;Apple&gt; p = <span class="keyword">new</span> Plate&lt;&gt;();   <span class="comment">//可行</span></span><br><span class="line">Plate&lt;String&gt; p = <span class="keyword">new</span> plate&lt;&gt;();  <span class="comment">//不可行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型通配符的使用</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">Plate&lt;Fruit&gt; p = <span class="keyword">new</span> Plate&lt;Apple&gt;();             <span class="comment">//不可行</span></span><br><span class="line">Plate&lt;? extends Fruit&gt; p = <span class="keyword">new</span> Plate&lt;Apple&gt;();   <span class="comment">//可行</span></span><br><span class="line">Plate&lt;? <span class="keyword">super</span> Apple&gt; p = <span class="keyword">new</span> plate&lt;Fruit&gt;();     <span class="comment">//可行</span></span><br></pre></td></tr></table></figure>
<p>这里也可以看出泛型限制类型，和泛型通配符的使用区别：</p>
<ul>
<li>泛型限制类型针对“形参”，在声明类是就限制了能够传入的形参</li>
<li>泛型通配符针对“实参”，在实例对象类型未知时用？代替传入具体类作为实参，也可以对实参类型进行限制</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210307142127.png" alt="image-20210307142120814" style="zoom: 150%;" /></p>
<p>泛型统配符也不能乱用，对于需要传入参数具体类型的add方法在调用时报错，可以看出上述实例对象并未指定准确类型</p>
<p>常见的使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 指明泛型参数必须是supC或其子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">( gent&lt;? extends supC&gt; o )</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Bc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-核心类库"><a href="#5-核心类库" class="headerlink" title="5. 核心类库"></a>5. 核心类库</h1><h2 id="5-1-java-util-Objects"><a href="#5-1-java-util-Objects" class="headerlink" title="5.1 java.util.Objects"></a>5.1 java.util.Objects</h2><p>父类Object，final修饰</p>
<p>常用静态方法：</p>
<ul>
<li>equals</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>isNull</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>nonNull</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nonNull</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>requireNonNull</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//如果对象为空，直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>hash()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> code = Objects.hash(Object... values) <span class="comment">//为一系列输入值生成哈希码。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-java-util-Date"><a href="#5-2-java-util-Date" class="headerlink" title="5.2 java.util.Date"></a>5.2 java.util.Date</h2><p>父类java.lang.Object，子类java.sql.Date（缺陷，作用一样）</p>
<p>注意：方法多为过时，只能表示时刻，精确到毫秒</p>
<ul>
<li>获取当前日期和时间：toString（）</li>
<li>获取毫秒数（时间戳）：getTime（）：标准基准时间（1970年1月1日08:00:00，格林尼治标准时间）开始到现在</li>
<li>通过时间戳获取当前日期和时间：setTime（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date_test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date d = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println(d.getTime());</span><br><span class="line">        d.setTime(d.getTime()-<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Sat Mar <span class="number">06</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">18</span> CST <span class="number">2021</span></span><br><span class="line"><span class="number">1614997038545</span></span><br><span class="line">Fri Mar <span class="number">05</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">18</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure>
<h2 id="5-3-java-text-SimpleDateFormat"><a href="#5-3-java-text-SimpleDateFormat" class="headerlink" title="5.3 java.text.SimpleDateFormat"></a>5.3 java.text.SimpleDateFormat</h2><p>java.lang.Object——java.text.Format——java.text.DateFormat（抽象类）——java.text.SimpleDateFormat（实现类）</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210306104251.png" alt="image-20210306104135339" style="zoom: 80%;" /></p>
<ul>
<li><p>构造方法：<code>SimpleDateFormat(String pattern)</code></p>
<p>String pattern规定了可以解析和输出的时间格式</p>
</li>
<li><p>将声明的Date对象转化为规定格式：<code>String format(Date d)</code></p>
</li>
<li>按规定格式输入时间，获取Date类型的对象：<code>Date parse(String source)</code></li>
<li>通过Date的getTime方法可以获取时间戳，从而进行时间运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date_test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        SimpleDateFormat s = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        System.out.println(s.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        Date d = s.parse(<span class="string">"1995-05-29 01:30:30"</span>);</span><br><span class="line">        <span class="keyword">long</span> num = <span class="keyword">new</span> Date().getTime() - d.getTime();</span><br><span class="line">        <span class="keyword">long</span> day = num/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">        System.out.println(day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结构</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">03</span>-<span class="number">06</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">41</span></span><br><span class="line"><span class="number">9413</span></span><br></pre></td></tr></table></figure>
<h2 id="5-4-java-util-Calendar"><a href="#5-4-java-util-Calendar" class="headerlink" title="5.4 java.util.Calendar"></a>5.4 java.util.Calendar</h2><p>extends Object, abstract修饰</p>
<p>作用：解决Date类不能国际化的问题，通过时区来进行日历对象的创意</p>
<p>创建对象的方法：<code>Calendar.getInstance()</code></p>
<p>常用方法：</p>
<p>方法中出现的全局常量，都是对应<code>fields</code>数组（存储本机日历信息）的下标</p>
<ul>
<li>获取日历对象中的年，月，日，时，分，秒等信息：<code>int get()</code></li>
<li>不使用当前时间的日历，对信息进行修改：<code>void set()</code></li>
<li><p>不使用当前时间的日历，对信息进行修改：<code>void add()</code></p>
</li>
<li><p>获取日历时间表示的Date对象：<code>Date getTime()</code></p>
</li>
<li>获取各个字段最大的值：<code>int getActualMaxmium</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">//get方法：获取当前日历的信息</span></span><br><span class="line">        <span class="keyword">int</span> a = c.get(Calendar.MONTH); <span class="comment">//MONTH：0-11</span></span><br><span class="line">        <span class="keyword">int</span> b = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//set方法：修改日历的信息</span></span><br><span class="line">        c.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        b = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//add方法：区别于set的直接修改</span></span><br><span class="line">        c.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> e = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="comment">//getTime方法，返回Date类型</span></span><br><span class="line">        Date d = c.getTime();</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        <span class="comment">//getActualMaximum方法，获取某个信息的最大值</span></span><br><span class="line">        <span class="keyword">int</span> f = c.getActualMaximum(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Tue Mar <span class="number">02</span> <span class="number">14</span>:<span class="number">47</span>:<span class="number">32</span> CST <span class="number">2021</span></span><br><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure>
<h2 id="5-5-java-util-Arrays"><a href="#5-5-java-util-Arrays" class="headerlink" title="5.5 java.util.Arrays"></a>5.5 java.util.Arrays</h2><p>extends Object</p>
<p>常用静态方法：</p>
<ul>
<li><p>获取数组字符串：<code>Arrays.toString(arr)</code></p>
</li>
<li><p>查找元素下标：<code>Arrays.binarySearch(arr，6)</code></p>
<p>Arrays类中定义了一个二分查找的重载方法binarySearch（），从指定的数组范围中查找指定的值，<strong>返回其索引位置</strong>。二分查找的前提是数组必须有序。如果无序，必须先进行排序，再进行查找。</p>
</li>
<li><p>数组扩容：<code>Arrays.copyOf(arr, 14)</code></p>
</li>
<li><p>数组排序：<code>Arrays.sort(arr)</code>(还可以通过匿名内部类实现comparable接口，重写compare方法，制定排序规则)</p>
</li>
</ul>
<h2 id="5-6-java-lang-Math"><a href="#5-6-java-lang-Math" class="headerlink" title="5.6 java.lang.Math"></a>5.6 java.lang.Math</h2><p>extends Object，final修饰</p>
<p>常用静态方法：</p>
<ul>
<li>获取绝对值：<code>Math.abs(int/long/float/double a)</code></li>
<li>最小和最大值：<code>Math.min(), Math.max()</code></li>
<li>四舍五入：<code>Math.round()</code></li>
<li>小于等于参数的最大整数：<code>Maht.floor()</code></li>
<li>大于等于参数的最大整数：<code>Maht.ceil()</code></li>
<li>m的n次方：<code>Math.pow(m,n)</code></li>
</ul>
<h2 id="5-7-java-math-BigDecimal"><a href="#5-7-java-math-BigDecimal" class="headerlink" title="5.7 java.math.BigDecimal"></a>5.7 java.math.BigDecimal</h2><p>java.lang.Object——java.lang.Number——java.math.BigDecimal</p>
<p>作用：解决double、float数据类型计算时的数据精度问题</p>
<p>常用构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal(String a)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>常用方法：</p>
<ul>
<li>加：<code>BigDecimal add(BidDecimal augend)</code></li>
<li>减：<code>BigDecimal subtract(BidDecimal augend)</code></li>
<li>乘：<code>BigDecimal multiply(BidDecimal augend)</code></li>
<li>除：<code>BigDecimal divide(BidDecimal augend)</code></li>
</ul>
<p>返回值仍为BigDecimal类型，需要再新建一个BigDecimal存储</p>
<h2 id="5-8-java-lang-String"><a href="#5-8-java-lang-String" class="headerlink" title="5.8 java.lang.String"></a>5.8 java.lang.String</h2><p>extends Object，final修饰</p>
<p>java中的每一个字符串都是一个String的实例对象，且因为String对象时不可变的，所以可以“共享”他们</p>
<h3 id="共享的理解："><a href="#共享的理解：" class="headerlink" title="共享的理解："></a>共享的理解：</h3><p>相同内容的字符串共享同一块内存地址，存储在字符串常量池中</p>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>1.方法区</p>
<p>方法区，又称永久代（永远存在），被所有线程共享</p>
<p>2.堆</p>
<p>一个JVM实例只存在一个堆内存，堆内存的大小是可调节的。类加载器读了类文件以后，需要把类，方法，常变量放到堆内存中，保存所有引用类型的真实信息，方便执行器执行</p>
<p>堆在逻辑上分为3部分：</p>
<ul>
<li><p>新生代：（又分为Eden区和Survior区），gc方法频繁访问</p>
<ul>
<li>Eden：新创建的对象</li>
<li>Survior：经过垃圾回收，但垃圾回收次数少于15次的对象</li>
</ul>
</li>
<li><p>老年代：垃圾回收次数超过15次仍存活的对象</p>
</li>
<li><p>永久代：不进行垃圾回收（类，方法，常量，静态属性等）</p>
</li>
</ul>
<p>字符串对象就被存在永久代中，每次新创建时在永久代中找有没有相同内容的字符串。</p>
<p>注意：对于new创建的字符串对象，一定是新开了空间，内存地址一定不同</p>
<p>JDK1.7：</p>
<p>字符串常量池：从方法区拿到了堆中</p>
<p>运行时常量池：剩下的东西还在方法区，也就是hotspot的永久代</p>
<p>JDK1.8：</p>
<p>hotspot移除的永久代，用元空间取而代之，字符串常量池还在堆</p>
<p>运行时常量池还在方法区，只不过方法区实现从永久代变为元空间</p>
<h3 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h3><p>作用：解决String类型字符串拼接无法及时进行垃圾回收的问题</p>
<h2 id="5-9-java-lang-System"><a href="#5-9-java-lang-System" class="headerlink" title="5.9 java.lang.System"></a>5.9 java.lang.System</h2><h1 id="6-集合（java-util包）"><a href="#6-集合（java-util包）" class="headerlink" title="6. 集合（java.util包）"></a>6. 集合（java.util包）</h1><h2 id="6-1-集合的概念"><a href="#6-1-集合的概念" class="headerlink" title="6.1 集合的概念"></a>6.1 集合的概念</h2><ul>
<li><p>集合的作用：</p>
<p>将队列，栈，数组，链表，二叉树等数据结构整合为一个个类库，方便数据的管理</p>
</li>
<li><p>集合和数组的异同</p>
<p><strong><font color="red">相同点：集合和数组一样，保存的都是一个对象的引用，而不是真正的对象数据，可以实现增删改查等操作</font></strong></p>
<p>不同点：</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
</li>
<li><p>集合类间的关系</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code></p>
</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210307101812.png" alt="image-20210307101805808"></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20201103090237.png" alt="img" style="zoom: 80%;" /></p>
<h2 id="6-2-Collection接口"><a href="#6-2-Collection接口" class="headerlink" title="6.2 Collection接口"></a>6.2 Collection接口</h2><p>Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是 java.util.List 和 java.util.Set</p>
<ul>
<li>List 的特点是元素有序、元素可重复。List 接口的主要实现类有 <code>java.util.ArrayList</code>和<code>java.util.LinkedList</code></li>
<li>Set 的特点是元素无序，而且不可重复。Set 接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code></li>
</ul>
<h3 id="Collection-常用功能"><a href="#Collection-常用功能" class="headerlink" title="Collection 常用功能"></a>Collection 常用功能</h3><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<blockquote>
<p>需要注意的是：Collection中没有提供获取元素的方法，Set同样如此</p>
</blockquote>
<ul>
<li>public boolean add(E e) ： 把给定的对象添加到当前集合中 。</li>
<li>public void clear() :清空集合中所有的元素。</li>
<li>public boolean remove(E e) : 把给定的对象在当前集合中删除。</li>
<li>public boolean contains(E e) : 判断当前集合中是否包含给定的对象。</li>
<li>public boolean isEmpty() : 判断当前集合是否为空。</li>
<li>public int size() : 返回集合中元素的个数。</li>
<li>public Object[] toArray() : 把集合中的元素，存储到数组中。</li>
</ul>
<h2 id="6-3-List接口"><a href="#6-3-List接口" class="headerlink" title="6.3 List接口"></a>6.3 List接口</h2><h2 id="6-3-1-List特点"><a href="#6-3-1-List特点" class="headerlink" title="6.3.1 List特点"></a>6.3.1 List特点</h2><p>所有的元素是以一种线性方式进行存储，这也保证了List的特点：</p>
<ul>
<li>有序（存取都是）：例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的</li>
<li>带索引：过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）</li>
<li>允许重复元素：通过元素的equals方法，来比较是否为重复的元素</li>
</ul>
<h3 id="6-3-2-List重载的方法（基于索引）"><a href="#6-3-2-List重载的方法（基于索引）" class="headerlink" title="6.3.2 List重载的方法（基于索引）"></a>6.3.2 List重载的方法（基于索引）</h3><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些<strong>根据元素索引来操作集合的特有方法</strong></p>
<ul>
<li>public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。</li>
<li>public E get(int index) :返回集合中指定位置的元素。</li>
<li>public E remove(int index) : 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li>public E set(int index, E element) :用指定元素替换集合中指定位置的元素,返回更新前的元素。</li>
<li>public int indexOf(Object o)：根据对象查找指定的位置，找不到返回-1</li>
<li>List<E> subList(int fromIndex,int toIndex)：返回子集合</li>
</ul>
<h2 id="6-4-List子类"><a href="#6-4-List子类" class="headerlink" title="6.4 List子类"></a>6.4 List子类</h2><h3 id="6-4-1-ArrayList"><a href="#6-4-1-ArrayList" class="headerlink" title="6.4.1 ArrayList"></a>6.4.1 ArrayList</h3><p>java.util.ArrayList 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以 ArrayList 是最常用的集合。</p>
<p>ArrayList构造方法：</p>
<ul>
<li>无参：默认创建的数组长度为10（new的时候初始化长度为0，）；</li>
<li>有参：传入int类型的参数，定义长度；</li>
</ul>
<p>ArrayList扩容算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;	<span class="comment">//原数组长度，扩容肯定是数组满了</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);	<span class="comment">//先将新长度设置为旧长度的1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;	<span class="comment">//如果新长度扔不能满足需要长度，</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)  <span class="comment">//长度为0（初始化的值）</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);    <span class="comment">//就把长度设置为（10和需要长度）的较大值</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow，超出int类型范围，minCapacity为负</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        	<span class="keyword">return</span> minCapacity;  <span class="comment">//如果添加一组，长度不可控</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-2-LinkedList"><a href="#6-5-2-LinkedList" class="headerlink" title="6.5.2 LinkedList"></a>6.5.2 LinkedList</h3><p><code>java.util.LinkedList</code>集合数据存储的结构是双向链表结构。方便元素添加、删除的集合。</p>
<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<ul>
<li>public void addFirst(E e) :将指定元素插入此列表的开头。</li>
<li>public void addLast(E e) :将指定元素添加到此列表的结尾。</li>
<li>public E getFirst() :返回此列表的第一个元素。</li>
<li>public E getLast() :返回此列表的最后一个元素。</li>
<li>public E removeFirst() :移除并返回此列表的第一个元素。</li>
<li>public E removeLast() :移除并返回此列表的最后一个元素。</li>
<li>public E pop() :从此列表所表示的堆栈处弹出一个元素。</li>
<li>public void push(E e) :将元素推入此列表所表示的堆栈。</li>
<li>public boolean isEmpty() ：如果列表不包含元素，则返回true。</li>
</ul>
<h2 id="6-5-迭代器（Iterator和ListIterator）"><a href="#6-5-迭代器（Iterator和ListIterator）" class="headerlink" title="6.5 迭代器（Iterator和ListIterator）"></a>6.5 迭代器（Iterator和ListIterator）</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code> 。 Iterator 接口也是</p>
<p>Java集合中的一员，但它与 Collection 、 Map 接口有所不同， Collection 接口与 Map 接口主要用于存储元素，而 Iterator 主要用于迭</p>
<p>代访问（即遍历）Collection 中的元素，因此 Iterator 对象也被称为迭代器。</p>
<ul>
<li>快速失败：在创建迭代器之后的任何时间修改集合，除了通过迭代器自己的remove方法之外，都会抛出异常</li>
<li>安全失败：迭代器的遍历对象是集合的备份，此时修改集合并不会报错</li>
</ul>
<p>ListIterator：功能完全相同，只能被List使用</p>
<p>public Iterator iterator() : 获取集合对应的迭代器，用来遍历集合中的元素的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line">List&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; i = l.Iterator();</span><br></pre></td></tr></table></figure>
<p>迭代的概念：</p>
<p>迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代</p>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><p>public E next() :返回迭代的下一个元素。</p>
</li>
<li><p>public boolean hasNext() :如果仍有元素可以迭代，则返回 true。</p>
</li>
<li><p><img src="https://gitee.com/biongd/img/raw/master/img/20210307151440.png" alt="image-20210307151440844"></p>
<p>如图，迭代器操作的就是这个指针，</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    l.add(<span class="number">1</span>);</span><br><span class="line">    l.add(<span class="number">2</span>);</span><br><span class="line">    l.add(<span class="number">3</span>);</span><br><span class="line">    l.add(<span class="number">4</span>);</span><br><span class="line">    ListIterator&lt;Integer&gt; li = l.listIterator();</span><br><span class="line">    li.add(<span class="number">100</span>)；	<span class="comment">//空指针处添加100</span></span><br><span class="line">    li.next();      <span class="comment">//下移一位</span></span><br><span class="line">    li.next();		<span class="comment">//下移一位</span></span><br><span class="line">    li.set(<span class="number">200</span>);	<span class="comment">//1的位置改为200</span></span><br><span class="line">    li.previous();	<span class="comment">//上移1位</span></span><br><span class="line">    li.previous();	<span class="comment">//上移1位</span></span><br><span class="line">    li.previous();	<span class="comment">//上移1位（指向100的上面）</span></span><br><span class="line">    <span class="keyword">while</span>(li.hasNext())&#123;</span><br><span class="line">        System.out.println(li.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-6-增强for（foreach）"><a href="#6-6-增强for（foreach）" class="headerlink" title="6.6 增强for（foreach）"></a>6.6 增强for（foreach）</h2><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量 : Collection集合or数组)&#123;</span><br><span class="line"><span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h2 id="6-7-Set接口"><a href="#6-7-Set接口" class="headerlink" title="6.7 Set接口"></a>6.7 Set接口</h2><p><code>java.util.Set</code> 接口和 <code>java.util.List</code>接口一样，同样继承自 Collection 接口，它与Collection 接口中的方法基本一致，并没有对 </p>
<p>Collection 接口进行功能上的扩充，只是比Collection 接口更加严格了。与 List 接口不同的是， Set 接口中元素无序，并且都会以某种规</p>
<p>则保证存入的元素不出现重复。所有的重复元素依靠 hashCode()和 equals 进行区分。</p>
<blockquote>
<p>tips:Set集合取出元素的方式可以采用：迭代器、增强for、调用toArray（）方法转成数组。</p>
</blockquote>
<h3 id="6-7-1-HashSet"><a href="#6-7-1-HashSet" class="headerlink" title="6.7.1 HashSet"></a>6.7.1 HashSet</h3><p>散列存放，利用双列的存储结构HashMap</p>
<p>存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)，底层的实现其实是 java.util.HashMap 支持，根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于： hashCode 与 equals 方法。</p>
<p>只利用Map的键进行存储，值得部分存储特定对象（new Object（））</p>
<h3 id="6-7-2-TreeSet"><a href="#6-7-2-TreeSet" class="headerlink" title="6.7.2 TreeSet"></a>6.7.2 TreeSet</h3><p>相比HashSet只是增加了排序功能的集合。会按照一定的排序规则，将集合汇总的对象序列时刻按照<strong><font color = "red">“升序”</font></strong>排列。所以必须注意的一点是：</p>
<ul>
<li>向TreeSet添加的对象元素的类型<strong>必须实现处于java.lang包下的Comparable接口</strong>，否则程序运行时出现java.lang.ClassException异常。API中的String类，封装类都已实现该接口，这个接口只有一个抽象方法：<code>public int compareTo(Object o)</code>用来实现排序规则。</li>
</ul>
<p><a href="#com">比较器</a></p>
<h2 id="6-8-Map接口"><a href="#6-8-Map接口" class="headerlink" title="6.8 Map接口"></a>6.8 Map接口</h2><p>此接口与 Collection 接口没有任何的关系，是第二大的集合操作接口。此接口常用方法如下：</p>
<ul>
<li><p>void clear()：清空 Map 集合中的内容</p>
</li>
<li><p>boolean containsKey(Object key)：判断集合中是否存在指定的 key</p>
</li>
<li><p>boolean containsValue(Object value)：判断集合中是否存在指定的 value</p>
</li>
<li><font color="red">**Set<Map.Entry<K,V>> entrySet()：将 Map 接口变为 Set 集合**</font>
</li>
<li><font color="red">**V get(Object key)：根据 key 找到其对应的 value**</font> 
</li>
<li><font color="red">**V put(K key,V value)：向集合中增加内容**</font>
</li>
<li><p>void putAll(Map&lt;? extends K,? extends V&gt; m)：增加一组集合</p>
</li>
<li><p>V remove(Object key)：根据 key 删除内容</p>
</li>
<li><font color="red">**Set<K> keySet()**
**普通**
**将全部的 key 变为 Set 集合**</font> 

<p>注意：Map的遍历方法就是通过keySet方法获取key的set集合，然后遍历这一set集合</p>
</li>
<li><p>boolean isEmpty()：判断是否为空</p>
</li>
</ul>
<h2 id="6-9哈希表理解"><a href="#6-9哈希表理解" class="headerlink" title="6.9哈希表理解"></a>6.9哈希表理解</h2><p>对象+数组+链表，在链表长度达到一定程度以后还会转为二叉树</p>
<p>对象：继承自Object的hashCode方法，提供哈希码</p>
<p>数组：默认长度16，通过哈希码%16的方式，获取数组下标存放对象，数组的每个下标被称为哈希桶</p>
<p>链表：当存储的下标出现重复的时候，用链表进行存储</p>
<p>二叉树：JDK1.8之后，当哈希桶中的数据量大于8的时候，链表会转换为红黑树（更便于查找）；当哈希桶中的数据量减小到6时，又会转为链表</p>
<h3 id="6-9-1-散列因子（0-75）"><a href="#6-9-1-散列因子（0-75）" class="headerlink" title="6.9.1 散列因子（0.75）"></a>6.9.1 散列因子（0.75）</h3><p>为了避免数据过于拥挤，当已存储的哈希桶数量是哈希桶总数（当前的数组长度）的75%时，对数组进行扩容，扩容长度为原来的2倍</p>
<p>散列因子越大，则空间利用率越高，发生哈希碰撞的概率也更高，效率变低</p>
<p>反之则效率变高，即空间和效率的权衡</p>
<h3 id="6-9-2-初始容量（16）"><a href="#6-9-2-初始容量（16）" class="headerlink" title="6.9.2 初始容量（16）"></a>6.9.2 初始容量（16）</h3><p> 初始容量即创建哈希表时的容量，当哈希表中的散列数超过散列因子和当前容量的乘积时，哈希表将重建内部数据结构（将原先的数据拿出，扩容，再重新添加），如果初始容量不合理，可能会导致大量的时间用于散列</p>
<h2 id="6-10-HashMap"><a href="#6-10-HashMap" class="headerlink" title="6.10 HashMap"></a>6.10 HashMap</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210308110454.png" alt="image-20210308110447134"></p>
<h2 id="6-11-Map集合的子类区别分析"><a href="#6-11-Map集合的子类区别分析" class="headerlink" title="6.11 Map集合的子类区别分析"></a>6.11 Map集合的子类区别分析</h2><h3 id="6-11-1-HashMap，HashTable，ConcurrentHashMap"><a href="#6-11-1-HashMap，HashTable，ConcurrentHashMap" class="headerlink" title="6.11.1 HashMap，HashTable，ConcurrentHashMap"></a>6.11.1 HashMap，HashTable，ConcurrentHashMap</h3><p>区别：线程安全与否</p>
<p>HashMap：线程不安全</p>
<p>HashTable：线程安全</p>
<p>ConcurrentHashMap：采用分段锁机制，保证线程安全，效率比较高</p>
<h3 id="6-11-2-TreeMap"><a href="#6-11-2-TreeMap" class="headerlink" title="6.11.2 TreeMap"></a>6.11.2 TreeMap</h3><p>和TreeSet类似，增加了排序功能，在操作的时候将按照 key 进行排序，同样要求作为key的类型实现comparable接口</p>
<h3 id="6-11-3-LinkedHashMap"><a href="#6-11-3-LinkedHashMap" class="headerlink" title="6.11.3 LinkedHashMap"></a>6.11.3 LinkedHashMap</h3><p>在数据存储到HashMap的同时，还添加到一个双向链表中，这就使得数据存储时可以有序，又兼具哈希表快速检索的优点</p>
<h2 id="6-12-JDK9新特性"><a href="#6-12-JDK9新特性" class="headerlink" title="6.12 JDK9新特性"></a>6.12 JDK9新特性</h2><p>创建一个固定长度且不可改变的集合的简便方法：</p>
<p>只有List，Set，Map三个接口下的静态方法，子类均未继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l = List.of(<span class="string">"123"</span>,<span class="string">"321"</span>);</span><br><span class="line"><span class="keyword">for</span>(String s: l)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">321</span></span><br></pre></td></tr></table></figure>
<h2 id="6-13-比较器（comparator和comparable）"><a href="#6-13-比较器（comparator和comparable）" class="headerlink" title="6.13 比较器（comparator和comparable）"></a>6.13 <a name="com">比较器（comparator和comparable）</a></h2><p>与Objects类类似，为了操作集合，有专门的类Collections，存储了用于集合操作的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collections类</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//默认将指定列表按升序排序（类内部必须实现Comparable接口）</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//根据指定比较器引发的顺序对指定列表进行排序。</span></span></span><br></pre></td></tr></table></figure>
<p><code>Arrays.sort()</code>功能与之相同，作用于数组结构</p>
<p>Comparator使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 年龄降序</span></span><br><span class="line">        <span class="keyword">int</span> result = o2.getAge()-o1.getAge();<span class="comment">//年龄降序</span></span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;<span class="comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span></span><br><span class="line">        	result = o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回值问题：</p>
<p>可以将o1,o2理解为左边的元素和右边的元素，如果返回值为-1，则维持原集合，如果返回值为1，则两元素调换位置</p>
<p>所以当<code>return o2.getAge()-o1.getAge()</code>时，o2大则返回正值，将o2和o1对调（o2在左，o1在右），从左到右为降序</p>
<p>如果想要升序排列：<code>return o1-o2</code></p>
</li>
</ul>
<p>Comparable使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回的数据：负数-this小，0-this和o相同（此时重复），正数-this大</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age&lt;o.age) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.age==o.age) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回值问题：（和Comparator类比）</p>
<p>可以将this比作o1，传入的对象比作o2！！！</p>
</li>
</ul>
<h2 id="6-14-equals、hashCode-与内存泄露"><a href="#6-14-equals、hashCode-与内存泄露" class="headerlink" title="6.14 equals、hashCode 与内存泄露"></a>6.14 equals、hashCode 与内存泄露</h2><p>存储自定义对象时equals和hashCode的写法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">    Private name;</span><br><span class="line">    Private info;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == o)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="keyword">null</span> || getClass() != o.getClass())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Book book = (Book) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, book.name) &amp;&amp; Objects.equals(info, book.info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-14-1-两个方法的约定"><a href="#6-14-1-两个方法的约定" class="headerlink" title="6.14.1 两个方法的约定"></a>6.14.1 两个方法的约定</h3><p>首先必需清楚，当 String 、Math、还有 Integer、Double。。。。等这些封装类在使用 equals()方法时，已经覆盖了 object类的 equals（）方法，不再是地址的比较而是内容的比较。</p>
<p>equals方法在重写时必须遵守的规范：</p>
<p>自反性，对称性，传递性，一致性（多次调用结果一致），非空性（非空对象a.equals(null）一定为false）</p>
<p>java.lang.Object 中对 hashCode 的约定（很重要）：</p>
<ul>
<li><p>如果一个对象的 equals 方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode 方法多次，<strong>它必须始终如一地返回同一个整数(一致性)</strong></p>
</li>
<li><p>如果两个对象根据 <strong>equals(Object o)方法是相等的</strong>，则调用这两个对象中任一对象的 <strong>hashCode 方法必须产生相同的整数结果</strong></p>
<p>（所以修改equals，hashCode方法也要跟着修改）</p>
</li>
<li><p>如果两个对象根据 equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的 hashCode 方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能（哪怕是不着边的两个对象，进行hashCode的时候都可能返回相同结果）</p>
</li>
</ul>
<h3 id="6-4-2-对象相等的判断"><a href="#6-4-2-对象相等的判断" class="headerlink" title="6.4.2 对象相等的判断"></a>6.4.2 对象相等的判断</h3><p>在 java 的集合中，判断两个对象是否相等的规则是：</p>
<ul>
<li><p>判断两个对象的 hashCode 是否相等</p>
<ul>
<li><p>如果不相等，认为两个对象也不相等，完毕</p>
</li>
<li><p>如果相等，转入 2（不能判断就是相等的，还要再判断）</p>
<p>（这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。后面会重点讲到这个问题。）</p>
</li>
</ul>
</li>
<li><p>判断两个对象用 equals 运算是否相等</p>
<ul>
<li>如果不相等，认为两个对象也不相等</li>
<li>如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键）</li>
</ul>
</li>
</ul>
<h3 id="6-4-3-内存泄漏"><a href="#6-4-3-内存泄漏" class="headerlink" title="6.4.3 内存泄漏"></a>6.4.3 内存泄漏</h3><p>对于一个已经被存进 HashSet 集合或Map集合中作为key的对象，不能修改这个对象中<font color="red"><strong>参与计算哈希值的字段</strong></font>了，一旦修改，哈希值也被修改，用Contains方法判断元素是否存在或者get（key）方法获取目标对象时必然检索不到，这会导致无法从 HashSet 集合中删除当前对象，从而造成内存泄露</p>
<h1 id="7-流（java-io）"><a href="#7-流（java-io）" class="headerlink" title="7. 流（java.io）"></a>7. 流（java.io）</h1><h2 id="7-1-概念-p-277"><a href="#7-1-概念-p-277" class="headerlink" title="7.1 概念(p/277)"></a>7.1 概念(p/277)</h2><ul>
<li><p>目的：越出JVM，或者说是内存，与外界进行数据交换。</p>
<p>也就是将数据传输这一行为抽象为流这个概念，或者也可以具象的将流理解为数据的通道</p>
</li>
<li><p>异常：</p>
<p>无论是文件对象，还是流对象，在创建时就必须处理IOException</p>
</li>
</ul>
<h2 id="7-2-java-io-File"><a href="#7-2-java-io-File" class="headerlink" title="7.2 java.io.File"></a>7.2 java.io.File</h2><p>一个File类的对象就可以抽象的表示一个文件，表示的文件可以不存在，此时创建的对象就可以通过File类的方法进行文件的创建，修改，删除等操作</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过路径创建字符串实例</span></span><br><span class="line">File(String pathname)</span><br><span class="line"><span class="comment">//通过String parent创建目录，通过child创建文件</span></span><br><span class="line">File(String parent, String child)</span><br><span class="line"><span class="comment">//通过File parent创建目录，通过child创建文件    </span></span><br><span class="line">File(File parent, String child)</span><br><span class="line">    <span class="comment">//例子：</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C://haha"</span>);</span><br><span class="line">        file.mkdir();</span><br><span class="line">        File txt = <span class="keyword">new</span> File(file, <span class="string">"1"</span>);</span><br><span class="line">        txt.createNewFile();</span><br><span class="line">        File txt2 = <span class="keyword">new</span> File(<span class="string">"C://haha"</span>,<span class="string">"2.txt"</span>);</span><br><span class="line">        txt2.mkdir();</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件 </span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"C://1.txt"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = file.createNewFile();</span><br><span class="line">System.out.println(flag? <span class="string">"创建成功"</span>：<span class="string">"创建失败"</span>)；</span><br><span class="line"><span class="comment">//创建目录</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"C://1.txt"</span>);</span><br><span class="line">dir.mkdir();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> <span class="comment">//删除此抽象路径名表示的文件或目录。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> <span class="comment">// 测试此抽象路径名表示的文件或目录是否存在。 </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">File <span class="title">getAbsoluteFile</span><span class="params">()</span> <span class="comment">//返回此抽象路径名的绝对形式。  </span></span></span><br><span class="line"><span class="function">String <span class="title">getAbsolutePath</span><span class="params">()</span> <span class="comment">//返回此抽象路径名的绝对路径名字符串。  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="comment">//返回此抽象路径名表示的文件或目录的名称。  </span></span></span><br><span class="line"><span class="function">String <span class="title">getParent</span><span class="params">()</span> <span class="comment">//返回此抽象路径名父项的路径名字符串，如果此路径名未指定父目录，则返回 null 。  </span></span></span><br><span class="line"><span class="function">File <span class="title">getParentFile</span><span class="params">()</span> <span class="comment">//返回此抽象路径名父项的抽象路径名，如果此路径名未指定父目录，则返回 null 。  </span></span></span><br><span class="line"><span class="function">String <span class="title">getPath</span><span class="params">()</span> <span class="comment">//将此抽象路径名转换为路径名字符串。  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> <span class="comment">//测试此抽象路径名表示的文件是否为目录。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> <span class="comment">//测试此抽象路径名表示的文件是否为普通文件。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String[] <span class="title">list</span><span class="params">()</span> <span class="comment">//返回一个字符串数组，用于命名此抽象路径名表示的目录中的文件和目录 </span></span></span><br><span class="line"><span class="function">File[] <span class="title">listFiles</span><span class="params">()</span> <span class="comment">//返回一个抽象路径名数组，表示此抽象路径名表示的目录中的文件。 </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span> <span class="comment">//重置文件（dest为指定的新抽象路径名）。</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件操作案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D://安装包"</span>);</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        listFiles(files);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listFiles</span><span class="params">(File[] files)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(files == <span class="keyword">null</span> || files.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(File file: files)&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                <span class="keyword">if</span>(file.getName().endsWith(<span class="string">".exe"</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(file.length()&gt;<span class="number">200</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">                        System.out.println(file.getAbsoluteFile());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                File[] files1 = file.listFiles();</span><br><span class="line">                listFiles(files1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤器（FileFilter）使用案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//过滤器的生成方法：FileFilter接口+重写accept方法</span></span><br><span class="line">        FileFilter filter = <span class="keyword">new</span> FileFilter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(pathname.getName().endsWith(<span class="string">".exe"</span>) || pathname.isDirectory())&#123;</span><br><span class="line">                    <span class="comment">//返回值为true即代表过滤器选通</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//除了上面选通的其他都无法通过</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//过滤器的使用场景</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"d://安装包"</span>);</span><br><span class="line">        File[] files = file.listFiles(filter);<span class="comment">//满足过滤器要求的被存入files</span></span><br><span class="line">        listFiles(files);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listFiles</span><span class="params">(File[] files)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(files == <span class="keyword">null</span> || files.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(File file: files)&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                <span class="keyword">if</span>(file.length()&gt;<span class="number">200</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">                    System.out.println(file.getAbsoluteFile());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                File[] files1 = file.listFiles();</span><br><span class="line">                listFiles(files1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7-3-流概述"><a href="#7-3-流概述" class="headerlink" title="7.3 流概述"></a>7.3 流概述</h2><p>可以将数据传输操作,看做一种数据的流动 , 按照流动的方向分为输入Input和输出Output</p>
<p>Java中的IO操作主要指的是 java.io包下的一些常用类的使用. 通过这些常用类对数据进行读取(输入Input) 和 写出(输出Output)，可以理解为流传输的管道和驱动装置，这里的输入和输出也都是相对于内存而言的！！</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IO流的分类:</span><br><span class="line"><span class="bullet">*  </span>按照流的方向来分,可以分为:输入流和输出流.</span><br><span class="line"><span class="bullet">*  </span>按照流动的数据类型来分,可以分为:字节流和字符流</span><br><span class="line"><span class="strong">*</span></span><br><span class="line"><span class="strong">*</span>     字节流:</span><br><span class="line"><span class="bullet">*          </span>-   输入流 :   InputStream</span><br><span class="line"><span class="bullet">*          </span>-   输出流 :   OutputStream</span><br><span class="line"><span class="bullet">*     </span>字符流:</span><br><span class="line"><span class="bullet">*          </span>-   输入流 :   Reader</span><br><span class="line"><span class="bullet">*          </span>-   输出流 :   Writer</span><br><span class="line"><span class="strong">*</span></span><br><span class="line"><span class="strong">*</span> 一切皆字节:</span><br><span class="line"><span class="bullet">*      </span>计算机中的任何数据(文本,图片,视频,音乐等等)都是以二进制的形式存储的.</span><br><span class="line"><span class="bullet">*      </span>在数据传输时 也都是以二进制的形式存储的.</span><br><span class="line"><span class="bullet">*      </span>后续学习的任何流 , 在传输时底层都是二进制.</span><br></pre></td></tr></table></figure>
<h2 id="7-4-字节流（byte）"><a href="#7-4-字节流（byte）" class="headerlink" title="7.4 字节流（byte）"></a>7.4 字节流（byte）</h2><p>abstract修饰的抽象类，extends Object，输出字节流的所有类的父类，输出流接受输出字节并将他们发送到某个接收器</p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="comment">//将 b.length字节从指定的字节数组写入此输出流。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//将从偏移量 off开始的指定字节数组中的 len字节写入此输出流。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="comment">//将指定的字节写入此输出流。  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> 关闭此输出流并释放与此流关联的所有系统资源。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> 刷新此输出流并强制写出任何缓冲的输出字节。</span></span><br></pre></td></tr></table></figure>
<p>写完一定要执行close（）将流关闭，不然内存被持续占用，文件无法关闭</p>
<h3 id="字节流的常用子类"><a href="#字节流的常用子类" class="headerlink" title="字节流的常用子类"></a>字节流的常用子类</h3><h3 id="7-4-1-FileOutputStream"><a href="#7-4-1-FileOutputStream" class="headerlink" title="7.4.1 FileOutputStream"></a>7.4.1 FileOutputStream</h3><p>用于将数据写入文件的管道，写入方法和OutputStream没有区别</p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(File file, <span class="keyword">boolean</span> append) <span class="comment">//创建文件输出流以写入由指定的 File对象表示的文件。 </span></span><br><span class="line"></span><br><span class="line">FileOutputStream(String name, <span class="keyword">boolean</span> append) <span class="comment">//创建文件输出流以写入具有指定名称的文件。</span></span><br></pre></td></tr></table></figure>
<p>常用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileOutputStream outFile = <span class="keyword">new</span> FileOutputStream(<span class="string">"d://1.txt"</span>);</span><br><span class="line">    <span class="comment">//需要处理FileNotFoundException：虽然没有文件会自动创建，但是有可能因为系统原因创建不了</span></span><br><span class="line">    </span><br><span class="line">    outFile.write(<span class="number">65</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] b = &#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</span><br><span class="line">    outFile.write(b);</span><br><span class="line">    outFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意抛出的异常类型</p>
<h3 id="7-4-2-FileInputStream"><a href="#7-4-2-FileInputStream" class="headerlink" title="7.4.2 FileInputStream"></a>7.4.2 FileInputStream</h3><p>构造方法和读取方法与FileOutputStream无异</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="comment">//从此输入流中读取一个字节的数据。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="comment">//从此输入流将b.length字节的数据读入数组。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//从此off开始将len字节的数据读入一个字节数组。</span></span></span><br></pre></td></tr></table></figure>
<p><code>read（）</code>的返回值表示读取的字节值，<font color="red"><strong>如果已经读到流末尾再执行read方法，返回值为-1</strong></font></p>
<p>返回值表示读出的字节长度，<font color="red"><strong>如果已经读到流末尾再执行read方法，返回值为-1</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.io.FileInputStream fis = <span class="keyword">new</span> java.io.FileInputStream(<span class="string">"d://1//1.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> len = fis.read(bytes);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">len = fis.read(bytes);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">len = fis.read(bytes);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
<h3 id="7-4-3-字节输入流的乱码问题"><a href="#7-4-3-字节输入流的乱码问题" class="headerlink" title="7.4.3 字节输入流的乱码问题"></a>7.4.3 字节输入流的乱码问题</h3><h3 id="7-4-4-字节流总结"><a href="#7-4-4-字节流总结" class="headerlink" title="7.4.4 字节流总结"></a>7.4.4 字节流总结</h3><ul>
<li><p>输出流的常用类：FileOutputStream</p>
<p>声明流对象的构造器的传入参数：写出内容的地址</p>
<p>write方法的传入参数：需要传输的文件</p>
</li>
<li><p>输出流的常用类：FileOutputStream</p>
<p>声明流对象的构造器的传入参数：写出内容的地址</p>
<p>write方法的传入参数：需要传输的文件</p>
</li>
</ul>
<h2 id="7-5-字符流（char）"><a href="#7-5-字符流（char）" class="headerlink" title="7.5 字符流（char）"></a>7.5 字符流（char）</h2><h3 id="7-5-1-字符输出流"><a href="#7-5-1-字符输出流" class="headerlink" title="7.5.1 字符输出流"></a>7.5.1 字符输出流</h3><p>父类Writer，类似OutputStream是抽象类，常用子类FileWriter</p>
<p>写入的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> <span class="comment">//写一个字符数组。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//写一个字符数组的一部分。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="comment">//写一个字符。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> <span class="comment">//写一个字符串。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//写一个字符串的一部分</span></span></span><br></pre></td></tr></table></figure>
<p>追加的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Writer <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="comment">//将指定的字符追加到此writer。  </span></span></span><br><span class="line"><span class="function">Writer <span class="title">append</span><span class="params">(CharSequence csq)</span> <span class="comment">//将指定的字符序列追加到此writer。  </span></span></span><br><span class="line"><span class="function">Writer <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> <span class="comment">//将指定字符序列的子序列追加到此writer。</span></span></span><br></pre></td></tr></table></figure>
<p>此方法较为常用，底层实现就是直接调用上面的write方法！！！为什么呢？？</p>
<p>因为append的返回值为Writer，于是就可以说实现如下所示的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"d://1.txt"</span>, <span class="keyword">true</span>);</span><br><span class="line">fw.append(<span class="string">"123"</span>).append(<span class="string">"abc"</span>).append(<span class="string">"ABC"</span>);</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<p>构造方法中的<code>boolean append</code>参数和<code>append()</code>方法没啥关系：前者为true，则表示每次生成的输出流都是在原有文件基础上追加；</p>
<p>后者则表示每次写入的内容可以连着追加写入</p>
<h3 id="7-5-2-字符输入流"><a href="#7-5-2-字符输入流" class="headerlink" title="7.5.2 字符输入流"></a>7.5.2 字符输入流</h3><p>抽象类：java.io.Reader，常用子类java.io.FileReader</p>
<p>计算机的底层操作本身是以字节为单位进行传输的，字符流这个管道就是通过将传入的单个字节进行缓存，能够拼凑成一个字符时才有资格输出</p>
<h2 id="7-6-flush刷新管道"><a href="#7-6-flush刷新管道" class="headerlink" title="7.6 flush刷新管道"></a>7.6 flush刷新管道</h2><p>将管道中的缓存数据直接传出给接收方，比如对于字符流的操作，在使用流进行数据读写出的时候，如果不使用close方法，是看不到数据写到硬盘的。（字节流是不需要的）</p>
<p>执行close（）方法时同样是先进行flush（）操作</p>
<h2 id="7-7-字节装饰为字符流"><a href="#7-7-字节装饰为字符流" class="headerlink" title="7.7 字节装饰为字符流"></a>7.7 字节装饰为字符流</h2><p>使用了：装饰者设计模式</p>
<ul>
<li><p>通过字符流的构造方法：以输出流为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d://1.txt"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将字节流转为字符流</span></span><br><span class="line"><span class="comment">参数1.字节流对象</span></span><br><span class="line"><span class="comment">参数2.指定编码名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"GBK"</span>);<span class="comment">//Writer抽象类的子类</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过打印流的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d://1.txt"</span>);</span><br><span class="line">PrintWriter pw= <span class="keyword">new</span> PrintWriter(fos);</span><br><span class="line">pw.println(<span class="string">"123"</span>);</span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7-8-打印流及缓存流"><a href="#7-8-打印流及缓存流" class="headerlink" title="7.8 打印流及缓存流"></a>7.8 打印流及缓存流</h2><h3 id="7-8-1打印流-写到硬盘"><a href="#7-8-1打印流-写到硬盘" class="headerlink" title="7.8.1打印流(写到硬盘)"></a>7.8.1打印流(写到硬盘)</h3><p><strong>对于需要输出到本地的时候，推荐使用打印流</strong></p>
<p>同样是进行数据的写出，和字符及字节的输出流一样的功能，也分为字符和字节流</p>
<p><strong>字节打印流：java.io.PrintStream，父类为FileOutputStream</strong></p>
<p><strong>字符打印流：java.io.PrintWriter，父类为Writer</strong></p>
<h3 id="7-8-2-标准IO"><a href="#7-8-2-标准IO" class="headerlink" title="7.8.2 标准IO"></a>7.8.2 标准IO</h3><p>其实就是控制台输入输出，<code>java.lang.System</code>的3个静态成员提供了标准输入输出的操作功能</p>
<p>System.out：java.io.PrintStream类型，PrintStream类的write方法本来是写到输出流或数据源中，对于System.out，<strong>JVM启动时将其重定向在计算机的终端窗口</strong></p>
<p>System.in：java.io.InputStream类型，本来是从输入流或数据源中读数据，<strong>JVM启动时将其重定向在计算机键盘。</strong></p>
<h3 id="7-8-3-缓存流"><a href="#7-8-3-缓存流" class="headerlink" title="7.8.3 缓存流"></a>7.8.3 缓存流</h3><p>从输入或者输出流中（而不是文件中）读取文本，缓冲字符，以便有效的读取字符，</p>
<p>以缓存读取流为例：将字符输入流，转换为带有缓存，可以一次读取一行的缓存字符读取流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileReader fw = <span class="keyword">new</span> FileReader(<span class="string">"d://1.txt"</span>);</span><br><span class="line">BufferedReader br= <span class="keyword">new</span> BufferReader(fw);</span><br><span class="line">String textLine = br.readLine();</span><br><span class="line">System.out.println(textLine);</span><br></pre></td></tr></table></figure>
<h2 id="7-9-收集异常日志"><a href="#7-9-收集异常日志" class="headerlink" title="7.9 收集异常日志"></a>7.9 收集异常日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    String s = <span class="keyword">null</span>;</span><br><span class="line">    s.toStirng();</span><br><span class="line">&#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">    <span class="comment">//先创建打印流对象</span></span><br><span class="line">    PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">"d://1.txt"</span>);</span><br><span class="line">    simpleDateFormat sdf = <span class="keyword">new</span> simpleDateFormat(<span class="string">"yyyy-MM-dd HH-mm"</span>);</span><br><span class="line">    System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    e.printStackTrace(pw);</span><br><span class="line">    pw.close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-10-Properties类"><a href="#7-10-Properties类" class="headerlink" title="7.10 Properties类"></a>7.10 Properties类</h2><p>java.util包下，父类为java.util.hashMap，对，这个类构建的对象也是一个Map集合</p>
<p>在进行本地存储时需要实现一定的格式，Properties类就是实现这一功能的类之一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Properties ppt = <span class="keyword">new</span> Properties();</span><br><span class="line">ppt.put(<span class="string">"name"</span>, <span class="string">"金苹果"</span>);</span><br><span class="line">ppt.put(<span class="string">"info"</span>, <span class="string">"金苹果的种植方法"</span>);</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">"d://1.txt"</span>);</span><br><span class="line"><span class="comment">//保存到本地</span></span><br><span class="line">ppt.store(pw, <span class="string">"this is a book"</span>);</span><br><span class="line">pw.close();</span><br><span class="line"><span class="comment">//从本地读到内存</span></span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"d://1.txt"</span>);</span><br><span class="line">ppt.load(fr);</span><br><span class="line">System.out.println(ppt.getProperty(<span class="string">"name"</span>));</span><br><span class="line">System.out.println(ppt.getProperty(<span class="string">"info"</span>));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210311222549.png" alt="image-20210311222542637"></p>
<h2 id="7-11-序列化和反序列化"><a href="#7-11-序列化和反序列化" class="headerlink" title="7.11 序列化和反序列化"></a>7.11 序列化和反序列化</h2><p>把java对象转换为字节序列，才能实现网络传送，本地存储。把java对象转换为字节序列保存起来的过程称为对象的序列化，再将字节序列恢复为java对象的过程称为反序列化。这里的序列应该是指二进制序列。</p>
<p>方法：</p>
<p>对象要想能够实现序列化，其所属类型必须<strong>实现Serializable接口或Externalizable接口</strong>。</p>
<p>实现方法：</p>
<p>ObjectOutputStream/ObjectInputStream这一对流类，分别是writeObject()方法和readObject()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象序列化</span></span><br><span class="line">OutputStream os = <span class="keyword">new</span> FileOutputStream(pathname);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">oos.writeObject(Student);</span><br><span class="line">oos.close;</span><br></pre></td></tr></table></figure>
<h3 id="7-11-1-部分属性序列化"><a href="#7-11-1-部分属性序列化" class="headerlink" title="7.11.1 部分属性序列化"></a>7.11.1 部分属性序列化</h3><ul>
<li><p>使用transient修饰符</p>
<p>在不想被序列化的属性前加上transient修饰符</p>
</li>
<li><p>static修饰符</p>
<p>静态属性被所有对象共享，哪怕对象再序列化之后，操作set方法对静态属性进行修改，此时反序列化的结果即为修改后的结果</p>
</li>
<li><p>在需要序列化的类中添加默认方法writeObject/readObject</p>
<blockquote>
<p>添加的两个方法必须是private修饰</p>
<p>JVM调用ObjectOutputStream类判断两个添加的方法是否有私有的，无返回值的writeObject方法，如果有，则调用该方法进行序列化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream oos)</span></span>&#123;</span><br><span class="line">    oos.writeObject(属性<span class="number">1</span>);</span><br><span class="line">    oos.writeObject(属性<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即调用对象自有的writeObject方法，想要什么属性序列化就将其添加进去</p>
</li>
</ul>
<h3 id="7-11-2-Externalizable接口"><a href="#7-11-2-Externalizable接口" class="headerlink" title="7.11.2 Externalizable接口"></a>7.11.2 Externalizable接口</h3><p>继承自Serializable，使用Externallizable接口必须重写writeExternal和readExternal两个抽象方法，这两个方法其实对应Serializable接口的writeObject和readObject方法。</p>
<p>可以理解为：Externalizable接口的存在就是为了抽象出这两个方法</p>
<p>就像上面的部分属性序列化的方法3：通过重写写入或读出序列的方法，对每个属性单独执行写入或读出操作，即可以用Externalizable来重写</p>
<h3 id="7-11-3-两个序列化接口的关系"><a href="#7-11-3-两个序列化接口的关系" class="headerlink" title="7.11.3 两个序列化接口的关系"></a>7.11.3 两个序列化接口的关系</h3><div class="table-container">
<table>
<thead>
<tr>
<th>区别</th>
<th>Serializable</th>
<th>Externalizable</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现复杂度</td>
<td>简单，JVM有内建支持</td>
<td>复杂，有开发人员自己完成</td>
</tr>
<tr>
<td>执行效率</td>
<td>所有对象全部保存，效率低</td>
<td>开发人员自己选择保存属性，效率较高</td>
</tr>
<tr>
<td>保存信息</td>
<td>空间大</td>
<td>空间小</td>
</tr>
<tr>
<td>使用频率</td>
<td>高</td>
<td>低</td>
</tr>
</tbody>
</table>
</div>
<h2 id="7-12-try-with-resources"><a href="#7-12-try-with-resources" class="headerlink" title="7.12 try-with-resources"></a>7.12 try-with-resources</h2><p>1.7之前的IO异常处理try-catch语句块：finally块在try块之外不能使用fr</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fr = <span class="keyword">new</span> FileReader(<span class="string">"c：//book.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> c = fr.read();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fr.close();  </span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.7:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"c：//book.txt"</span>))&#123;</span><br><span class="line">    <span class="keyword">int</span> c = fr.read();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">    fr.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求，在try中可以创建对象的类，必须实现Closeable或AutoCloseable接口，运行结束后自动进行关闭操作</p>
<p>JDK9:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"c：//book.txt"</span>);</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">"c：//book.txt"</span>);</span><br><span class="line"><span class="keyword">try</span>(fr;pw)&#123;</span><br><span class="line">    <span class="keyword">int</span> c = fr.read();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-13-相对路径"><a href="#7-13-相对路径" class="headerlink" title="7.13 相对路径"></a>7.13 相对路径</h2><p>java中相对路径的表示：</p>
<ol>
<li><p>以工作目录作为当前目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前目录： E://idea-project//day34_xmlAndJson</span></span><br><span class="line"><span class="comment">//相对路径：src//com//java//demo1</span></span><br><span class="line"><span class="comment">//表示的绝对路径：E://idea-project//day34_xmlAndJson//src//com//java//demo1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同样以工作目录作为当前目录</p>
<p><code>.</code>表示本目录，<code>..</code>表示父目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//得到指向xml文件的输入流</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"../idea-exe"</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">        System.out.println(f.getCanonicalFile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">D:\idea-project\day34_xmlAndJson\..\idea-exe</span><br><span class="line">D:\idea-project\idea-exe</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：工作目录的概念：是程序运行时的起始目录</p>
<p>文件并不一定在当前工程下运行，可能在cmd中的默认路径下用java命令工具执行，这时候的工作目录就是cmd中的默认路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//得到指向xml文件的输入流</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"src/com/java/demo1"</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//idea中直接运行结果：</span></span><br><span class="line">D:\idea-project\day34_xmlAndJson\src\com\java\demo1</span><br><span class="line"><span class="comment">//cmd中运行结果</span></span><br><span class="line">C:\Users\biongd&gt;java -jar D:\idea-project\day34_xmlAndJson\out\artifacts\day34_xmlAndJson_jar\day34_xmlAndJson.jar</span><br><span class="line">C:\Users\biongd\src\com\java\demo1</span><br></pre></td></tr></table></figure>
<p>可以看出其工作目录就是运行目录</p>
<h2 id="7-14-总结"><a href="#7-14-总结" class="headerlink" title="7.14 总结"></a>7.14 总结</h2><h3 id="修改源文件中某一行的内容"><a href="#修改源文件中某一行的内容" class="headerlink" title="修改源文件中某一行的内容"></a>修改源文件中某一行的内容</h3><ol>
<li>输出流在建立的时候会将文件清空，在创建File的对象的时候传入参数true可以保留之前内容</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(File f,String target,String src)</span> <span class="keyword">throws</span> IOException </span>&#123;<span class="comment">//修改</span></span><br><span class="line">    BufferedReader br= <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(f));</span><br><span class="line">    PrintWriter pw= <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(f,<span class="keyword">true</span>));</span><br><span class="line">    <span class="keyword">try</span>(br;pw)&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String huanhang =System.getProperty(<span class="string">"line.separator"</span>);<span class="comment">//平台换行!</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            String line = br.readLine();</span><br><span class="line">            <span class="keyword">if</span>(line == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(line.contains(target))&#123;</span><br><span class="line">                line = src;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(line+huanhang);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        String a = sb.toString();</span><br><span class="line">        pw.println(a);</span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源文件：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234</span></span><br><span class="line">abcd</span><br></pre></td></tr></table></figure>
<ol>
<li>先全部读出，完成修改并保存内容到内存后再建立输出流，此时就可以清空内容再写入</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = sb.toString();</span><br><span class="line">PrintWriter pw= <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(f,<span class="keyword">true</span>));</span><br><span class="line">pw.println(a);</span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure>
<h1 id="8-多线程"><a href="#8-多线程" class="headerlink" title="8. 多线程"></a>8. 多线程</h1><h2 id="8-1-线程和进程"><a href="#8-1-线程和进程" class="headerlink" title="8.1 线程和进程"></a>8.1 线程和进程</h2><p>进程的概念：<a href="https://biongd.gitee.io/2020/07/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">操作系统-进程</a></p>
<h3 id="8-1-1-进程和线程的关系："><a href="#8-1-1-进程和线程的关系：" class="headerlink" title="8.1.1 进程和线程的关系："></a>8.1.1 进程和线程的关系：</h3><ul>
<li><p>进程</p>
<p>一个内存中运行的应用程序，每个应用程序都有独立的内存空间</p>
</li>
<li><p>线程</p>
<p>是进程中的一个执行路径，共享一个内存空间，线程之间可以自由切换，并发执行. 一个进程最少有一个线程</p>
<p>线程实际上是在进程基础之上的进一步划分，一个进程启动之后，里面的若干执行路径又可以划分成若干个线程</p>
</li>
<li><p>两者的关系</p>
<p>其实上面包括我之前的文章总结一下就很好理解：进程是建立在线程之上的一个空泛的概念，在任务管理器中看到的进程实际上底层在执行的是实现这个应用程序功能的所有线程！进程就类似于一个接口，而线程就是能够具体实现的子类！</p>
<p>所以：</p>
<ul>
<li>进程是系统资源分配的单位</li>
<li>线程是CPU调度和执行的单位</li>
<li><strong>一个单核的cpu可以并发的执行多条进程，但是这本质上也是从一个进程的一个线程跳到另一个进程的一个线程！！！！！</strong></li>
</ul>
<p>注意：</p>
<ul>
<li>线程没有独立的存储空间，一个进程下的所有线程共享</li>
<li>线程之间的切换只需要切换执行流程和相关的局部变量，这种切换要比进程之间的切换效率高得多</li>
</ul>
</li>
</ul>
<h3 id="8-1-2-线程调度"><a href="#8-1-2-线程调度" class="headerlink" title="8.1.2 线程调度"></a>8.1.2 线程调度</h3><p>同样参考上面进程的文章，里面有介绍进程的cpu资源分配方法，其实也就是线程的调度方法</p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
</li>
<li><p>CPU使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高</p>
</li>
</ul>
<blockquote>
<p> 这句话该如何理解呢：</p>
<p>程序计数器只有一个，所以程序并发的执行速度和顺序执行的速度并没有什么区别，反而是切换会导致耗时</p>
<p>但是以一个应用程序的登录界面为例，线程需要接收用户输入才能继续执行，总不能用户不输入程序就崩溃了吧</p>
</blockquote>
<h2 id="8-2-在java中实现多线程"><a href="#8-2-在java中实现多线程" class="headerlink" title="8.2 在java中实现多线程"></a>8.2 在java中实现多线程</h2><h3 id="8-2-1-继承Thread类"><a href="#8-2-1-继承Thread类" class="headerlink" title="8.2.1 继承Thread类"></a>8.2.1 继承Thread类</h3><ul>
<li>创建一个类继承Thread类，此时继承了Thread的子类就是一个线程类</li>
<li>重写run方法<code>public void run()</code>，这个方法的内容就是另外的一条执行路径</li>
<li>这条执行路径的出发方式：线程类的<code>start()</code>方法！</li>
<li>main方法中可以有多条执行路径，只有当所有的路径全部结束，程序才算执行完毕</li>
</ul>
<p>注意：</p>
<p>每个路径都有自己的栈空间，共享同一块堆空间！！每条路径调用的方法也都在其内部执行，执行完后将结果弹出到main</p>
<h3 id="8-2-2-实现Runnable接口"><a href="#8-2-2-实现Runnable接口" class="headerlink" title="8.2.2 实现Runnable接口"></a>8.2.2 实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个任务对象</span></span><br><span class="line">MyRunnable mr = <span class="keyword">new</span>  MyRunnable();</span><br><span class="line"><span class="comment">//创建一个线程，并为其分配一个任务</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(mr);</span><br><span class="line"><span class="comment">//执行这个线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<p> 其实，继承Thread类来实现多线程，其实是相当于拿出三件事即三个卖早餐10份的任务分别分给三个窗口，他们各做各的事各卖各的早餐各完成各的任务，因为MyThread继承Thread类，所以在newMyThread的时候在创建三个对象的同时创建了三个线程；</p>
<p>实现Runnable的， 相当于是拿出一个卖早餐10份的任务给三个人去共同完成，newMyThread相当于创建一个任务，然后实例化三个Thread，创建三个线程即安排三个窗口去执行。</p>
<ul>
<li>相比于继承Thread的优点<ul>
<li>更适合多个线程同时执行相同任务的情况</li>
<li>可以避免单继承带来的局限性</li>
<li>任务于线程本身分离，提高了代码的健壮性</li>
<li>后续学习的线程池，接受Runnable类型，不接受Thread类型</li>
</ul>
</li>
</ul>
<h3 id="8-2-3-实现Callable接口"><a href="#8-2-3-实现Callable接口" class="headerlink" title="8.2.3 实现Callable接口"></a>8.2.3 实现Callable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 编写类实现Callable接口 , 实现call方法</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXX</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 创建FutureTask对象 , 并传入第一步编写的Callable类对象:</span><br><span class="line">FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 通过Thread,启动线程</span><br><span class="line"><span class="keyword">new</span> Thread(future).start();</span><br></pre></td></tr></table></figure>
<p>和Runnable相比，实现Callable接口的区别就在于有一个返回值，并且可以通过get方法获取到这个返回值，在执行<code>get()</code>方法时候，主线程会等待返回值获取到之后才继续进行。</p>
<h2 id="8-3-Thread类"><a href="#8-3-Thread类" class="headerlink" title="8.3 Thread类"></a>8.3 Thread类</h2><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread() <span class="comment">//分配新的 Thread对象。  </span></span><br><span class="line">Thread(Runnable target) <span class="comment">//传入任务参数</span></span><br><span class="line">Thread(Runnable target, String name) <span class="comment">//传入任务参数和名称 </span></span><br><span class="line">Thread(String name)  <span class="comment">//只传入名称</span></span><br></pre></td></tr></table></figure>
<p>优先级字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY 线程可以拥有的最大优先级。  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY 线程可以拥有的最低优先级。  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY 分配给线程的默认优先级。</span><br></pre></td></tr></table></figure>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> 更改此线程的优先级。  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> 返回此线程的优先级。  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span> 返回对当前正在执行的线程对象的引用。 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> 返回此Thread的标识符。  </span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> 返回此线程的名称。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> setName​<span class="params">(String name)</span> 将此线程的名称更改为等于参数 name 。  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> sleep​<span class="params">(<span class="keyword">long</span> millis)</span> 导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，具体取决于系统计时器和调度程序的精度和准确性。  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> sleep​<span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> 导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数加上指定的纳秒数，具体取决于系统定时器和调度程序的精度和准确性。 </span></span><br><span class="line"><span class="function">oolean <span class="title">isDaemon</span><span class="params">()</span> 测试此线程是否为守护程序线程。</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-1-获取和设置线程名称"><a href="#8-3-1-获取和设置线程名称" class="headerlink" title="8.3.1 获取和设置线程名称"></a>8.3.1 获取和设置线程名称</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Thread.currentThread().getName()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"><span class="keyword">new</span> Thread(mr).start(); </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">t.setNmae(<span class="string">"123"</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<h2 id="8-4-线程状态及守护线程"><a href="#8-4-线程状态及守护线程" class="headerlink" title="8.4 线程状态及守护线程"></a>8.4 线程状态及守护线程</h2><ul>
<li><p>线程休眠<code>static void sleep()</code></p>
</li>
<li><p>线程阻塞</p>
<p>可以理解为所有的耗时操作，比如文件的输入输出，就只有等待文件完全读取，线程才能继续执行，这里的等待就被称为线程阻塞</p>
</li>
<li><p>线程中断</p>
<p>一个线程是一个独立的路径，它是否应该结束，应该由它自己决定</p>
<p>线程在执行过程中会占用很多资源，比如硬件资源在未完成时突然中断，可能会导致占用无法释放或者垃圾无法回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    t.interrupt();<span class="comment">//该方法用于给线程添加标记，部分方法在添加标记后执行就会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptException e)&#123;</span><br><span class="line">            <span class="comment">//在添加标记后，再执行该线程的sleep方法就会进入该catch块</span></span><br><span class="line">            <span class="comment">//此时可以决定是否让线程继续！</span></span><br><span class="line">            <span class="comment">//想要让线程结束就直接return，结束run方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以想要让线程中断就可以在catch块内将资源的释放等操作进行执行，最后再return</p>
</li>
<li><p>守护线程</p>
<p>线程的分类：守护线程和用户线程</p>
<p>用户线程：当一个进程的所有用户线程结束，则进行结束</p>
<p>守护线程：守护用户线程，当最后一个用户线程结束后，所有守护线程自动死亡</p>
</li>
</ul>
<h2 id="8-5-线程安全问题-锁"><a href="#8-5-线程安全问题-锁" class="headerlink" title="8.5 线程安全问题-锁"></a>8.5 线程安全问题-锁</h2><p><strong>线程不安全的产生原因：</strong></p>
<ul>
<li>当多个线程对同一个数据进行操作时（比如实现Runnable接口的任务类被多个线程公用），此时无法保证线程在进入时拿到的数据和处理时使用的数据一致（有可能执行中途被别的线程获取时间片，修改数据内容），导致结果不符合预期</li>
</ul>
<p><strong>解决线程不安全的方向：</strong></p>
<ul>
<li>对于被争抢的数据所在的执行代码块，使其排队执行，即在一个线程执行的时候，其余线程排队</li>
</ul>
<h3 id="8-5-1-方法1-同步代码块"><a href="#8-5-1-方法1-同步代码块" class="headerlink" title="8.5.1 方法1-同步代码块"></a>8.5.1 方法1-同步代码块</h3><p>格式：<code>synchronized(锁对象){同步代码块}</code></p>
<blockquote>
<p>锁对象：任何对象都可以作为锁存在（可以打上锁的标记），比如可以传入一个Object对象</p>
<p>锁对象的作用：同时有a,b,c  3个线程执行之一同步代码块，a执行时就会给Object对象加上锁的标记（硬件实现），此时b,c无法执行，a执行结束后，锁标记释放；此时b,c检查到后看是争抢Object对象，争抢到后给对象添加锁标记，开始执行</p>
<p>注意：想要同步的线程必须用同一个锁对象（共用一把锁）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(o)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到：当有一个线程开始执行同步代码块，此时别的线程就只能停留在while处等待该线程执行完，</p>
<h3 id="8-5-2-方法2-同步方法"><a href="#8-5-2-方法2-同步方法" class="headerlink" title="8.5.2 方法2-同步方法"></a>8.5.2 方法2-同步方法</h3><p>给方法添加synchronized的修饰符</p>
<p>同步方法同样有锁，锁对象就是this，也就是同步方法所在的对象！</p>
<p>对于静态方法而言，锁的对象就是当前所在的类：<code>类名.class</code></p>
<h3 id="8-5-3-方法3-显示锁"><a href="#8-5-3-方法3-显示锁" class="headerlink" title="8.5.3 方法3-显示锁"></a>8.5.3 方法3-显示锁</h3><p>上述的同步代码块和同步方法都属于隐式锁</p>
<p>显示锁：Lock类，用的是其子类ReentrantLock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock l = <span class="keyword">new</span> ReentrantLock;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        l.lock();</span><br><span class="line">    	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(o)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        l.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>再次强调： 不管显式锁和隐式锁，对于执行同一任务的线程必须持有同一把锁（锁的声明必须在任务类中的run方法外）！！！</strong></p>
<blockquote>
<p>问：隐式锁和显式锁的区别</p>
</blockquote>
<h3 id="8-5-4-公平锁和非公平锁"><a href="#8-5-4-公平锁和非公平锁" class="headerlink" title="8.5.4 公平锁和非公平锁"></a>8.5.4 公平锁和非公平锁</h3><p>公平锁和非公平锁的区别就在于线程执行顺序的问题</p>
<ul>
<li>公平锁：先到先得，一个锁释放，就由先执行到这一步的线程（比如while循环，排在最前面的线程）来获取锁</li>
<li>非公平锁：抢占式，那个线程抢到那个执行，一般刚刚持有锁的执行完后再获得锁的概率很高</li>
</ul>
<h3 id="8-5-5-线程死锁"><a href="#8-5-5-线程死锁" class="headerlink" title="8.5.5 线程死锁"></a>8.5.5 线程死锁</h3><p>一个加锁（Lock1）的代码块内又有一个加锁（Lock2）的代码块，而Lock2的内部又有Lock1，此时双方都要等待对方的锁释放获得资源才能继续执行，类似于锁存器</p>
<p><a href="https://blog.csdn.net/weixin_43213517/article/details/90314004" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43213517/article/details/90314004</a></p>
<h2 id="8-6-多线程通信问题"><a href="#8-6-多线程通信问题" class="headerlink" title="8.6 多线程通信问题"></a>8.6 多线程通信问题</h2><blockquote>
<p>问：Object的wait方法和Thread的sleep方法有何区别</p>
</blockquote>
<p>生产者和消费者问题：</p>
<p>通过Object的wait方法和notify方法实现线程的等待和唤醒，需要注意的是：</p>
<p>调用obj的wait(), notify()方法前，必须获得锁！！！</p>
<p>要么必须写在synchronized(obj) 代码段内；要么是在synchronized声明的方法中用隐式的锁对象this调用</p>
<h2 id="8-7-线程的状态"><a href="#8-7-线程的状态" class="headerlink" title="8.7 线程的状态"></a>8.7 线程的状态</h2><p>枚举类<code>java.lang.Enum&lt;Thread.State&gt;</code>下的<code>Thread.state</code>类</p>
<ol>
<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>
<li>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>
<li>阻塞(BLOCKED)：表示线程阻塞于锁。</li>
<li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>
<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>
</ol>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210315152157.jpeg" alt="线程状态图"></p>
<h2 id="8-8-线程池Executors"><a href="#8-8-线程池Executors" class="headerlink" title="8.8 线程池Executors"></a>8.8 线程池Executors</h2><ul>
<li><p>为什么需要线程池</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低 系统的效率，因为频繁创建线程和销毁线程需要时间. <strong>线程池就是一个容纳多个线程的容器</strong>，池中的线程可以反复使用，省去了频繁创建线程对象的操作，节省了大量的时间和资源。</p>
</li>
<li><p>线程池的好处</p>
<ul>
<li>降低资源消耗。</li>
<li>提高响应速度。</li>
<li>提高线程的可管理性</li>
</ul>
</li>
</ul>
<h3 id="8-8-1-缓存线程池"><a href="#8-8-1-缓存线程池" class="headerlink" title="8.8.1 缓存线程池"></a>8.8.1 缓存线程池</h3><p>特点：长度无限制</p>
<p>执行流程:</p>
<ul>
<li><ol>
<li>判断线程池是否存在空闲线程</li>
</ol>
</li>
<li><ol>
<li>存在则使用</li>
</ol>
</li>
<li><ol>
<li>不存在,则创建线程 并放入线程池, 然后使用</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//向线程池中 加入 新的任务</span></span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程的名称:"</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程的名称:"</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);<span class="comment">//如果1,2任务未执行完则执行第三个任务时会在缓存线程池中再创建一个线程执行该任务，但是通过加了个等待时间，则下面的任务可以使用上面结束的线程</span></span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程的名称:"</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="8-8-2-定长线程池"><a href="#8-8-2-定长线程池" class="headerlink" title="8.8.2 定长线程池"></a>8.8.2 定长线程池</h3><p>指定线程池长度</p>
<p>执行流程:</p>
<ul>
<li><ol>
<li>判断线程池是否存在空闲线程</li>
</ol>
</li>
<li><ol>
<li>存在则使用</li>
</ol>
</li>
<li><ol>
<li>不存在空闲线程,且线程池未满的情况下,则创建线程 并放入线程池, 然后使用</li>
</ol>
</li>
<li><ol>
<li>不存在空闲线程,且线程池已满的情况下,则等待线程池存在空闲线程</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程的名称:"</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程的名称:"</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如上，新建线程池的方法中传入线程池的长度参数为2 ，则最多只能有两个线程被创建，如果两个线程都在执行，则更多的任务只能等待！！</p>
<h3 id="8-8-3-单线程"><a href="#8-8-3-单线程" class="headerlink" title="8.8.3 单线程"></a>8.8.3 单线程</h3><p>效果与定长线程池 创建时传入数值1 效果一致.</p>
<p>执行流程:</p>
<ul>
<li><ol>
<li>判断线程池 的那个线程 是否空闲</li>
</ol>
</li>
<li><ol>
<li>空闲则使用</li>
</ol>
</li>
<li><ol>
<li>不空闲,则等待 池中的单个线程空闲后 使用</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池的方法</span></span><br><span class="line">ExecutorService service = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>
<h3 id="8-8-4-周期性任务定长线程池"><a href="#8-8-4-周期性任务定长线程池" class="headerlink" title="8.8.4 周期性任务定长线程池"></a>8.8.4 周期性任务定长线程池</h3><p>执行流程:</p>
<ul>
<li><ol>
<li>判断线程池是否存在空闲线程</li>
</ol>
</li>
<li><ol>
<li>存在则使用</li>
</ol>
</li>
<li><ol>
<li>不存在空闲线程,且线程池未满的情况下,则创建线程 并放入线程池, 然后使用</li>
</ol>
</li>
<li><ol>
<li>不存在空闲线程,且线程池已满的情况下,则等待线程池存在空闲线程</li>
</ol>
</li>
</ul>
<p><strong>定时执行：</strong>当某个时机触发时, 自动执行某任务 </p>
<p>定时执行1次</p>
<ul>
<li>参数1. runnable类型的任务</li>
<li>参数2. 时长数字(即在这个时间后执行)</li>
<li>参数3. 时长数字的单位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">service.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"俩人相视一笑~ 嘿嘿嘿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">5</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p><strong>周期执行任务：</strong></p>
<ul>
<li>参数1. runnable类型的任务</li>
<li>参数2. 时长数字(第一次执行在多次时间以后)</li>
<li>参数3. 周期时长(每次执行的间隔时间)</li>
<li>参数4. 时长数字的单位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"俩人相视一笑~ 嘿嘿嘿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">5</span>,<span class="number">2</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h2 id="8-9-lambda表达式"><a href="#8-9-lambda表达式" class="headerlink" title="8.9 lambda表达式"></a>8.9 lambda表达式</h2><p>函数式编程思想：和面向对象是有些对立的思想</p>
<p>格式：</p>
<p><code>(参数) -&gt; {方法}</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冗余的线程实现写法：</span></span><br><span class="line">service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"俩人相视一笑~ 嘿嘿嘿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">5</span>,<span class="number">2</span>,TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//替换为lambda表达式</span></span><br><span class="line">service.scheduleAtFixedRate(() -&gt;&#123;System.out.println(<span class="string">"俩人相视一笑~ 嘿嘿嘿"</span>), <span class="number">5</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>案例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    print((<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;    <span class="comment">//将new 父类/接口()跟匿名内部类的方式用lambda的方式表现出来 </span></span><br><span class="line">        	<span class="keyword">return</span> a+b;</span><br><span class="line">    	&#125;, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">print</span><span class="params">(Sum s, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = s.sum(a,b);</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，lambda公式是在传递实参时，需要新建对象（继承自抽象父类或接口）且需要重写方法的场合！！</p>
<p>相对于匿名内部类的方式，lambda只需要考虑需要重写的方法（因为类名作为形参已经声明了），括号内为重写方法的参数，箭头后面是方法的内容！！</p>
<h1 id="9-网络编程"><a href="#9-网络编程" class="headerlink" title="9. 网络编程"></a>9. 网络编程</h1><h2 id="9-1-网络知识"><a href="#9-1-网络知识" class="headerlink" title="9.1 网络知识"></a>9.1 网络知识</h2><p><a href="https://biongd.gitee.io/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">https://biongd.gitee.io/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></p>
<h2 id="9-2-TCP程序"><a href="#9-2-TCP程序" class="headerlink" title="9.2 TCP程序"></a>9.2 TCP程序</h2><p>网络编程的分类：</p>
<ol>
<li>B/S 程序 : 浏览器与服务器程序</li>
<li>C/S 程序 : 客户端与服务器程序</li>
</ol>
<h3 id="9-2-3-C-S程序"><a href="#9-2-3-C-S程序" class="headerlink" title="9.2.3 C/S程序"></a>9.2.3 C/S程序</h3><p><strong>需要使用到两个类：</strong></p>
<ol>
<li>ServerSocket 搭建服务器</li>
<li>Socket 搭建客户端</li>
<li>两方使用socket(套接字 , 通信端点) 进行交流</li>
</ol>
<p><strong>服务器端：ServerSocket类</strong></p>
<p>用于创建服务器 . 创建完毕后, 会绑定一个端口号。然后此服务器可以等待客户端连接 。每连接一个客户端 , 服务器就会得到一个新的Socket对象,，用于跟客户端进行通信 。</p>
<ul>
<li>构造方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket(<span class="keyword">int</span> port); </span><br><span class="line"><span class="comment">//创建一个基于TCP/IP协议的服务器 , 并绑定指定的端口号.</span></span><br></pre></td></tr></table></figure>
<p>注意: 参数port的范围是: 0-65535 (建议1025-65535)</p>
<ul>
<li>常用方法：</li>
</ul>
<p><code>Socket accept()</code>：等待客户端连接 ，此方法会导致线程的阻塞！直到一个新的客户端连接成功， return Socket对象后, 线程才能继续执行。<br><code>void close()</code>：释放占用的端口号 , 关闭服务器.</p>
<p><strong>客户端：Socket</strong></p>
<p>是两台计算机之间通信的端点 , 是网络驱动提供给应用程序编程的一种接口，一套标准，一种机制 </p>
<ul>
<li>构造方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Socket(String ip,<span class="keyword">int</span> port)</span><br><span class="line"> <span class="comment">//创建一个套接字, 并连接指定ip和端口号的 服务器.</span></span><br><span class="line"><span class="comment">//参数1. 服务器的ip地址</span></span><br><span class="line"><span class="comment">//参数2. 服务器软件的端口号..</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常用方法：</li>
</ul>
<p><code>OutputStream getOutputStream()</code>：返回的是 , 指向通信的另一端点的输出流</p>
<p><code>InputStream getInputStream()</code>：返回的是 , 指向通信的另一端点的输入流</p>
<p><code>void close()</code>：关闭套接字<br><strong>总结：</strong></p>
<p>服务器就像是客栈，是必须有明确的地址和大门的实体！客户端就像是来吃饭住宿，只要知道地址和大门就行了，无需实例化</p>
<h1 id="10-IDEA"><a href="#10-IDEA" class="headerlink" title="10. IDEA"></a>10. IDEA</h1><h2 id="10-1-debug"><a href="#10-1-debug" class="headerlink" title="10.1 debug"></a>10.1 debug</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">debugTestTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)&#123;</span><br><span class="line"><span class="comment">//在这一行设置断点  ++s;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>设置条件：</p>
<p>红点右键：比如condition设置为<code>s == 5</code>，表示满足<code>s==5</code>这一条件时才会触发断点</p>
</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210321223354.png" alt="image-20210321223354497" style="zoom:67%;" /></p>
<ul>
<li><p>左侧红圈：</p>
<ul>
<li>第一个：再次执行到断点处</li>
<li>第二个：暂停</li>
<li>第三个：查看所有已添加的断点信息</li>
<li>第四个：屏蔽所有断点</li>
</ul>
</li>
<li><p>上面红圈：</p>
<ul>
<li><p>将光标移动到当前运行到的代码位置</p>
</li>
<li><p>单步跳过</p>
</li>
<li>进入自定义方法</li>
<li>进入所有方法（包括自定义的和系统的）</li>
<li>退出本层方法</li>
<li>退出全部方法至最顶层</li>
<li>程序直接执行到光标处</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="10-2-junit（单元检测）"><a href="#10-2-junit（单元检测）" class="headerlink" title="10.2 junit（单元检测）"></a>10.2 junit（单元检测）</h2><blockquote>
<p> 问：jar文件是干嘛的？</p>
<p>jar包就是别人已经写好的一些类，然后将这些类进行打包，你可以将这些jar包引入你的项目中，然后就可以直接使用这些jar包中的类和属性以及方法。</p>
<p>JAR（Java ARchive）是将一系列文件合并到单个压缩文件里，就象Zip那样。然而，同Java中其他任何东西一样，JAR文件是跨平台的，所以不必关心涉及具体平台的问题。<br>涉及因特网应用时，JAR文件显得特别有用。在JAR文件之前，Web浏览器必须重复多次请求Web服务器，以便下载完构成一个“程序片”（Applet）的所有文件。除此以外，每个文件都是未经压缩的。但在将所有这些文件合并到一个JAR文件里以后，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，所以可在更短的时间里获得全部数据</p>
</blockquote>
<p>通过将jar文件导入项目，即可以通过快捷键直接生成单元的测试文件<code>ctrl+shift+t</code></p>
<blockquote>
<p>导入方法见文件：java-IDEA</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"haha"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heihei</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"heihei"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成测试文件，写入验证方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="keyword">new</span> Demo().sum(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">200</span>,sum);<span class="comment">//断言</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo().haha();<span class="comment">//测试</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heihei</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo().heihei();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"出异常了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haHei</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo().haha();</span><br><span class="line">        <span class="keyword">new</span> Demo().heihei();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>断言方法的使用效果</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210321160610.png" alt="Annotation 2020-08-13 132754.png" style="zoom:67%;" /></p>
<h1 id="11-XML和JSON"><a href="#11-XML和JSON" class="headerlink" title="11. XML和JSON"></a>11. XML和JSON</h1><h2 id="11-1-XML概念"><a href="#11-1-XML概念" class="headerlink" title="11.1 XML概念"></a>11.1 XML概念</h2><h3 id="11-1-1-XML简介"><a href="#11-1-1-XML简介" class="headerlink" title="11.1.1 XML简介"></a>11.1.1 XML简介</h3><p>可扩展标记语言（eXtensible Markup Language）。</p>
<ul>
<li>特性:</li>
</ul>
<ol>
<li>xml具有平台无关性, 是一门独立的标记语言.</li>
<li>xml具有自我描述性</li>
</ol>
<ul>
<li>XML的作用：</li>
</ul>
<ol>
<li>网络数据传输（socket）</li>
<li>数据存储（由专门的存储工具）</li>
<li>配置文件（只有这个方法是最常用的）</li>
</ol>
<ul>
<li>XML文件</li>
</ul>
<ol>
<li>.XML文件是保存XML数据的一种方式</li>
<li>XML数据也可以以其他的方式存在（如在内存中构建XML数据）。</li>
<li>不要将XML语言狭隘的理解成XML文件。</li>
</ol>
<h3 id="11-1-2-XML语法"><a href="#11-1-2-XML语法" class="headerlink" title="11.1.2 XML语法"></a>11.1.2 XML语法</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">1. XML文档声明</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line">2. 标记 (也被叫做：元素 / 标签 / 节点)</span><br><span class="line">XML文档,由一个个的标记组成.</span><br><span class="line">语法:</span><br><span class="line">开始标记(开放标记): <span class="tag">&lt;<span class="name">标记名称</span>&gt;</span></span><br><span class="line">结束标记(闭合标记): <span class="tag">&lt;/<span class="name">标记名称</span>&gt;</span></span><br><span class="line">标记名称: 自定义名称，必须遵循以下命名规则：</span><br><span class="line">    1.名称可以含字母、数字以及其他的字符</span><br><span class="line">    2.名称不能以数字或者标点符号开始</span><br><span class="line">    3.名称不能以字符 “xml”（或者 XML、Xml）开始</span><br><span class="line">    4.名称不能包含空格，不能包含冒号（:）</span><br><span class="line">    5.名称区分大小写</span><br><span class="line">标记内容: 开始标记与结束标记之间 ,是标记的内容.</span><br><span class="line">例如 ,我们通过标记, 描述一个人名:</span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>李伟杰<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3. 一个XML文档中, 必须有且且仅允许有一个根标记.</span><br><span class="line">正例:</span><br><span class="line">    <span class="tag">&lt;<span class="name">names</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line">反例:</span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>麻子<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">4. 标记可以嵌套, 但是不允许交叉.</span><br><span class="line">正例:</span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">反例:</span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;<span class="name">age</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"></span><br><span class="line">5. 标记的层级称呼 (子标记, 父标记 , 兄弟标记, 后代标记 ,祖先标记)</span><br><span class="line">例如:</span><br><span class="line">    <span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">length</span>&gt;</span>180cm<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">length</span>&gt;</span>200cm<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br><span class="line">name是person的子标记.也是person的后代标记</span><br><span class="line">name是persons的后代标记.</span><br><span class="line">案例:</span><br><span class="line">语法进阶CDATA （了解）</span><br><span class="line">name是length的兄弟标记.</span><br><span class="line">person是name的父标记.</span><br><span class="line">persons是name的祖先标记.</span><br><span class="line">6. 标记名称 允许重复</span><br><span class="line">7. 标记除了开始和结束 , 还有属性.</span><br><span class="line">标记中的属性, 在标记开始时 描述, 由属性名和属性值 组成.</span><br><span class="line">格式:</span><br><span class="line">在开始标记中, 描述属性.</span><br><span class="line">可以包含0-n个属性, 每一个属性是一个键值对!</span><br><span class="line">属性名不允许重复 , 键与值之间使用等号连接, 多个属性之间使用空格分割.</span><br><span class="line">属性值 必须被引号引住.</span><br><span class="line">案例:</span><br><span class="line">    <span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"10001"</span> <span class="attr">groupid</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"10002"</span> <span class="attr">groupid</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br><span class="line">8. 注释</span><br><span class="line">注释不能写在文档文档声明前</span><br><span class="line">注释不能嵌套注释</span><br><span class="line">格式:</span><br><span class="line">注释开始: <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">注释结束: --&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>语法进阶CDATA</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CDATA</span><br><span class="line">	CDATA 是不应该由 XML 解析器解析的文本数据。</span><br><span class="line">    像 "<span class="tag">&lt;<span class="name">"</span> 和 "&amp;" 字符在 <span class="attr">XML</span> 元素中都是非法的。</span></span><br><span class="line">    "&lt;" 会产生错误，因为解析器会把该字符解释为新元素的开始。</span><br><span class="line">    "&amp;" 会产生错误，因为解析器会把该字符解释为字符实体的开始。</span><br><span class="line">    Java解析XML 掌握</span><br><span class="line">    面试题 *</span><br><span class="line">    某些文本，比如 JavaScript 代码，包含大量 "<span class="tag">&lt;<span class="name">"</span> 或 "&amp;" 字符。为了避免错误，可以将脚本代</span></span><br><span class="line"><span class="tag">码定义为 <span class="attr">CDATA</span>。</span></span><br><span class="line"><span class="tag">    <span class="attr">CDATA</span> 部分中的所有内容都会被解析器忽略。</span></span><br><span class="line">    CDATA 部分由 "&lt;![CDATA[" 开始，由 "]]&gt;" 结束：</span><br></pre></td></tr></table></figure>
<h2 id="11-2-Java解析XML"><a href="#11-2-Java解析XML" class="headerlink" title="11.2 Java解析XML"></a>11.2 Java解析XML</h2><h3 id="11-2-1-Java中有几种XML解析方式"><a href="#11-2-1-Java中有几种XML解析方式" class="headerlink" title="11.2.1 Java中有几种XML解析方式"></a>11.2.1 Java中有几种XML解析方式</h3><ul>
<li><p><strong>SAX解析</strong></p>
<p>解析方式是事件驱动机制 ! </p>
<p>SAX解析器, 逐行读取XML文件解析 , 每当解析到一个标签的开始/结束/内容/属性时,触 发事件. 我们可以编写程序在这些事件发生时, 进行相应的处理. </p>
<p>优点:</p>
<ul>
<li>分析能够立即开始，而不是等待所有的数据被处理 </li>
</ul>
</li>
</ul>
<ul>
<li>逐行加载,节省内存.有助于解析大于系统内存的文档 </li>
</ul>
<ul>
<li>有时不必解析整个文档,它可以在某个条件得到满足时停止解析. </li>
</ul>
<p>  缺点:</p>
<ul>
<li>单向解析，无法定位文档层次，无法同时访问同一文档的不同部分数据(因为逐 行解析, 当解析第n行是, 第n-1行已经被释放了, 无法在进行操作了). </li>
</ul>
<ul>
<li>无法得知事件发生时元素的层次, 只能自己维护节点的父/子关系. </li>
</ul>
<ul>
<li>只读解析方式, 无法修改XML文档的内容. </li>
</ul>
<ul>
<li><p><strong>DOM解析</strong></p>
<p>是用与平台和语言无关的方式表示XML文档的官方W3C标准，分析该结构通常需要加载整个 文档和内存中建立文档树模型.程序员可以通过操作文档树, 来完成数据的获取 修改 删除等. </p>
<p>优点:</p>
<ul>
<li><p>文档在内存中加载, 允许对数据和结构做出更改. </p>
</li>
<li><p>访问是双向的，可以在任何时候在树中双向解析数据。 </p>
</li>
</ul>
<p>缺点:</p>
<ul>
<li>文档全部加载在内存中 , 消耗资源大. </li>
</ul>
</li>
<li><p><strong>JDOM解析</strong></p>
<p>目的是成为Java特定文档模型，它简化与XML的交互并且比使用DOM实现更快。由于是第一 个Java特定模型，JDOM一直得到大力推广和促进。 </p>
</li>
<li><p>JDOM文档声明其目的是“使用20%（或更少）的精力解决80%（或更多）Java/XML问题” （根据学习曲线假定为20%） </p>
<p>优点:</p>
<ul>
<li><p>使用具体类而不是接口，简化了DOM的API。 </p>
</li>
<li><p>大量使用了Java集合类，方便了Java开发人员。 </p>
</li>
</ul>
<p>缺点:</p>
<ul>
<li>没有较好的灵活性。 </li>
</ul>
</li>
</ul>
<ul>
<li>性能不是那么优异。 </li>
</ul>
<ul>
<li><p><strong>DOM4J解析</strong> </p>
<p>它是JDOM的一种智能分支。它合并了许多超出基本XML文档表示的功能，包括集成的XPath 支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项， DOM4J是一个非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一 个开放源代码的软件。如今你可以看到越来越多的Java软件都在使用DOM4J来读XML。 目前许多开源项目中大量采用DOM4J , 例如:Hibernate </p>
</li>
</ul>
<h3 id="11-2-2-DOM4J解析XML掌握"><a href="#11-2-2-DOM4J解析XML掌握" class="headerlink" title="11.2.2 DOM4J解析XML掌握"></a>11.2.2 DOM4J解析XML掌握</h3><ul>
<li>步骤：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 引入jar文件 dom4j.jar </span><br><span class="line"><span class="number">2</span>. 创建一个指向XML文件的输入流 </span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"xml文件的地址"</span>); </span><br><span class="line"><span class="number">3</span>. 创建一个XML读取工具对象 </span><br><span class="line">    SAXReader sr = <span class="keyword">new</span> SAXReader(); </span><br><span class="line"><span class="number">4</span>. 使用读取工具对象, 读取XML文档的输入流 , 并得到文档对象 </span><br><span class="line">    Document doc = sr.read(fis); </span><br><span class="line"><span class="number">5</span>. 通过文档对象, 获取XML文档中的根元素对象 </span><br><span class="line">    Element root = doc.getRootElement();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>文档对象</strong> <strong>Document</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指的是加载到内存的 整个XML文档. 常用方法: </span><br><span class="line"><span class="number">1</span>. 通过文档对象, 获取XML文档中的根元素对象 </span><br><span class="line">    Element root = doc.getRootElement(); </span><br><span class="line"><span class="number">2</span>. 添加根节点 </span><br><span class="line">    Element root = doc.addElement(<span class="string">"根节点名称"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>元素对象</strong> <strong>Element</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">指的是XML文档中的单个节点. 常用方法: </span><br><span class="line"><span class="number">1</span>. 获取节点名称 <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line"><span class="number">2</span>. 获取节点内容 <span class="function">String <span class="title">getText</span><span class="params">()</span></span>; </span><br><span class="line"><span class="number">3</span>. 设置节点内容 <span class="function">String <span class="title">setText</span><span class="params">()</span></span>; </span><br><span class="line"><span class="number">4</span>. 根据子节点的名称 , 获取匹配名称的第一个子节点对象. <span class="function">Element <span class="title">element</span><span class="params">(String 子节点名称)</span></span>; </span><br><span class="line"><span class="number">5</span>. 获取所有的子节点对象 <span class="function">List&lt;Element&gt; <span class="title">elements</span><span class="params">()</span></span>; </span><br><span class="line"><span class="number">6</span>. 获取节点的属性值 <span class="function">String <span class="title">attributeValue</span><span class="params">(String 属性名称)</span></span>; </span><br><span class="line"><span class="number">7</span>. 获取子节点的内容 <span class="function">String <span class="title">elementText</span><span class="params">(String 子节点名称)</span></span>; </span><br><span class="line"><span class="number">8</span>. 添加子节点 <span class="function">Element <span class="title">addElement</span><span class="params">(String 子节点名称)</span></span>;</span><br><span class="line"><span class="number">9</span>. 添加属性<span class="function"><span class="keyword">void</span> <span class="title">addAttribute</span><span class="params">(String 属性名,String 属性值)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>解析本地文件案例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 获取文件的输入流 </span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\code\\35\\code1\\day03_XML\\src\\books.xml"</span>); </span><br><span class="line"><span class="comment">//2. 创建XML读取工具对象 </span></span><br><span class="line">SAXReader sr = <span class="keyword">new</span> SAXReader(); </span><br><span class="line"><span class="comment">//3. 通过读取工具, 读取XML文档的输入流 , 并得到文档对象 </span></span><br><span class="line">Document doc = sr.read(fis); </span><br><span class="line"><span class="comment">//4. 通过文档对象 , 获取文档的根节点对象 </span></span><br><span class="line">Element root = doc.getRootElement(); </span><br><span class="line"><span class="comment">//5. 通过根节点, 获取所有子节点 </span></span><br><span class="line">List&lt;Element&gt; es = root.elements(); </span><br><span class="line"><span class="comment">//6. 循环遍历三个</span></span><br><span class="line"><span class="function">book <span class="title">for</span> <span class="params">(Element e : es)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//1. 获取id属性值 </span></span><br><span class="line">    tring id = e.attributeValue(<span class="string">"id"</span>); </span><br><span class="line">    <span class="comment">//2. 获取子节点name , 并获取它的内容 </span></span><br><span class="line">    String name = e.element(<span class="string">"name"</span>).getText(); </span><br><span class="line">    <span class="comment">//3. 获取子节点info , 并获取它的内容 </span></span><br><span class="line">    String info = e.element(<span class="string">"info"</span>).getText(); </span><br><span class="line">    System.out.println(<span class="string">"id="</span>+id+<span class="string">",name="</span>+name+<span class="string">",info="</span>+info); &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>解析网络文件案例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String phone = <span class="string">"18516955565"</span>; </span><br><span class="line"><span class="comment">//1. 获取到XML资源的输入流 URL </span></span><br><span class="line">url = <span class="keyword">new</span> URL(<span class="string">"http://apis.juhe.cn/mobile/get? phone="</span>+phone+<span class="string">"&amp;dtype=xml&amp;key=9f3923e8f87f1ea50ed4ec8c39cc9253"</span>); </span><br><span class="line">URLConnection conn = url.openConnection(); InputStream is = conn.getInputStream(); </span><br><span class="line"><span class="comment">//2. 创建一个XML读取对象 </span></span><br><span class="line">SAXReader sr = <span class="keyword">new</span> SAXReader(); </span><br><span class="line"><span class="comment">//3. 通过读取对象 读取XML数据，并返回文档对象 </span></span><br><span class="line">Document doc = sr.read(is); </span><br><span class="line"><span class="comment">//4. 获取根节点 </span></span><br><span class="line">Element root = doc.getRootElement(); </span><br><span class="line"><span class="comment">//5. 解析内容 </span></span><br><span class="line">String code = root.elementText(<span class="string">"resultcode"</span>); </span><br><span class="line"><span class="keyword">if</span>(<span class="string">"200"</span>.equals(code))&#123; Element result = root.element(<span class="string">"result"</span>); </span><br><span class="line">   String province = result.elementText(<span class="string">"province"</span>); </span><br><span class="line">   String city = result.elementText(<span class="string">"city"</span>); </span><br><span class="line">   <span class="keyword">if</span>(province.equals(city))&#123; </span><br><span class="line">       System.out.println(<span class="string">"手机号码归属地为："</span>+city); </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"手机号码归属地为："</span>+province+<span class="string">" "</span>+city); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"请输入正确的手机号码"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：无论怎样都得先获取根节点，然后才能一级一级的获取元素的名称或内容等属性</p>
<h3 id="11-2-3-DOM4J-XPATH解析XML"><a href="#11-2-3-DOM4J-XPATH解析XML" class="headerlink" title="11.2.3 DOM4J - XPATH解析XML"></a>11.2.3 <strong>DOM4J - XPATH</strong>解析XML</h3><p>不需要一级一级的向下遍历，通过路径进行获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">通过路径快速的查找一个或一组元素 路径表达式: </span><br><span class="line"><span class="number">1</span>. / : 从根节点开始查找 </span><br><span class="line"><span class="number">2</span>. <span class="comment">// : 从发起查找的节点位置 查找后代节点 *** </span></span><br><span class="line"><span class="number">3</span>. . : 查找当前节点 </span><br><span class="line"><span class="number">4</span>. .. : 查找父节点 </span><br><span class="line"><span class="number">5</span>. @ : 选择属性. * 属性使用方式: [@属性名=<span class="string">'值'</span>] [@属性名&gt;<span class="string">'值'</span>] [@属性名&lt;<span class="string">'值'</span>] [@属性名!=<span class="string">'值'</span>] </span><br><span class="line">例如</span><br><span class="line">books: 路径： <span class="comment">//book[@id='1']//name </span></span><br><span class="line">    books</span><br><span class="line">    	book id=<span class="number">1</span> </span><br><span class="line">    		name </span><br><span class="line">    		info </span><br><span class="line">    	book id=<span class="number">2</span> </span><br><span class="line">    		name </span><br><span class="line">    		info</span><br></pre></td></tr></table></figure>
<ul>
<li>本地解析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, DocumentException </span>&#123;</span><br><span class="line">        <span class="comment">//1.    获取输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c://Demo1.xml"</span>);</span><br><span class="line">        <span class="comment">//2.    创建XML读取对象</span></span><br><span class="line">        SAXReader sr = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="comment">//3.    读取并得到文档对象</span></span><br><span class="line">        Document doc = sr.read(fis);</span><br><span class="line">        <span class="comment">//4.    通过文档对象+xpath，查找所有的name节点</span></span><br><span class="line">        <span class="comment">/*List&lt;Node&gt; names = doc.selectNodes("//book[@id='1001']//name");//Node:文档对象和元素对象都是他的子</span></span><br><span class="line"><span class="comment">        for (int i=0;i&lt;names.size();i++)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(names.get(i).getName());</span></span><br><span class="line"><span class="comment">            System.out.println(names.get(i).getText());</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        Node n = doc.selectSingleNode(<span class="string">"//book[@id='1002']//name"</span>);</span><br><span class="line">        System.out.println(n.getName()+<span class="string">":"</span>+n.getText());</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>网络解析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">String phone = <span class="string">"18516955565"</span>; </span><br><span class="line"><span class="comment">//1. 获取到XML资源的输入流 </span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://apis.juhe.cn/mobile/get?phone="</span>+phone+<span class="string">"&amp;dtype=xml&amp;key=9f3923e8f87f1ea50ed4ec8c39cc9253"</span>); </span><br><span class="line">URLConnection conn = url.openConnection(); </span><br><span class="line">InputStream is = conn.getInputStream();</span><br><span class="line"><span class="comment">//2. 创建一个XML读取对象 </span></span><br><span class="line">SAXReader sr = <span class="keyword">new</span> SAXReader(); </span><br><span class="line"><span class="comment">//3. 通过读取对象 读取XML数据，并返回文档对象 </span></span><br><span class="line">Document doc = sr.read(is); </span><br><span class="line"><span class="comment">//4. 获取根节点 </span></span><br><span class="line">Element root = doc.getRootElement(); </span><br><span class="line"><span class="comment">//5. 解析内容 </span></span><br><span class="line">String code = root.elementText(<span class="string">"resultcode"</span>); </span><br><span class="line"><span class="keyword">if</span>(<span class="string">"200"</span>.equals(code))&#123; </span><br><span class="line">    Element result = root.element(<span class="string">"result"</span>); </span><br><span class="line">    String province = result.elementText(<span class="string">"province"</span>); </span><br><span class="line">    String city = result.elementText(<span class="string">"city"</span>); </span><br><span class="line">    <span class="keyword">if</span>(province.equals(city))&#123; </span><br><span class="line">        System.out.println(<span class="string">"手机号码归属地为："</span>+city); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;System.out.println(<span class="string">"手机号码归属地为："</span>+province+<span class="string">" "</span>+city); </span><br><span class="line">         &#125; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"请输入正确的手机号码"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-3-XML生成"><a href="#11-3-XML生成" class="headerlink" title="11.3 XML生成"></a>11.3 XML生成</h2><p>步骤:</p>
<ol>
<li>通过文档帮助器 (DocumentHelper) , 创建空的文档对象<br><code>Document doc = DocumentHelper.createDocument();</code></li>
<li>通过文档对象, 向其中添加根节点<br><code>Element root = doc.addElement(&quot;根节点名称&quot;);</code></li>
<li>通过根节点对象root , 丰富我们的子节点<br><code>Element e = root.addElement(&quot;元素名称&quot;);</code></li>
<li>创建一个文件输出流 ,用于存储XML文件<br><code>FileOutputStream fos = new FileOutputStream(&quot;要存储的位置&quot;);</code></li>
<li>将文件输出流, 转换为XML文档输出流<br><code>XMLWriter xw = new XMLWriter(fos);</code></li>
<li>写出文档<br><code>xw.write(doc);</code></li>
<li>释放资源<br><code>xw.close();</code></li>
</ol>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 通过文档帮助器, 创建空的文档对象</span></span><br><span class="line">Document doc = DocumentHelper.createDocument();</span><br><span class="line"><span class="comment">//2. 向文档对象中, 加入根节点对象</span></span><br><span class="line">Element books = doc.addElement(<span class="string">"books"</span>);</span><br><span class="line"><span class="comment">//3. 向根节点中 丰富子节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) &#123;</span><br><span class="line"><span class="comment">//向根节点中加入1000个book节点.</span></span><br><span class="line">Element book = books.addElement(<span class="string">"book"</span>);</span><br><span class="line"><span class="comment">//向book节点, 加入id属性</span></span><br><span class="line">book.addAttribute(<span class="string">"id"</span>, <span class="number">1</span>+i+<span class="string">""</span>);</span><br><span class="line"><span class="comment">//向book节点中加入name和info节点</span></span><br><span class="line">Element name = book.addElement(<span class="string">"name"</span>);</span><br><span class="line">Element info = book.addElement(<span class="string">"info"</span>);</span><br><span class="line">name.setText(<span class="string">"苹果"</span>+i);</span><br><span class="line">info.setText(<span class="string">"哈哈哈"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4. 创建文件的输出流</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\books.xml"</span>);</span><br><span class="line"><span class="comment">//5. 将文件输出流 , 转换为XML文档输出流</span></span><br><span class="line">XMLWriter xw = <span class="keyword">new</span> XMLWriter(fos);</span><br><span class="line"><span class="comment">//6. 写出XML文档</span></span><br><span class="line">xw.write(doc);</span><br><span class="line"><span class="comment">//7. 释放资源</span></span><br><span class="line">xw.close();</span><br><span class="line">System.out.println(<span class="string">"代码执行完毕"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="11-4-XStream-对象-gt-字符串"><a href="#11-4-XStream-对象-gt-字符串" class="headerlink" title="11.4 XStream(对象-&gt;字符串)"></a>11.4 XStream(对象-&gt;字符串)</h2><p>快速的将Java中的对象, 转换为 XML字符串</p>
<p>使用步骤:</p>
<ol>
<li>创建XStream 对象<br><code>XStream x = new XStream();</code></li>
<li>修改类生成的节点名称 (默认节点名称为 包名.类名)<br> <code>x.alias(&quot;节点名称&quot;,类名.class);</code></li>
<li>传入对象 , 生成XML字符串<br> <code>String xml字符串 = x.toXML(对象);</code></li>
</ol>
<p>案例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">"张三"</span>, <span class="string">"不详"</span>);</span><br><span class="line">XStream x = <span class="keyword">new</span> XStream();</span><br><span class="line">x.alias(<span class="string">"haha"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">String xml = x.toXML(p);</span><br><span class="line">System.out.println(xml);</span><br></pre></td></tr></table></figure>
<h2 id="11-5-JSON"><a href="#11-5-JSON" class="headerlink" title="11.5 JSON"></a>11.5 JSON</h2><p>概念：<code>JavaScript Object Notation</code> JS对象简谱 , 是一种轻量级的数据交换格式.</p>
<h3 id="11-5-1-JSON格式"><a href="#11-5-1-JSON格式" class="headerlink" title="11.5.1 JSON格式"></a>11.5.1 JSON格式</h3><blockquote>
<p>回想xml的对象格式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String info;</span><br><span class="line">        get/set...</span><br><span class="line">    &#125;</span><br><span class="line">    Book b = <span class="keyword">new</span> Book();</span><br><span class="line">    b.setName(“金苹果”);</span><br><span class="line">    b.setInfo(“种苹果”);</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//js:</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">new</span> Object();</span><br><span class="line">    b.name = <span class="string">"金苹果"</span>;</span><br><span class="line">    b.info = <span class="string">"种苹果"</span>;</span><br><span class="line"><span class="comment">//XML:</span></span><br><span class="line">    &lt;book&gt;</span><br><span class="line">        &lt;name&gt;金苹果&lt;/name&gt;</span><br><span class="line">        &lt;info&gt;种苹果&lt;/info&gt;</span><br><span class="line">    &lt;/book&gt;</span><br><span class="line">JSON:</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"金苹果"</span>,</span><br><span class="line">    <span class="string">"info"</span>:<span class="string">"种苹果"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>格式:</strong></p>
<ul>
<li>键与值之间使用冒号连接, 多个键值对之间使用逗号分隔.</li>
<li>键值对的键 应使用引号引住 (通常Java解析时, 键不使用引号会报错. 而JS能正确解析.)</li>
<li>键值对的值, 可以是JS中的任意类型的数据</li>
</ul>
<p><strong>数组格式：</strong></p>
<ul>
<li>在JSON格式中可以与对象互相嵌套<br>[JSON元素1,  JSON元素2…]</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"伟杰老师"</span>,</span><br><span class="line">    <span class="attr">"age"</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">"pengyou"</span>:[<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王二"</span>,<span class="string">"麻子"</span>,&#123;</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"野马老师"</span>,</span><br><span class="line">        <span class="attr">"info"</span>:<span class="string">"像匹野马一样狂奔在技术钻研的道路上"</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="attr">"heihei"</span>:&#123;</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"大长刀"</span>,</span><br><span class="line">        <span class="attr">"length"</span>:<span class="string">"40m"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-6-JSON解析"><a href="#11-6-JSON解析" class="headerlink" title="11.6 JSON解析"></a>11.6 JSON解析</h2><blockquote>
<p>两个问题：</p>
<p>将Java中的对象 快速的转换为 JSON格式的字符串；将JSON格式的字符串, 转换为Java的对象。</p>
</blockquote>
<h3 id="11-6-1-Gson"><a href="#11-6-1-Gson" class="headerlink" title="11.6.1 Gson"></a>11.6.1 Gson</h3><ul>
<li><p>将对象转换为JSON字符串</p>
<ol>
<li>引入JAR包</li>
<li>在需要转换JSON字符串的位置编写如下代码即可:<br><code>String json = new Gson().toJSON(要转换的对象);</code></li>
</ol>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book b = BookDao.find();</span><br><span class="line">String json = <span class="keyword">new</span> Gson().toJson(b);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将JSON字符串转换为对象</p>
<ol>
<li>引入JAR包</li>
<li>在需要转换Java对象的位置, 编写如下代码:<br><code>对象 = new Gson().fromJson(JSON字符串,对象类型.class);</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="string">"&#123;\"id\":1,\"name\":\"金苹果\",\"author\":\"李伟杰</span></span><br><span class="line"><span class="string">\",\"info\":\"嘿嘿嘿嘿嘿嘿\",\"price\":198.0&#125;"</span>;</span><br><span class="line">Book book = <span class="keyword">new</span> Gson().fromJson(json, Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(book);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>传入的json字符串的格式！！！大括号和转义字符</p>
</li>
</ul>
<h3 id="11-6-2-FastJson"><a href="#11-6-2-FastJson" class="headerlink" title="11.6.2 FastJson"></a>11.6.2 FastJson</h3><ul>
<li><p>将对象转换为JSON字符串</p>
<ol>
<li>引入JAR包</li>
<li>在需要转换JSON字符串的位置编写如下代码即可:<br><code>String json=JSON.toJSONString(要转换的对象);</code></li>
</ol>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book b = BookDao.find();</span><br><span class="line">String json = <span class="keyword">new</span> Gson().toJson(b);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将JSON字符串转换为对象</p>
<ol>
<li>引入JAR包</li>
<li>在需要转换Java对象的位置, 编写如下代码:<br><code>类型 对象名=JSON.parseObject(JSON字符串, 类型.class);</code><br>或<br><code>List&lt;类型&gt; list=JSON.parseArray(JSON字符串,类型.class);</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="string">"&#123;\"id\":1,\"name\":\"金苹果\",\"author\":\"李伟杰</span></span><br><span class="line"><span class="string">\",\"info\":\"嘿嘿嘿嘿嘿嘿\",\"price\":198.0&#125;"</span>;</span><br><span class="line">Book book = <span class="keyword">new</span> Gson().fromJson(json, Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(book);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>传入的json字符串的格式！！！大括号和转义字符</p>
</li>
</ul>
<h1 id="12-枚举、注解-、反射"><a href="#12-枚举、注解-、反射" class="headerlink" title="12. 枚举、注解 、反射"></a>12. 枚举、注解 、反射</h1><h2 id="12-1-枚举"><a href="#12-1-枚举" class="headerlink" title="12.1 枚举"></a>12.1 枚举</h2><h3 id="12-1-1-概念和格式"><a href="#12-1-1-概念和格式" class="headerlink" title="12.1.1 概念和格式"></a>12.1.1 概念和格式</h3><ul>
<li><p>枚举的作用：</p>
<p>JDK1.5引入了新的类型——枚举。在JDK1.5 之前，我们定义常量都是： public static fianl…. 。很难管理。</p>
<p>枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。<strong>用于定义有限数量的一组同类常量</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">错误级别：</span><br><span class="line">低、中、高、急</span><br><span class="line">一年的四季：</span><br><span class="line">春、夏、秋、冬</span><br><span class="line">商品的类型：</span><br><span class="line">美妆、手机、电脑、男装、女装...</span><br></pre></td></tr></table></figure>
<p>在枚举类型中定义的<font color="red"><strong>常量是该枚举类型的实例</strong>。</font></p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 <span class="keyword">enum</span> 枚举名称 &#123;</span><br><span class="line">    实例<span class="number">1</span>,实例<span class="number">2</span>，实例<span class="number">3</span>，实例<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level &#123;</span><br><span class="line">    LOW(<span class="number">30</span>), MEDIUM(<span class="number">15</span>), HIGH(<span class="number">7</span>), URGENT(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> levelValue;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Level</span><span class="params">(<span class="keyword">int</span> levelValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.levelValue = levelValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevelValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> levelValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="12-1-2-常见方法"><a href="#12-1-2-常见方法" class="headerlink" title="12.1.2 常见方法"></a>12.1.2 常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span> <span class="comment">//将此枚举与指定的订单对象进行比较。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> <span class="comment">//如果指定的对象等于此枚举常量，则返回true。     </span></span></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="comment">//返回此枚举常量的名称，与其枚举声明中声明的完全相同 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> <span class="comment">//返回此枚举常量的序数（它在枚举声明中的位置，其中初始常量的序数为零）。  </span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> <span class="comment">//返回声明中包含的此枚举常量的名称。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt;T <span class="title">valueOf</span><span class="params">(类&lt;T&gt; enumType, String name)</span> <span class="comment">//返回具有指定名称的指定枚举类型的枚举常量。</span></span></span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Level.LOW.compareTo(Level.HIGH));</span><br><span class="line">        System.out.println(Level.LOW.compareTo(Level.MEDIUM));</span><br><span class="line">        System.out.println(Level.HIGH.compareTo(Level.LOW));</span><br><span class="line">        System.out.println(Level.HIGH.name());</span><br><span class="line">        System.out.println(Level.HIGH.toString());</span><br><span class="line">        System.out.println(Level.HIGH.ordinal());</span><br><span class="line">        System.out.println(Level.LOW.ordinal());</span><br><span class="line">        Level x = Enum.valueOf(Level.class, "HIGH");</span><br><span class="line">        System.out.println(x.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">2</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">HIGH</span><br><span class="line">HIGH</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">HIGH</span><br></pre></td></tr></table></figure>
<h3 id="12-1-3-枚举接口"><a href="#12-1-3-枚举接口" class="headerlink" title="12.1.3 枚举接口"></a>12.1.3 枚举接口</h3><p>所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。</p>
<p>每个枚举对象，都可以实现自己的抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lshow</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.所有枚举对象实现相同方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level implements Lshow&#123;</span><br><span class="line">    LOW,MEDIUM,HIGH;</span><br><span class="line">    <span class="comment">//给所有枚举对象统一添加的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"级别对象调用的show方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.给每个枚举对象的继承的方法可以实现不同功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level implements Lshow&#123;</span><br><span class="line">    LOW&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"低"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,MEDIUM&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"中"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,HIGH&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"高"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2方法中每个枚举类型的实例对象其实都是在通过内部类的方式进行实例化，上面因为是调用的无参构造方法将括号省略，在调用有参构造方法时括号又可以加上。</p>
<h3 id="12-1-4-注意事项"><a href="#12-1-4-注意事项" class="headerlink" title="12.1.4 注意事项"></a>12.1.4 注意事项</h3><ul>
<li>一旦定义了枚举，最好不要妄图修改里面的值，除非修改是必要的。</li>
<li>枚举类默认继承的是java.lang.Enum类而不是Object类</li>
<li>枚举类不能有子类，因为其枚举类默认被final修饰</li>
<li>只能有private构造方法</li>
<li>switch中使用枚举时，直接使用常量名，不用携带类名、</li>
<li>不能定义name属性，因为自带name属性</li>
<li>不要为枚举类中的属性提供set方法，不符合枚举最初设计初衷。</li>
</ul>
<h2 id="12-2-注解-框架学习"><a href="#12-2-注解-框架学习" class="headerlink" title="12.2 注解-框架学习"></a>12.2 注解-框架学习</h2><p>框架中常用！</p>
<h3 id="12-2-1-注解的简介和学习步骤"><a href="#12-2-1-注解的简介和学习步骤" class="headerlink" title="12.2.1 注解的简介和学习步骤"></a>12.2.1 注解的简介和学习步骤</h3><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。注释是给人看的，但注解是给机器看的，即可以把注释嵌入到代码执行流程中的机制。</p>
<p>Java 语言中的<strong>类、方法、变量、参数和包等都可以被标注</strong>。和注释不同，Java 标注可以通过反射获取标注内容。在编译器生成类文时，</p>
<p>标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p>
<p>主要用于：</p>
<ul>
<li>编译格式检查</li>
<li>反射中解析</li>
<li>生成帮助文档</li>
<li>跟踪代码依赖</li>
</ul>
<p>学习步骤：</p>
<ul>
<li>概念</li>
<li>怎么使用内置注解</li>
<li>怎么自定义注解</li>
<li>反射中怎么获取注解内容</li>
</ul>
<h3 id="12-2-2-内置注解"><a href="#12-2-2-内置注解" class="headerlink" title="12.2.2 内置注解"></a>12.2.2 内置注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line">Java <span class="number">7</span> 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>：标识某注解可以在同一个声明上使用多次</span><br><span class="line">Java <span class="number">8</span> 开始支持，标识某注解可以在同一个声明上使用多次。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>:  <span class="comment">//重写 *</span></span><br><span class="line">定义在java.lang.Override</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span>:  <span class="comment">//废弃 *</span></span><br><span class="line">定义在java.lang.Deprecated</span><br><span class="line">(为什么不删掉：后续发现问题但考虑到对之前版本的兼容性，一般不会修改代码，而是扩展代码)</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span>： <span class="comment">//函数式接口 *</span></span><br><span class="line">Java <span class="number">8</span> 开始支持，标识一个匿名函数或函数式接口。</span><br><span class="line"></span><br><span class="line">SuppressWarnings：抑制编译时的警告信息。 *</span><br><span class="line">定义在java.lang.SuppressWarnings</span><br><span class="line">三种使用方式：</span><br><span class="line"><span class="number">1</span>. <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) [^ 抑制单类型的警告]</span><br><span class="line"><span class="number">2</span>. <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>,<span class="string">"rawtypes"</span>) [^ 抑制多类型的警告]</span><br><span class="line"><span class="number">3</span>. <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>) [^ 抑制所有类型的警告]</span><br></pre></td></tr></table></figure>
<p>抑制编译警告SuppressWarnings的注解的参数：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">all：抑制所有警告</span><br><span class="line">boxing：抑制装箱、拆箱操作时候的警告</span><br><span class="line">cast：抑制映射相关的警告</span><br><span class="line">dep-ann：抑制启用注释的警告</span><br><span class="line">deprecation：抑制过期方法警告</span><br><span class="line">fallthrough：抑制确在<span class="keyword">switch</span>中缺失breaks的警告</span><br><span class="line"><span class="keyword">finally</span>：抑制<span class="keyword">finally</span>模块没有返回的警告</span><br><span class="line">hiding：抑制相对于隐藏变量的局部变量的警告</span><br><span class="line">incomplete-<span class="keyword">switch</span>：忽略没有完整的<span class="keyword">switch</span>语句</span><br><span class="line">nls：忽略非nls格式的字符</span><br><span class="line"><span class="literal">null</span>：忽略对<span class="literal">null</span>的操作</span><br><span class="line">rawtypes：使用generics时忽略没有指定相应的类型</span><br><span class="line">restriction：抑制禁止使用劝阻或禁止引用的警告</span><br><span class="line">serial：忽略在serializable类中没有声明serialVersionUID变量</span><br><span class="line"><span class="keyword">static</span>-access：抑制不正确的静态访问方式警告</span><br><span class="line">synthetic-access：抑制子类没有按最优方法访问内部类的警告</span><br><span class="line"><span class="keyword">unchecked</span>：抑制没有进行类型检查操作的警告</span><br><span class="line">unqualified-field-access：抑制没有权限访问的域的警告</span><br><span class="line">unused：抑制没被使用过的代码的警告</span><br></pre></td></tr></table></figure>
<h3 id="12-2-3-元注解"><a href="#12-2-3-元注解" class="headerlink" title="12.2.3 元注解"></a>12.2.3 元注解</h3><p>作用：给其他注解加注解（对定义的注解进行配置）</p>
<ul>
<li><p>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问</p>
</li>
<li><p>@Documented - 标记这些注解是否包含在用户文档中 javadoc。</p>
</li>
<li><p>@Target - 标记这个注解应该是哪种 Java 成员。</p>
</li>
<li><p>@Inherited - 标记这个注解是自动继承的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 子类会继承父类使用的注解中被<span class="meta">@Inherited</span>修饰的注解</span><br><span class="line"><span class="number">2</span>. 接口继承关系中，子接口不会继承父接口中的任何注解，不管父接口中使用的注解有没有</span><br><span class="line">被<span class="meta">@Inherited</span>修饰</span><br><span class="line"><span class="number">3</span>. 类实现接口时不会继承任何接口中定义的注解</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="12-2-4-自定义注解（实现Annotation接口）"><a href="#12-2-4-自定义注解（实现Annotation接口）" class="headerlink" title="12.2.4 自定义注解（实现Annotation接口）"></a>12.2.4 自定义注解（实现Annotation接口）</h3><p><img src="https://gitee.com/biongd/img/raw/master/img/20210325221450.png" alt="image-20210325221443535" style="zoom:67%;" /></p>
<ul>
<li><p>Annotation与RetentionPolicy 与ElementType 。每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n个</p>
</li>
<li><p>ElementType(注解的用途类型)<br>“每 1 个 Annotation” 都与 “1～n 个 ElementType” 关联。当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个 Annotation 对象是 METHOD 类型，则该Annotation 只能用来修饰方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    TYPE, <span class="comment">/* 类、接口（包括注释类型）或枚举声明 */</span></span><br><span class="line">    FIELD, <span class="comment">/* 字段声明（包括枚举常量） */</span></span><br><span class="line">    METHOD, <span class="comment">/* 方法声明 */</span></span><br><span class="line">    PARAMETER, <span class="comment">/* 参数声明 */</span></span><br><span class="line">    CONSTRUCTOR, <span class="comment">/* 构造方法声明 */</span></span><br><span class="line">    LOCAL_VARIABLE, <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">    ANNOTATION_TYPE, <span class="comment">/* 注释类型声明 */</span></span><br><span class="line">    PACKAGE <span class="comment">/* 包声明 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RetentionPolicy（注解作用域策略）。</p>
<p>“每 1 个 Annotation” 都与 “1 个 RetentionPolicy” 关联。</p>
<ul>
<li><p>若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</p>
</li>
<li><p>若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认为。</p>
</li>
<li><p>若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    SOURCE, <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该</span></span><br><span class="line"><span class="comment">    Annotation信息了 */</span></span><br><span class="line">    CLASS, <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为 */</span></span><br><span class="line">    RUNTIME <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> 自定义注解名&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的作用是定义一个 Annotation，我们可以在代码中通过 “@MyAnnotation1” 来使用它。@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。含义：</p>
<ul>
<li><p>@interface<br>使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。定义 Annotation 时，@interface 是必须的。<br>注意：它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。</p>
</li>
<li><p>@Documented<br>类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该Annotation，则表示它可以出现在 javadoc 中。</p>
<p>定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc</p>
</li>
<li><p>@Target(ElementType.TYPE)</p>
<p>前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定Annotation 的类型属性。</p>
<p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p>
<p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；<strong>若没有 @Target，则该 Annotation 可以用于任何地方。</strong></p>
</li>
<li><p>@Retention(RetentionPolicy.RUNTIME)<br>前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定Annotation 的策略属性。<br>例如@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。<br>定义 Annotation 时，@Retention 可有可无。<strong>若没有 @Retention，则默认是RetentionPolicy.CLASS</strong></p>
</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ol>
<li>定义的注解，自动继承了java.lang,annotation.Annotation接口</li>
<li>注解中的每一个方法，实际是声明的注解配置参数<br>方法的名称就是 配置参数的名称<br>方法的返回值类型，就是配置参数的类型。只能是：基本类型/Class/String/enum</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数成员，一般参数名为value</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串、0作为默认值。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>元注解和自定义注解相辅相成，元注解可以对自定义注解加以修饰，修饰的方法就是给元注解传入一些枚举常量</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(value = <span class="string">"张三"</span>, num = <span class="number">122</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//用途类型</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="comment">//可以继承</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">//保存策略</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="comment">//本质上也是抽象方法</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "xiaoming"</span>;<span class="comment">//不加default则调用注解时相当于创建注解对象，必须传入参数，加入默认值即可以不用传值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-3-反射-优化代码"><a href="#12-3-反射-优化代码" class="headerlink" title="12.3 反射-优化代码"></a>12.3 反射-优化代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA反射机制是在运行状态中，获取任意一个类的结构 , 创建对象 , 得到方法，执行方法 , 属性 !；</span><br><span class="line">这种在运行状态动态获取信息以及动态调用对象方法的功能被称为java语言的反射机制</span><br></pre></td></tr></table></figure>
<h3 id="12-3-1-类加载器"><a href="#12-3-1-类加载器" class="headerlink" title="12.3.1 类加载器"></a>12.3.1 类加载器</h3><p>Java类加载器（Java Classloader）是Java运行时环境（Java Runtime Environment）的一部分，负责动态加载Java类到Java虚拟机的内存空间中。</p>
<p>java默认有三种类加载器，BootstrapClassLoader、ExtensionClassLoader、AppClassLoader。</p>
<ol>
<li><p>BootstrapClassLoader（引导启动类加载器）：</p>
<p>嵌在JVM内核中的加载器，该加载器是用C++语言写的，主要负载加载JAVA_HOME/lib下的类库，引导启动类加载器无法被应用程序直接使用。</p>
</li>
<li><p>ExtensionClassLoader（扩展类加载器）：<br>ExtensionClassLoader是用JAVA编写，且它的父类加载器是Bootstrap。是由sun.misc.Launcher$ExtClassLoader实现的，主要加载JAVA_HOME/lib/ext目录中的类库。它的父加载器是BootstrapClassLoader</p>
</li>
<li>App ClassLoader（应用类加载器）：<br>App ClassLoader是应用程序类加载器，负责加载应用程序classpath目录下的所有jar和class文件。它的父加载器为Ext ClassLoader</li>
</ol>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210326101228.png" alt="image-20210326101221084"></p>
<blockquote>
<p>多个类加载器如何避免类的重复加载？</p>
</blockquote>
<p>类通常是按需加载，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件与文件系统。学习类加载器时，掌握Java的委派概念很重要。</p>
<p><strong>双亲委派模型：</strong>如果一个类加载器收到了一个类加载请求，它不会自己去尝试加载这个类，而是把这个请求转交给父类加载器去完成。每一个层次的类加载器都是如此。因此所有的类加载请求都应该传递到最顶层的启动类加载器中，只有到父类加载器反馈自己无法完成这个加载请求（在它的搜索范围没有找到这个类）时，子类加载器才会尝试自己去加载。委派的好处就是避免有些类被重复加载。</p>
<h3 id="12-3-2-加载配置文件"><a href="#12-3-2-加载配置文件" class="headerlink" title="12.3.2 加载配置文件"></a>12.3.2 加载配置文件</h3><p><strong>类加载器的使用案例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//通过字节码文件获取类加载器</span></span><br><span class="line">        ClassLoader cl = Demo3<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        <span class="comment">//打印结果：jdk.internal.loader.ClassLoaders$AppClassLoader@1f89ab83</span></span><br><span class="line">        System.out.println(cl);</span><br><span class="line">        <span class="comment">//config.txt文件必须在src路径下才能获取，否则报空指针异常</span></span><br><span class="line">        InputStream is = cl.getResourceAsStream(<span class="string">"config.txt"</span>);</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        String s = bf.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>给项目添加resource root目录</strong>：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210326103308.png" alt="image-20210326103308012" style="zoom: 67%;" /></p>
<p><strong>注意：</strong>通过类加载器加载资源文件默认加载的是src路径下的文件，但是当项目存在resource root目录时，就变为了加载resource root下的文件了</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210326103439.png" alt="image-20210326103439658" style="zoom:50%;" /></p>
<h3 id="12-3-3-Class和加载方式"><a href="#12-3-3-Class和加载方式" class="headerlink" title="12.3.3 Class和加载方式"></a>12.3.3 Class和加载方式</h3><h4 id="所有类型的Class对象"><a href="#所有类型的Class对象" class="headerlink" title="所有类型的Class对象"></a>所有类型的Class对象</h4><p>要想了解一个类,必须先要获取到该类的字节码文件对象。在Java中，每一个字节码文件，被加载到内存后，都存在一个对应的Class类型的对象。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210326104315.png" alt="image-20210326104315107"></p>
<p>类编译成的class文件，在加载到内存中以后，同样是作为一个对象存在，同样有方法获取类的实例化对象</p>
<p>图中的<code>Class&lt;T&gt;</code>就表示类  类型。</p>
<h4 id="得到Class对象的几种方式"><a href="#得到Class对象的几种方式" class="headerlink" title="得到Class对象的几种方式"></a>得到Class对象的几种方式</h4><ul>
<li><p><code>包名.类名.class</code>得到一个类的 类对象</p>
<p>前提：如果在编写代码时, 知道类的名称, 且类已经存在</p>
</li>
<li><p><code>(Class&lt;T&gt;)Class.forName(包名+类名)</code></p>
<p>次方法可以用于类尚不存在，可以将类名作为参数传入</p>
</li>
<li><p><code>(Class&lt;T&gt;)对象.getClass()</code></p>
<p>前提：如果拥有类的对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.包名.类名.class</span></span><br><span class="line">        Class&lt;Person&gt; p1 = com.java.demo4.Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//2.Class 对象.getClass()</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Class&lt;Person&gt; p2 = (Class&lt;Person&gt;) p.getClass();</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//3.Class.forName(包名+类名)</span></span><br><span class="line">        Class&lt;Person&gt; p3 = (Class&lt;Person&gt;) Class.forName(<span class="string">"com.java.demo4.Person"</span>);</span><br><span class="line">        System.out.println(p3);</span><br><span class="line">        System.out.println(p1 == p2);</span><br><span class="line">        System.out.println(p2 == p3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">java</span>.<span class="title">demo4</span>.<span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">com</span>.<span class="title">java</span>.<span class="title">demo4</span>.<span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">com</span>.<span class="title">java</span>.<span class="title">demo4</span>.<span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">true</span></span></span><br><span class="line"><span class="class"><span class="title">true</span></span></span><br></pre></td></tr></table></figure>
<p><strong>上述的三种方式, 在调用时, 如果类在内存中不存在, 则会加载到内存 ! 如果类已经在内存中存在, 不会重复加载, 而是重复利用</strong> </p>
<p>特殊的类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型的类对象:</span><br><span class="line">    基本数据类型.clss</span><br><span class="line">    包装类.type</span><br><span class="line">基本数据类型包装类对象:</span><br><span class="line">    包装类<span class="class">.<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>
<h3 id="12-3-4-反射中的构造方法"><a href="#12-3-4-反射中的构造方法" class="headerlink" title="12.3.4 反射中的构造方法"></a>12.3.4 反射中的构造方法</h3><p>问题在于，如何从类对象中提取构造方法，如何利用构造方法创建一个对象。</p>
<h4 id="提取构造方法"><a href="#提取构造方法" class="headerlink" title="提取构造方法"></a>提取构造方法</h4><ul>
<li>通过指定的参数类型, 获取指定的单个构造方法：<code>getConstructor(参数类型的class对象数组)</code></li>
<li><p>获取构造方法数组：<code>getConstructors()</code></p>
</li>
<li><p>获取所有权限的单个构造方法：<code>getDeclaredConstructor(参数类型的class对象数组)</code></p>
</li>
<li>获取所有权限的构造方法数组：<code>getDeclaredConstructors()</code></li>
</ul>
<p>这里的所有权限指除了public以外的权限</p>
<h4 id="创建一个对象"><a href="#创建一个对象" class="headerlink" title="创建一个对象"></a>创建一个对象</h4><p>常用方法：<code>newInstance(Object... para)</code><br>调用这个构造方法, 把对应的对象创建出来<br>参数: 是一个Object类型可变参数, 传递的参数顺序 必须匹配构造方法中形式参数列表的顺序!</p>
<blockquote>
<p>如何越过私有构造方法的限制</p>
</blockquote>
<p><code>setAccessible(boolean flag)</code><br>如果flag为true 则表示忽略访问权限检查 !(可以访问任何权限的方法</p>
<p><strong>实际案例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//1.反射获取无参构造方法</span></span><br><span class="line">        Class&lt;Person&gt; pClass = (Class&lt;Person&gt;) Class.forName(<span class="string">"com.java.demo4.Person"</span>);</span><br><span class="line">        <span class="comment">//找到无参构造方法</span></span><br><span class="line">        Constructor&lt;Person&gt; c1 = pClass.getConstructor();</span><br><span class="line">        <span class="comment">//通过无参构造方法创建对象</span></span><br><span class="line">        Person p = c1.newInstance();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//2.反射获取有参构造方法，传递的参数类型是Class对象数组</span></span><br><span class="line">        Constructor&lt;Person&gt; c2 = pClass.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Person p1= c2.newInstance(<span class="string">"张三"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//3.反射获取私有权限的构造方法</span></span><br><span class="line">        Constructor&lt;Person&gt; c3 = pClass.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//设置忽略权限检查</span></span><br><span class="line">        c3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Person p2= c3.newInstance(<span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Person&#123;name=<span class="string">'null'</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">'张三'</span>, age=<span class="number">20</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">'张三'</span>, age=<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-3-5-反射获取方法"><a href="#12-3-5-反射获取方法" class="headerlink" title="12.3.5 反射获取方法"></a>12.3.5 反射获取方法</h3><p><strong>通过Class对象获取</strong>，与Constructor的获取方法类似，执行方法需要先 通过反射构造出实例变量</p>
<ol>
<li><code>getMethod(String methodName , class.. clss)</code><br>根据参数列表的类型和方法名, 得到一个方法(public修饰的)</li>
<li><code>getMethods()</code><br>得到一个类的所有方法 (public修饰的)</li>
<li><code>getDeclaredMethod(String methodName , class.. clss)</code><br>根据参数列表的类型和方法名, 得到一个方法(除继承以外所有的:包含私有, 共有, 保护, 默认)</li>
<li><code>getDeclaredMethods()</code><br>得到一个类的所有方法 (除继承以外所有的:包含私有, 共有, 保护, 默认)</li>
</ol>
<p><strong>执行获取到的方法：</strong></p>
<ul>
<li><p><code>invoke（Object o,Object... para）</code></p>
<p>执行o中的这个方法，传入相应参数</p>
</li>
<li><p><code>getName()</code></p>
<p>获取方法的方法名称</p>
</li>
<li><p><code>setAccessible(boolean flag)</code></p>
<p>如果flag为true 则表示忽略访问权限检查 !(可以访问任何权限的方法)</p>
</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">"com.java.demo4.Person"</span>);</span><br><span class="line">        Constructor ct = c1.getConstructor();</span><br><span class="line">        Object o = ct.newInstance();</span><br><span class="line">        Method setName = c1.getMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//参数1. 要调用方法的对象</span></span><br><span class="line">        <span class="comment">//参数2. 要传递的参数列表</span></span><br><span class="line">        setName.invoke(o, <span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h3 id="12-3-6-反射获取属性"><a href="#12-3-6-反射获取属性" class="headerlink" title="12.3.6 反射获取属性"></a>12.3.6 反射获取属性</h3><p><strong>通过Class对象获取</strong>，与Constructor、Method的获取方法类似，执行方法需要先通过反射构造出实例变量</p>
<ol>
<li><code>getDeclaredField(String filedName)</code><br>根据属性的名称, 获取一个属性对象 (所有属性)</li>
<li><code>getDeclaredFields()</code><br>获取所有属性</li>
<li><code>getField(String filedName)</code><br>根据属性的名称, 获取一个属性对象 (public属性)</li>
<li><code>getFields()</code><br>获取所有属性 (public)</li>
</ol>
<p><strong>获取或设置对象中属性</strong></p>
<ol>
<li><p><code>get(Object o)</code><br> 参数: 要获取属性的对象</p>
</li>
<li><p><code>set(Object o , Object value)</code></p>
<p>参数1. 要设置属性值的 对象<br>参数2. 要设置的值</p>
</li>
<li><p>getName()<br>获取属性的名称</p>
</li>
<li><p>setAccessible(boolean flag)<br>如果flag为true 则表示忽略访问权限检查 !(可以访问任何权限的属性)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class c = Class.forName(<span class="string">"com.java.demo4.Person"</span>);</span><br><span class="line">    Constructor ct = c.getConstructor();</span><br><span class="line">    Object o = ct.newInstance();</span><br><span class="line">    Field phoneNum = c.getField(<span class="string">"phoneNumber"</span>);</span><br><span class="line">    phoneNum.set(o,<span class="number">123456</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-3-7-反射获取注解"><a href="#12-3-7-反射获取注解" class="headerlink" title="12.3.7 反射获取注解"></a>12.3.7 反射获取注解</h3><blockquote>
<p>回一下注解部分的内容：自定义和添加注解？</p>
</blockquote>
<ul>
<li>自定义注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建class，选择Annotation类型，对新建的Annotation进行修饰</span></span><br><span class="line"><span class="comment">//MyAnnotationTable修饰类</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnontationTable &#123;</span><br><span class="line">    <span class="comment">//用于标注类对应的表格名称</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ColumnAnnotation用于修饰属性</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ColumnAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">columName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类声明前添加类的注解，在成员属性前添加属性注解</span></span><br><span class="line"><span class="meta">@MyAnnontationTable</span>(<span class="string">"person_test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ColumnAnnotation</span>(columName = <span class="string">"name"</span>,type = <span class="string">"String"</span>,length = <span class="string">"10"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ColumnAnnotation</span>(columName = <span class="string">"age"</span>,type = <span class="string">"String"</span>,length = <span class="string">"11"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@ColumnAnnotation</span>(columName = <span class="string">"phoneNumber"</span>,type = <span class="string">"String"</span>,length = <span class="string">"12"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> phoneNumber;</span><br></pre></td></tr></table></figure>
<p>可以看到注解中其实有我们想要的信息，向类注解中的信息可以作为数据库中的表头，属性注解中的内容可以作为数据库中的属性</p>
<p>接下来的问题就是如何通过反射获取注解</p>
<h4 id="反射获取注解"><a href="#反射获取注解" class="headerlink" title="反射获取注解"></a>反射获取注解</h4><p><strong>通过Class对象获取</strong>，与Constructor、Method、Field的获取方法类似，执行方法需要先通过反射构造出实例变量</p>
<ul>
<li><p>获取类的单个或全部注解</p>
<p><code>注解类型 对象名 = (注解类型) c.getAnnotation(注解类型.class)</code></p>
<p><code>注解类型 对象名 = (注解类型) c.getAnnotations(注解类型.class)</code></p>
</li>
<li><p>获取属性的注解</p>
<p>先通过反射获取属性对象，再通过属性对象调用上面的获取注解方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = Class.forName(<span class="string">"com.java.demo4.Person"</span>);</span><br><span class="line">        Annotation[] an = c.getAnnotations();</span><br><span class="line">        <span class="comment">//获取类的全部注解（此时只能获取一个类的注解）</span></span><br><span class="line">        <span class="keyword">for</span>(Annotation a: an)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取类的注解，因为只有一个，可以用注解类型.class获取</span></span><br><span class="line">        MyAnnontationTable mat = (MyAnnontationTable)c.getAnnotation(MyAnnontationTable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(mat);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取全部的属性注解</span></span><br><span class="line">        Field[] fs = c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f: fs)&#123;</span><br><span class="line">            ColumnAnnotation ca = (ColumnAnnotation)f.getAnnotation(ColumnAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(f.getName()+<span class="string">"\t"</span>+ca.columName()+<span class="string">"\t"</span>+ca.length()+<span class="string">"\t"</span>+ca.type());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br></pre></td></tr></table></figure>
<h3 id="12-4-内省"><a href="#12-4-内省" class="headerlink" title="12.4 内省"></a>12.4 内省</h3><h3 id="12-4-1-概念"><a href="#12-4-1-概念" class="headerlink" title="12.4.1 概念"></a>12.4.1 概念</h3><p>基于反射 , java所提供的一套应用到JavaBean的API</p>
<blockquote>
<p>什么是bean类？</p>
</blockquote>
<ul>
<li>一个定义在包中的类 ,</li>
<li>拥有无参构造器</li>
<li>所有属性私有,</li>
<li>所有属性提供get/set方法</li>
<li>实现了序列化接口</li>
</ul>
<h3 id="12-4-2-Introspector"><a href="#12-4-2-Introspector" class="headerlink" title="12.4.2 Introspector"></a>12.4.2 Introspector</h3><p>先说目的：获取所有属性的get和set方法</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210329145433.png" alt="image-20210329145426502"></p>
<p>其中<code>getPropertyDescription（）</code>方法获取的<code>PropertyDescription</code>类型的数组，其中的每个<code>PropertyDescription</code>对象都是一个属性的相关信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IntrospectionException </span>&#123;</span><br><span class="line">        Class c = Express<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        BeanInfo bi = Introspector.getBeanInfo(c);</span><br><span class="line">        <span class="comment">//获取get和set方法的对象</span></span><br><span class="line">        PropertyDescriptor[] pds = bi.getPropertyDescriptors();</span><br><span class="line">        <span class="comment">//将get和set方法从对象中抽离</span></span><br><span class="line">        <span class="keyword">for</span>(PropertyDescriptor pd: pds)&#123;</span><br><span class="line">            Method get = pd.getReadMethod();</span><br><span class="line">            Method set = pd.getWriteMethod();</span><br><span class="line">            System.out.println(get);</span><br><span class="line">            System.out.println(set);</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(pd.getPropertyType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="keyword">public</span> java.lang.String com.java.demo.Express.getAddress()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> com.java.demo.Express.setAddress(java.lang.String)</span><br><span class="line">address</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">native</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span>.<span class="title">getClass</span>()</span></span><br><span class="line"><span class="class"><span class="title">null</span></span></span><br><span class="line"><span class="class"><span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span> <span class="title">com</span>.<span class="title">java</span>.<span class="title">demo</span>.<span class="title">Express</span>.<span class="title">getName</span>()</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">com</span>.<span class="title">java</span>.<span class="title">demo</span>.<span class="title">Express</span>.<span class="title">setName</span>(<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>)</span></span><br><span class="line"><span class="class"><span class="title">name</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span> <span class="title">com</span>.<span class="title">java</span>.<span class="title">demo</span>.<span class="title">Express</span>.<span class="title">getNumber</span>()</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">com</span>.<span class="title">java</span>.<span class="title">demo</span>.<span class="title">Express</span>.<span class="title">setNumber</span>(<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>)</span></span><br><span class="line"><span class="class"><span class="title">number</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span> <span class="title">com</span>.<span class="title">java</span>.<span class="title">demo</span>.<span class="title">Express</span>.<span class="title">getPhoneNumber</span>()</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">com</span>.<span class="title">java</span>.<span class="title">demo</span>.<span class="title">Express</span>.<span class="title">setPhoneNumber</span>(<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>)</span></span><br><span class="line"><span class="class"><span class="title">phoneNumber</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 0</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>虽然这个工具不一定用的上，但是在开发的时候bean类的编写一定要规范！！！比如属性没有get和set方法，通过内省机制是获取不到的</li>
<li>对于boolean类型的变量<code>boolean flag</code>，在调用<code>getWriteMethod()</code>时，结果不是<code>getFlag()</code>，而是<code>isFlag()</code>。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/02/15/java-JVM/" rel="next" title="java-JVM">
                <i class="fa fa-chevron-left"></i> java-JVM
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/09/java-spring/" rel="prev" title="java-spring">
                java-spring <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="xujunjie'blog" />
            
              <p class="site-author-name" itemprop="name">xujunjie'blog</p>
              <p class="site-description motion-element" itemprop="description">使一个人有限的生命更加有效也即等于延长了人的生命</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-变量、操作符和语句"><span class="nav-text">1. 变量、操作符和语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-变量"><span class="nav-text">1.1 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-数据类型"><span class="nav-text">1.2 数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-数据类型转换"><span class="nav-text">1.3 数据类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-语句"><span class="nav-text">1.4 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-基本输入输出"><span class="nav-text">1.5 基本输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-Scanner-类实现键盘输入"><span class="nav-text">1.5.1 Scanner 类实现键盘输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-JOptionPane对话框输入"><span class="nav-text">1.5.2 JOptionPane对话框输入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-各类型数组的默认值"><span class="nav-text">1.6 各类型数组的默认值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-面向对象"><span class="nav-text">2. 面向对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-异常"><span class="nav-text">3. 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-异常体系结构"><span class="nav-text">3.1 异常体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-异常处理"><span class="nav-text">3.2 异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-finally的必然执行和常见题目"><span class="nav-text">3.2.1 finally的必然执行和常见题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-实际的处理流程："><span class="nav-text">3.2.2 实际的处理流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-多异常捕获"><span class="nav-text">3.2.3 多异常捕获</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-throws和throw"><span class="nav-text">3.3 throws和throw</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-throws"><span class="nav-text">3.3.1 throws</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-throw"><span class="nav-text">3.3.2 throw</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-自定义异常类-了解"><span class="nav-text">3.4 自定义异常类 了解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-泛型"><span class="nav-text">4. 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-泛型的使用"><span class="nav-text">4.1 泛型的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-泛型类"><span class="nav-text">4.1.1 泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-泛型接口"><span class="nav-text">4.1.2 泛型接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-泛型方法"><span class="nav-text">4.1.3 泛型方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-泛型限制类型"><span class="nav-text">4.2 泛型限制类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-泛型中的通配符-？"><span class="nav-text">4.3 泛型中的通配符 ？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-核心类库"><span class="nav-text">5. 核心类库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-java-util-Objects"><span class="nav-text">5.1 java.util.Objects</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-java-util-Date"><span class="nav-text">5.2 java.util.Date</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-java-text-SimpleDateFormat"><span class="nav-text">5.3 java.text.SimpleDateFormat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-java-util-Calendar"><span class="nav-text">5.4 java.util.Calendar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-java-util-Arrays"><span class="nav-text">5.5 java.util.Arrays</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-java-lang-Math"><span class="nav-text">5.6 java.lang.Math</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-java-math-BigDecimal"><span class="nav-text">5.7 java.math.BigDecimal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-java-lang-String"><span class="nav-text">5.8 java.lang.String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#共享的理解："><span class="nav-text">共享的理解：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串常量池"><span class="nav-text">字符串常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder和StringBuffer"><span class="nav-text">StringBuilder和StringBuffer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-java-lang-System"><span class="nav-text">5.9 java.lang.System</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-集合（java-util包）"><span class="nav-text">6. 集合（java.util包）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-集合的概念"><span class="nav-text">6.1 集合的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Collection接口"><span class="nav-text">6.2 Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection-常用功能"><span class="nav-text">Collection 常用功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-List接口"><span class="nav-text">6.3 List接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-1-List特点"><span class="nav-text">6.3.1 List特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-List重载的方法（基于索引）"><span class="nav-text">6.3.2 List重载的方法（基于索引）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-List子类"><span class="nav-text">6.4 List子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-ArrayList"><span class="nav-text">6.4.1 ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-LinkedList"><span class="nav-text">6.5.2 LinkedList</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-迭代器（Iterator和ListIterator）"><span class="nav-text">6.5 迭代器（Iterator和ListIterator）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-增强for（foreach）"><span class="nav-text">6.6 增强for（foreach）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-Set接口"><span class="nav-text">6.7 Set接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-1-HashSet"><span class="nav-text">6.7.1 HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-2-TreeSet"><span class="nav-text">6.7.2 TreeSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-Map接口"><span class="nav-text">6.8 Map接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-9哈希表理解"><span class="nav-text">6.9哈希表理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-1-散列因子（0-75）"><span class="nav-text">6.9.1 散列因子（0.75）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-2-初始容量（16）"><span class="nav-text">6.9.2 初始容量（16）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-10-HashMap"><span class="nav-text">6.10 HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-11-Map集合的子类区别分析"><span class="nav-text">6.11 Map集合的子类区别分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-11-1-HashMap，HashTable，ConcurrentHashMap"><span class="nav-text">6.11.1 HashMap，HashTable，ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-11-2-TreeMap"><span class="nav-text">6.11.2 TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-11-3-LinkedHashMap"><span class="nav-text">6.11.3 LinkedHashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-12-JDK9新特性"><span class="nav-text">6.12 JDK9新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-13-比较器（comparator和comparable）"><span class="nav-text">6.13 比较器（comparator和comparable）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-14-equals、hashCode-与内存泄露"><span class="nav-text">6.14 equals、hashCode 与内存泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-14-1-两个方法的约定"><span class="nav-text">6.14.1 两个方法的约定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-对象相等的判断"><span class="nav-text">6.4.2 对象相等的判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-内存泄漏"><span class="nav-text">6.4.3 内存泄漏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-流（java-io）"><span class="nav-text">7. 流（java.io）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-概念-p-277"><span class="nav-text">7.1 概念(p&#x2F;277)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-java-io-File"><span class="nav-text">7.2 java.io.File</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-流概述"><span class="nav-text">7.3 流概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-字节流（byte）"><span class="nav-text">7.4 字节流（byte）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字节流的常用子类"><span class="nav-text">字节流的常用子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1-FileOutputStream"><span class="nav-text">7.4.1 FileOutputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-2-FileInputStream"><span class="nav-text">7.4.2 FileInputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-3-字节输入流的乱码问题"><span class="nav-text">7.4.3 字节输入流的乱码问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-4-字节流总结"><span class="nav-text">7.4.4 字节流总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-字符流（char）"><span class="nav-text">7.5 字符流（char）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-1-字符输出流"><span class="nav-text">7.5.1 字符输出流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-2-字符输入流"><span class="nav-text">7.5.2 字符输入流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-flush刷新管道"><span class="nav-text">7.6 flush刷新管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-字节装饰为字符流"><span class="nav-text">7.7 字节装饰为字符流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-打印流及缓存流"><span class="nav-text">7.8 打印流及缓存流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-1打印流-写到硬盘"><span class="nav-text">7.8.1打印流(写到硬盘)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-2-标准IO"><span class="nav-text">7.8.2 标准IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-3-缓存流"><span class="nav-text">7.8.3 缓存流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-9-收集异常日志"><span class="nav-text">7.9 收集异常日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-10-Properties类"><span class="nav-text">7.10 Properties类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-11-序列化和反序列化"><span class="nav-text">7.11 序列化和反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-11-1-部分属性序列化"><span class="nav-text">7.11.1 部分属性序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-11-2-Externalizable接口"><span class="nav-text">7.11.2 Externalizable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-11-3-两个序列化接口的关系"><span class="nav-text">7.11.3 两个序列化接口的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-12-try-with-resources"><span class="nav-text">7.12 try-with-resources</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-13-相对路径"><span class="nav-text">7.13 相对路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-14-总结"><span class="nav-text">7.14 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#修改源文件中某一行的内容"><span class="nav-text">修改源文件中某一行的内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-多线程"><span class="nav-text">8. 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-线程和进程"><span class="nav-text">8.1 线程和进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-进程和线程的关系："><span class="nav-text">8.1.1 进程和线程的关系：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-线程调度"><span class="nav-text">8.1.2 线程调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-在java中实现多线程"><span class="nav-text">8.2 在java中实现多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-继承Thread类"><span class="nav-text">8.2.1 继承Thread类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-实现Runnable接口"><span class="nav-text">8.2.2 实现Runnable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3-实现Callable接口"><span class="nav-text">8.2.3 实现Callable接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-Thread类"><span class="nav-text">8.3 Thread类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-获取和设置线程名称"><span class="nav-text">8.3.1 获取和设置线程名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-线程状态及守护线程"><span class="nav-text">8.4 线程状态及守护线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-线程安全问题-锁"><span class="nav-text">8.5 线程安全问题-锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-1-方法1-同步代码块"><span class="nav-text">8.5.1 方法1-同步代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-2-方法2-同步方法"><span class="nav-text">8.5.2 方法2-同步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-3-方法3-显示锁"><span class="nav-text">8.5.3 方法3-显示锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-4-公平锁和非公平锁"><span class="nav-text">8.5.4 公平锁和非公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-5-线程死锁"><span class="nav-text">8.5.5 线程死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-多线程通信问题"><span class="nav-text">8.6 多线程通信问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-线程的状态"><span class="nav-text">8.7 线程的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-8-线程池Executors"><span class="nav-text">8.8 线程池Executors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-8-1-缓存线程池"><span class="nav-text">8.8.1 缓存线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-8-2-定长线程池"><span class="nav-text">8.8.2 定长线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-8-3-单线程"><span class="nav-text">8.8.3 单线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-8-4-周期性任务定长线程池"><span class="nav-text">8.8.4 周期性任务定长线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-9-lambda表达式"><span class="nav-text">8.9 lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-网络编程"><span class="nav-text">9. 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-网络知识"><span class="nav-text">9.1 网络知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-TCP程序"><span class="nav-text">9.2 TCP程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-3-C-S程序"><span class="nav-text">9.2.3 C&#x2F;S程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-IDEA"><span class="nav-text">10. IDEA</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-debug"><span class="nav-text">10.1 debug</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-junit（单元检测）"><span class="nav-text">10.2 junit（单元检测）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-XML和JSON"><span class="nav-text">11. XML和JSON</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-XML概念"><span class="nav-text">11.1 XML概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-1-XML简介"><span class="nav-text">11.1.1 XML简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-2-XML语法"><span class="nav-text">11.1.2 XML语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-Java解析XML"><span class="nav-text">11.2 Java解析XML</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-1-Java中有几种XML解析方式"><span class="nav-text">11.2.1 Java中有几种XML解析方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-2-DOM4J解析XML掌握"><span class="nav-text">11.2.2 DOM4J解析XML掌握</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-3-DOM4J-XPATH解析XML"><span class="nav-text">11.2.3 DOM4J - XPATH解析XML</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-XML生成"><span class="nav-text">11.3 XML生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-XStream-对象-gt-字符串"><span class="nav-text">11.4 XStream(对象-&gt;字符串)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-JSON"><span class="nav-text">11.5 JSON</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-5-1-JSON格式"><span class="nav-text">11.5.1 JSON格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-6-JSON解析"><span class="nav-text">11.6 JSON解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-6-1-Gson"><span class="nav-text">11.6.1 Gson</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-6-2-FastJson"><span class="nav-text">11.6.2 FastJson</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-枚举、注解-、反射"><span class="nav-text">12. 枚举、注解 、反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-枚举"><span class="nav-text">12.1 枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-1-概念和格式"><span class="nav-text">12.1.1 概念和格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-2-常见方法"><span class="nav-text">12.1.2 常见方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-3-枚举接口"><span class="nav-text">12.1.3 枚举接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-4-注意事项"><span class="nav-text">12.1.4 注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-注解-框架学习"><span class="nav-text">12.2 注解-框架学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-1-注解的简介和学习步骤"><span class="nav-text">12.2.1 注解的简介和学习步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-2-内置注解"><span class="nav-text">12.2.2 内置注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-3-元注解"><span class="nav-text">12.2.3 元注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-4-自定义注解（实现Annotation接口）"><span class="nav-text">12.2.4 自定义注解（实现Annotation接口）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#格式"><span class="nav-text">格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项"><span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例"><span class="nav-text">案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-反射-优化代码"><span class="nav-text">12.3 反射-优化代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-1-类加载器"><span class="nav-text">12.3.1 类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-2-加载配置文件"><span class="nav-text">12.3.2 加载配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-3-Class和加载方式"><span class="nav-text">12.3.3 Class和加载方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#所有类型的Class对象"><span class="nav-text">所有类型的Class对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#得到Class对象的几种方式"><span class="nav-text">得到Class对象的几种方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-4-反射中的构造方法"><span class="nav-text">12.3.4 反射中的构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#提取构造方法"><span class="nav-text">提取构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建一个对象"><span class="nav-text">创建一个对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-5-反射获取方法"><span class="nav-text">12.3.5 反射获取方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-6-反射获取属性"><span class="nav-text">12.3.6 反射获取属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-7-反射获取注解"><span class="nav-text">12.3.7 反射获取注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#反射获取注解"><span class="nav-text">反射获取注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-内省"><span class="nav-text">12.4 内省</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-1-概念"><span class="nav-text">12.4.1 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-2-Introspector"><span class="nav-text">12.4.2 Introspector</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xujunjie'blog</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>


  
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
