<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数字IC," />










<meta name="description" content="终于进入了systemverilog的学习，接续加油！！">
<meta property="og:type" content="article">
<meta property="og:title" content="SystemVerilog">
<meta property="og:url" content="http://yoursite.com/2020/03/23/IC%E9%AA%8C%E8%AF%81-SystemVerilog/index.html">
<meta property="og:site_name" content="悦来客栈">
<meta property="og:description" content="终于进入了systemverilog的学习，接续加油！！">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20201209211755.png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9seWMtcGljdHVyZS5vc3MtY24tc2hhbmdoYWkuYWxpeXVuY3MuY29tL3NjcmVlbnNob3QvMjAyMDA0MTgxMDIwMTMucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9seWMtcGljdHVyZS5vc3MtY24tc2hhbmdoYWkuYWxpeXVuY3MuY29tL3NjcmVlbnNob3QvMjAyMDA0MTgxMDM1MTQucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210811203705.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210802093251.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210802123013.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210802093801.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210802094007.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210802102512.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210802103404.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210802104050.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210802121605.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210709221729.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210707182439.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210707190458.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210707191159.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210707192755.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210707192916.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210707202150.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210708100727.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210708101837.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210708110231.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200502110846540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheV93aG8=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210708161421.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200425001501241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjAyMjQzNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200412130741553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjAyMjQzNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200412132631177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjAyMjQzNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190823204638126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsZWF1Y2hhdA==,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-03-23T06:25:30.000Z">
<meta property="article:modified_time" content="2021-09-01T02:43:08.925Z">
<meta property="article:author" content="xujunjie&#39;blog">
<meta property="article:tag" content="数字IC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/biongd/img/raw/master/img/20201209211755.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","display_updated":true,"offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/23/IC验证-SystemVerilog/"/>





  <title>SystemVerilog | 悦来客栈</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">悦来客栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">learn and better</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/23/IC%E9%AA%8C%E8%AF%81-SystemVerilog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xujunjie'blog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="悦来客栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SystemVerilog</h1>
        

        <div class="post-meta">
          <span class="post-time">
              
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-23T14:25:30+08:00">
                2020-03-23
              </time>
            
            
                <span class="post-updated">
                     &nbsp; | &nbsp; 更新于
                     <time itemprop="dateUpdated" datetime="2021-09-01T10:43:08+08:00" content="2021-09-01">
                          2021-09-01
                     </time>
                 </span>
             

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%97-%E9%AA%8C%E8%AF%81%E6%8B%94%E9%AB%98-SystemVerilog-verilog%E5%9F%BA%E7%A1%80-%E6%80%BB%E7%BA%BFVIP-%E9%A1%B9%E7%9B%AE-mcdf%E5%AE%9E%E9%AA%8C-UVM/" itemprop="url" rel="index">
                    <span itemprop="name">数字-验证拔高.SystemVerilog.verilog基础.总线VIP.项目.mcdf实验.UVM.</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>终于进入了systemverilog的学习，接续加油！！</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="语法-数据类型"><a href="#语法-数据类型" class="headerlink" title="语法-数据类型"></a>语法-数据类型</h2><p>SV中引入logic类型，和传统verilog中的reg和net的区别和联系：</p>
<ul>
<li>verilog作为描述语言，倾向于设计人员懂得寄存器和线网类型变量。利于后端综合工具</li>
<li>SV侧重验证的语言，对logic对应的硬件并不十分关切，只作为单纯的变量进行赋值操作，这些变量也属于软件环境构建。</li>
</ul>
<p><strong>注意：</strong></p>
<p><strong>logic不能有多个结构性的驱动，也就是logic类型只能有一个驱动，如果存在多个驱动，那么编译时就会出现错误。 ！！！</strong></p>
<p><strong>当然，有些信号你本来就希望它有多个驱动，例如双向总线，这些信号就需要被定义成线网类型，例如wire。</strong></p>
<p>logic相对应的是bit类型，他们均可以构建矢量类型（vector），而他们的区别在于</p>
<ul>
<li><p>logic为4值逻辑，即可以表示0，1，x，z</p>
</li>
<li><p>bit为2值逻辑，只有0,1</p>
</li>
</ul>
<p>为什么有了四值了，还搞个2值的？将硬件世界与软件世界分离</p>
<p><strong>按四值逻辑类型</strong>和<strong>二值逻辑类型</strong>划分：</p>
<ul>
<li>四值：integer、logic、reg、net-type（wire，wand。。。）</li>
<li>二值：byte、shortint、int、longint、bit</li>
</ul>
<p>按<strong>有符号</strong>和<strong>无符号</strong>划分：</p>
<ul>
<li>有符号类型：byte、shortint、int、longint、integer</li>
<li>无符号类型：bit、logic、reg、net-type（逻辑信号）</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20201209211755.png" alt="image-20201209211755421"></p>
<p>图中画圈部分，从有符号数到无符号数的转化，即为静态转化，在编译的时候完成检查</p>
<p>对应的动态转换$cast(tgt, src),和静态转化均为显式转化。对应上面的隐式转化</p>
<p>所以在不同数据类型进行操作时应注意变量的：</p>
<ul>
<li>逻辑数值类型</li>
<li>符号类型</li>
<li>矢量位宽</li>
</ul>
<h4 id="使用typedef创建新的类型"><a href="#使用typedef创建新的类型" class="headerlink" title="使用typedef创建新的类型"></a>使用typedef创建新的类型</h4><p>创建数据自己的数据类型，可以用来声明变量</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] uint; <span class="comment">// 32比特双状态无符号数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">unsigned</span> uint; <span class="comment">//等效的定义</span></span><br></pre></td></tr></table></figure>
<p>可以用来定义一个struct</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] id;</span><br><span class="line">  &#125; mon_data_t;</span><br></pre></td></tr></table></figure>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>静态转换：如整形和实数的转换</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inti; </span><br><span class="line"><span class="keyword">real</span> r; </span><br><span class="line">i=<span class="keyword">int</span>'(<span class="number">10</span><span class="variable">.0</span>-<span class="number">0</span><span class="variable">.1</span>);  ／／转换是非强制的</span><br><span class="line">r= <span class="keyword">real</span>'(<span class="number">42</span>);   ／／转换是非强制的</span><br></pre></td></tr></table></figure>
<p>动态转换: $cast</p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p><strong>定义常量的另 一种方法是使用参数。 但参数需要对每个数值进行单独的定义，而枚举类型却能够自动为列表中的每个名称分配不同的数值</strong></p>
<p>例如：<strong>enum {RED, BLUE, GREEN} color;</strong> </p>
<p>创建署名的枚举类型有利于声明更多新变量，尤其是当这些变量被用作子程序参数或模块端口时。 你需要首先创建枚举类型，然后再创建相应的变量。 使用内建的name(）函数，你可以得到枚举变量值对应的字符串</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">／／创建代表<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>的数据类型</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;INIT1 DECODE,IDLE&#125; fsmstate_e; </span><br><span class="line">f smstate </span><br><span class="line"><span class="number">_</span> e pstate, nstate;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">case</span>(pstate)</span><br><span class="line">        IDLE: nstate = INIT; </span><br><span class="line">        INIT: nstate=DECODE;</span><br><span class="line">        <span class="keyword">default</span>: nstate=IDLE; </span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">"Next state is 号s"</span>，</span><br><span class="line">    nstate<span class="variable">.name</span> ()); </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>还可以指定枚举值</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> ｛INIT, DECODE= <span class="number">2</span>, IDLE&#125; fsmtype <span class="number">_</span>e;</span><br></pre></td></tr></table></figure>
<p>注意：第一个值只能默认缺省或指定为0值</p>
<h4 id="枚举类型的方法"><a href="#枚举类型的方法" class="headerlink" title="枚举类型的方法"></a>枚举类型的方法</h4><p><strong>(1)</strong> first（）返回第一个枚举常量。</p>
<p>(2) last（）返回最后一个枚举常量。</p>
<p>(3) next(）返回下一个枚举常量。</p>
<p><strong>(4)</strong> next (N)返回以后第N个枚举常量。</p>
<p>(5) prev(）返回前一个枚举变量。</p>
<p><strong>(6)</strong> prev (N)返回以前第N个枚举变量。</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p><a href="https://blog.csdn.net/weixin_46022434/article/details/106311870" target="_blank" rel="noopener">verilog、SystemVerilog的所有操作符</a></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定宽数组"><a href="#定宽数组" class="headerlink" title="定宽数组"></a>定宽数组</h3><p>声明：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ascend[<span class="number">4</span>];</span><br><span class="line">ascend = '&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> array[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">array = '&#123;'&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,'&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h4><p>例如：</p>
<p><strong>bit[2:0] [7:0] array5;</strong></p>
<p>在存储时是连续的：此时内存占用为1个word（32位操作系统）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9seWMtcGljdHVyZS5vc3MtY24tc2hhbmdoYWkuYWxpeXVuY3MuY29tL3NjcmVlbnNob3QvMjAyMDA0MTgxMDIwMTMucG5n?x-oss-process=image/format,png" alt="img"></p>
<h4 id="非合并数组"><a href="#非合并数组" class="headerlink" title="非合并数组"></a>非合并数组</h4><p>eg：</p>
<p><strong>bit[7:0] array4[2:0]</strong> <strong>或</strong> <strong>bit[7:0] array4[3]</strong></p>
<p>在存储时是非连续地址：此时内存占用为4个word</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9seWMtcGljdHVyZS5vc3MtY24tc2hhbmdoYWkuYWxpeXVuY3MuY29tL3NjcmVlbnNob3QvMjAyMDA0MTgxMDM1MTQucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>注：合并数组和非合并数组可以混用，例如：可以理解为连续的一维数组4*8bit进行了二维扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bit[3:0] [7:0] barray[3]; &#x2F;&#x2F;合并：3x32比特</span><br></pre></td></tr></table></figure>
<h4 id="常量数组"><a href="#常量数组" class="headerlink" title="常量数组"></a>常量数组</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ascend [ <span class="number">4</span>] ='&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ;  <span class="comment">//对4个元素进行初始化</span></span><br><span class="line">in descend [<span class="number">5</span>];       </span><br><span class="line">descend='&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;  <span class="comment">//为5个元素赋值</span></span><br><span class="line">descend [<span class="number">0</span>: <span class="number">2</span>] ='&#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;  <span class="comment">//为前3个元素赋值</span></span><br><span class="line">ascend ='&#123; <span class="number">4</span> &#123; <span class="number">8</span>&#125; &#125; ;      <span class="comment">//四个值全部为8</span></span><br><span class="line">descend='&#123; <span class="number">9</span>, <span class="number">8</span>, <span class="keyword">default</span>: <span class="number">1</span>&#125;;   <span class="comment">// 默认补全&#123;9,8,1,1,1&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="数组遍历（for、foreach）"><a href="#数组遍历（for、foreach）" class="headerlink" title="数组遍历（for、foreach）"></a>数组遍历（for、foreach）</h3><p>注意多维数组中foreach的使用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> md[<span class="number">2</span>][<span class="number">3</span>] ='&#123;'&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,'&#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"Initial value:"</span>); </span><br><span class="line">    <span class="keyword">foreach</span> (md[i, j]） <span class="comment">//这是正确的语法格式</span></span><br><span class="line">	<span class="built_in">$display</span> (<span class="string">"New value:"</span>); </span><br><span class="line">	<span class="comment">//对最后三个元素重复赋值5</span></span><br><span class="line">    <span class="keyword">foreach</span> (md[ i, j]) <span class="comment">//这是正确的语法格式</span></span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"md[%0d][%0d]=%0d"</span>,i, j,md[i][j]);</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">"New value:"</span>);</span><br><span class="line">    <span class="comment">//对最后三个元素重复赋值5</span></span><br><span class="line">    md ='&#123;'&#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>&#125;,'&#123; <span class="number">3</span> &#123; <span class="number">32'd5</span> &#125; &#125; &#125; ;</span><br><span class="line">    <span class="keyword">foreach</span> (md[ i, j])</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"mci[ %0d]［%0d]= %0d"</span>, i, j, md[i][j]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Initial value: </span><br><span class="line">md[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">md[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span> </span><br><span class="line">md[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">2</span> </span><br><span class="line">md[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">3</span> </span><br><span class="line">md[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">4</span> </span><br><span class="line">md[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">5</span> </span><br><span class="line">New value: </span><br><span class="line">md[<span class="number">0</span>][<span class="number">0</span>]= <span class="number">9</span> </span><br><span class="line">md[<span class="number">0</span>][ <span class="number">1</span>]= <span class="number">8</span> </span><br><span class="line">md[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">7</span> </span><br><span class="line">md[<span class="number">0</span>][ <span class="number">0</span>]= <span class="number">5</span> </span><br><span class="line">md[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span> </span><br><span class="line">md[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="动态数组（new）"><a href="#动态数组（new）" class="headerlink" title="动态数组（new）"></a>动态数组（new）</h3><ul>
<li>new[ ]   ——&gt; allocates the storage.</li>
<li>size()    ——&gt; returns the current size of a dynamic array.</li>
<li>delete() ——&gt; empties the array, resulting in a zero-sized array.</li>
</ul>
<p>类似于列表，可以动态扩展</p>
<p><strong>只要基本数据类型相同，例如都是int，定宽数组和动态数组之间就可以相互赋值。</strong></p>
<p><strong>在元素数目相同的情况下，可以把动态数组的值复制到定宽数组。</strong></p>
<p><strong>当你把一个定宽数组复制给一个动态数组时，SystemVerilog会调用构造函数new[]来分配空间并复制数值。</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dyn[], d2[];               <span class="comment">//声明动态数组</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">5</span>];              <span class="comment">//分配5个元素的空间内存</span></span><br><span class="line">    <span class="keyword">foreach</span>(dyn[j]) dyn[j] = j;<span class="comment">//对元素进行初始化</span></span><br><span class="line">    d2 = dyn;                  <span class="comment">//复制一个动态数组，这是d2会自动调用new函数</span></span><br><span class="line">    d2[<span class="number">0</span>] = <span class="number">5</span>;                 <span class="comment">//修改复制值</span></span><br><span class="line">    <span class="built_in">$display</span>(dyn[<span class="number">0</span>],d2[<span class="number">0</span>]);    <span class="comment">//显示数字（0和5）</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">20</span>](dyn);        <span class="comment">//分配20个整数值并进行复制</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">100</span>];            <span class="comment">//分配100个新的整数值，旧值不复存在</span></span><br><span class="line">    dyn = dyn<span class="variable">.delete</span>();        <span class="comment">//删除所有元素，此时数组大小为0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列与链表相似，可以在一个队列中的任何地方增加或删除元素，这类操作在性能上的损失比动态数组小很多，因为动态数组需要分配新的数组并复制所有元素的值。</p>
<p>队列定义：</p>
<ul>
<li>第一种是bounded queue，定义了队列的上界；</li>
<li>第二种是unbounded queue，没有定义上界。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span>    queue_1[$];     <span class="comment">// queue of bits  (unbound queue)</span></span><br><span class="line"><span class="keyword">int</span>    queue_2[$];     <span class="comment">// queue of int </span></span><br><span class="line"><span class="keyword">byte</span>   queue_3[$:<span class="number">255</span>]; <span class="comment">// queue of byte (bounded queue with 256 entries)</span></span><br><span class="line"><span class="keyword">string</span> queue_4[$];     <span class="comment">// queue of strings</span></span><br></pre></td></tr></table></figure>
<p>队列方法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>  q[$] = &#123;<span class="number">3</span>,<span class="number">4</span>&#125;;  <span class="comment">//队列的常量不需要使用单引号'</span></span><br><span class="line"><span class="keyword">int</span>  q2[$]= &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    q2<span class="variable">.insert</span>(<span class="number">1</span>,j);  <span class="comment">//&#123;0,1,2,5&#125;在2之前插入1</span></span><br><span class="line">    q2<span class="variable">.insert</span>(<span class="number">3</span>,q); <span class="comment">//&#123;0,1,2,3,4,5&#125;在q2中插入一个队列</span></span><br><span class="line">    q2<span class="variable">.delete</span>(<span class="number">1</span>);    <span class="comment">//&#123;0,2,3,4,5&#125;删除第一个元素</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//下面的操作执行速度很快</span></span><br><span class="line">    q<span class="variable">.push_front</span>(<span class="number">6</span>);<span class="comment">//&#123;6,0,2,3,4,5&#125;在队列前面插入</span></span><br><span class="line">    j = q<span class="variable">.pop_back</span>; <span class="comment">//&#123;6,0,2,3,4&#125; j = 5</span></span><br><span class="line">    q<span class="variable">.push_back</span>(<span class="number">8</span>); <span class="comment">//&#123;6,0,2,3,4,8&#125;在队列末尾插入</span></span><br><span class="line">    j = q<span class="variable">.pop_front</span>;<span class="comment">//&#123;0,2,3,4,8&#125; j = 6</span></span><br><span class="line">    <span class="keyword">foreach</span>(q[i])<span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(q[i]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    q<span class="variable">.delete</span>();     <span class="comment">//&#123;&#125;删除整个队列</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3><p>类似于哈希表，是键值对应关系进行存储</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a_array1[*] ;            <span class="comment">// associative array of integer (unspecified index)</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] a_array2[<span class="keyword">string</span>]; <span class="comment">// associative array of 32-bit, indexed by string</span></span><br><span class="line">ev_array [myClass];          <span class="comment">//associative array of event,indexed by class</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210811203705.png" alt="image-20210811203705872" style="zoom:67%;" /></p>
<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><h4 id="缩减方法"><a href="#缩减方法" class="headerlink" title="缩减方法"></a>缩减方法</h4><p><strong>sum（和），product（积），and（与），or（或），和xor（异或）</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> on[lO]; </span><br><span class="line"><span class="keyword">int</span> total; </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">foreach</span>(on[i]) </span><br><span class="line">    on[i]=i;  <span class="comment">//单比特数组, on[i]的值为0或1(奇数为1，偶数为0)</span></span><br><span class="line"><span class="comment">//打印出单比特和，结果为1，on.sum为1位</span></span><br><span class="line"><span class="built_in">$display</span> (<span class="string">"on.sum= %0d"</span>, on<span class="variable">.sum</span>) ; </span><br><span class="line"><span class="comment">//打印出32比特和，结果为5，on.sum为32位，此时才是正确的求和结果</span></span><br><span class="line"><span class="built_in">$display</span> (<span class="string">"on.sum = %0d"</span>, on<span class="variable">.sum</span> + <span class="number">32'd0</span>); </span><br><span class="line"><span class="comment">//用total来表示on.sum,由于total是32比特变量，所以数组和也是32比特</span></span><br><span class="line">total = on<span class="variable">.sum</span>; </span><br><span class="line"><span class="built_in">$display</span>(<span class="string">"total = %0d"</span>，total); <span class="comment">// total=S </span></span><br><span class="line"><span class="comment">//将数组和与一个32比特数进行比较</span></span><br><span class="line"><span class="keyword">if</span> (on<span class="variable">.sum</span> &gt; = <span class="number">32'd5</span>)</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">"sum has 5 or more 1's"</span>); </span><br><span class="line"><span class="comment">//使用带32比特有符号运算的with表达式</span></span><br><span class="line"><span class="built_in">$display</span> (<span class="string">"int sum = %0d"</span>, on<span class="variable">.sum</span> <span class="keyword">with</span> (<span class="keyword">int</span>'(item))) ; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="数组定位方法"><a href="#数组定位方法" class="headerlink" title="数组定位方法"></a>数组定位方法</h4><p>数组定位方法：min、max、unique</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">6</span>] = '&#123; <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> d[] = '&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> q[$] =｛<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, tq[$] ; </span><br><span class="line">tq = q<span class="variable">.min</span> () ;  <span class="comment">// &#123;l&#125;</span></span><br><span class="line">tq= d<span class="variable">.max</span>();     <span class="comment">// &#123;10&#125;</span></span><br><span class="line">tq= f<span class="variable">.unique</span>();  <span class="comment">// &#123;1,6,2,8&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>数组定位方法：find</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[] ='&#123; <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>&#125;,  tq[$]； </span><br><span class="line"><span class="comment">//找出所有大于3的元素</span></span><br><span class="line">tq=d<span class="variable">.find</span> <span class="keyword">with</span> (item &gt;<span class="number">3</span>);</span><br><span class="line">tq=d<span class="variable">.find_index</span> <span class="keyword">with</span> (item &gt;<span class="number">3</span>); <span class="comment">//&#123;0,2,4,5&#125;</span></span><br><span class="line">tq=d<span class="variable">.find_first</span> <span class="keyword">with</span> (item&gt; <span class="number">99</span>); <span class="comment">//&#123;&#125; 没找到</span></span><br><span class="line">tq=d<span class="variable">.find_first_index</span> <span class="keyword">with</span> (item == <span class="number">8</span>); <span class="comment">//&#123;2&#125; 第2个下标为8</span></span><br><span class="line">tq=d<span class="variable">.find_last</span> <span class="keyword">with</span> (item==<span class="number">4</span>);  <span class="comment">//&#123;4&#125;</span></span><br><span class="line">tq=d<span class="variable">.find</span> last_index <span class="keyword">with</span> (item== <span class="number">4</span>);  <span class="comment">//&#123;5&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[]='&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>&#125;; </span><br><span class="line">d<span class="variable">.reverse</span>(); <span class="comment">//'&#123;4,4,3,8,1,9&#125; </span></span><br><span class="line">d. sort();  <span class="comment">//'&#123;1,3,4,4,8,9&#125; </span></span><br><span class="line">d<span class="variable">.rsort</span>();  <span class="comment">//'&#123;9,8,4,4,3,1&#125; </span></span><br><span class="line">d. shuffle();  <span class="comment">//'&#123;9,4,3,8,1,4&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="变量生命周期"><a href="#变量生命周期" class="headerlink" title="变量生命周期"></a>变量生命周期</h2><p>对于automic方法，内部所有声明的变量默认是局部变量，伴随automic方法产生和销毁</p>
<p>对于static方法，内部所有声明的变量默认全局变量</p>
<p>可通过automic或static关键字显示声明变量</p>
<p>static声明的全局变量在编译时被创建加载，在整个运行期间存在</p>
<h3 id="不同位置变量的默认生命周期"><a href="#不同位置变量的默认生命周期" class="headerlink" title="不同位置变量的默认生命周期"></a>不同位置变量的默认生命周期</h3><ul>
<li>module，program，interface，function，task之外声明的变量，默认为static变量，存在于整个仿真阶段</li>
<li>module，program，interface之内，function，task之外声明的，默认为static变量，作用域在该块中</li>
<li>module，program，interface中定义的function和task默认都是static类型</li>
<li>function和task可以通过显示的姓名automic来改变其内部变量作用域！！</li>
</ul>
<h2 id="过程语句和子程序"><a href="#过程语句和子程序" class="headerlink" title="过程语句和子程序"></a>过程语句和子程序</h2><p>initial块：类似于c的main方法，是启动程序的入口，可以有多个initial块并行，除class外，别的块都可以有</p>
<p>always：硬件行为，只能用于硬件块中！</p>
<p>硬件世界：module，interface；</p>
<p>软件世界：class，programe；</p>
<h3 id="过程语句"><a href="#过程语句" class="headerlink" title="过程语句"></a>过程语句</h3><p>SystemVerilog的新增</p>
<ul>
<li><p>for循环：continue，break</p>
</li>
<li><p>begin-end：可省略（）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> multiple_lines; </span><br><span class="line"><span class="built_in">$display</span> (<span class="string">"First line"</span>); </span><br><span class="line"><span class="built_in">$display</span> (<span class="string">"second line"</span>); </span><br><span class="line"><span class="keyword">endtask</span> : multiple_lines</span><br></pre></td></tr></table></figure>
</li>
<li><p>return 语句：显式返回；function会返回一个与方法名同名的变量，可以直接对该变量进行修改</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fixed_array5[<span class="number">5</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fixed_array5 init (<span class="keyword">int</span> start); </span><br><span class="line">    <span class="keyword">foreach</span> (f[i]) </span><br><span class="line">        init[i]= i + start;   <span class="comment">//直接对返回值进行修改</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">fixed_arrayS f5; </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    f5= init(<span class="number">5</span>); </span><br><span class="line">    <span class="keyword">foreach</span> (f5[i]) </span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"..."</span>） ； </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当然，针对数组的操作函数，最好使用ref进行</p>
</li>
</ul>
<h3 id="function和task"><a href="#function和task" class="headerlink" title="function和task"></a>function和task</h3><p>区别：verilog中function不能消耗时间，不能调用task，function必须有返回值</p>
<p>Systemverilog中放宽限制，function可以调用task，但只能在fork-join_none块中</p>
<h4 id="返回值问题："><a href="#返回值问题：" class="headerlink" title="返回值问题："></a><strong>返回值问题：</strong></h4><p>声明无返回值的方法：void 修饰</p>
<p>忽略有返回值方法的返回值：void’ (<strong>$fscanf (file,”%d II, i)</strong>)</p>
<h4 id="传入参数："><a href="#传入参数：" class="headerlink" title="传入参数："></a><strong>传入参数</strong>：</h4><p><strong>Verilog对参数的处理方式很简单：在子程序的开头把input和inout的值复制给本地变量，在子程序退出时则复制output和inout此的值。 除了标量以外，没有任何把存储器传递给Verilog子程序的办法。</strong></p>
<p>可以在参数列表中指定输入参数（input），输出参数（output），输入输出参数（inout），引用类型（ref），这些参数形式区别于软件的参数</p>
<ul>
<li><p>input说明参数流入，在参数未表明传输方向时是默认的</p>
</li>
<li><p>output定义输出方向，方法结束后该参数其实是一个输出值</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> trans；</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    trans t;</span><br><span class="line">    trans s;</span><br><span class="line">    t = <span class="keyword">new</span>();</span><br><span class="line">    s = <span class="keyword">new</span>();</span><br><span class="line">    copyof（t,s）;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> copyof(trans t, trans s);</span><br><span class="line">    t=s;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p>默认为input参数，和软件的形参一样，input类型的参数在方法内部就是一个动态变量，和此时方法内的t和外面的t没有任何关系！！！</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> copyof(<span class="keyword">output</span> trans t, <span class="keyword">input</span> trans s);</span><br><span class="line">    t=s;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p>通过output修饰，则对变量的修改可以传出方法</p>
</li>
<li><p>inout：双向端口</p>
</li>
<li><p>ref：类似于inout，传入变量的引用，实际也就是内存地址或者说指针，方法内对变量的修改实际是对内存的修改，是立即发生的！！！</p>
<p>对应变量，可以理解为传入的是一个指针</p>
<p>对应句柄，可以理解为传入的是一个句柄！！</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> <span class="keyword">initial</span>(<span class="keyword">ref</span> trans t);</span><br><span class="line">	t=<span class="keyword">new</span>();</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ref专题"><a href="#ref专题" class="headerlink" title="ref专题"></a>ref专题</h4><p>在SystemVerilog中，参数的传递方式可以指定为引用而不是复制。 这种ref参数类型比input、output或inout更好用。</p>
<p><strong>为什么要使用ref？</strong></p>
<ul>
<li>System Verilog允许不带ref进行数组参数的传递，这时数组会被复制到堆栈区里。这种操作的代价很高，除非是对特别小的数组。</li>
<li>ref参数的第二个好处是在任务里可以修改变量而且修改结果对调用它的函数随时可见。 当你有若干并发执行的线程时，这可以给你提供一种简单的信息传递方式。</li>
</ul>
<p><strong>const ref</strong>声明参数又有何作用？</p>
<p>编译器会进行检查，以确保数组不被子程序修改，子程序存在修改操作，编译器会报错~</p>
<p><strong>实例：</strong></p>
<p>一旦bus.enable有效，初始化块中的thread2块马上就可以获取来自存储器的数据，而不用等到bus_read任务完成总线上的数据处理后返回，这可能需要若干个时钟周期。 由于参数data是以ref方式传递的，所以只要任务里的data有变化，@data语句就会触发。 如果你把data声明为output，则＠data语句就要等到总线处理完成后才能触发。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> bus_ read (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">31</span>: o] addr, </span><br><span class="line">	<span class="keyword">ref</span> <span class="keyword">logic</span> [ <span class="number">31</span>: O] data); </span><br><span class="line">	bus<span class="variable">.request</span>= l'bl; </span><br><span class="line">    @ (<span class="keyword">posedge</span> bus<span class="variable">.grant</span>) bus<span class="variable">.addr</span> = addr; </span><br><span class="line">	@ (<span class="keyword">posedge</span> bus<span class="variable">.enable</span>) data=bus<span class="variable">.data</span>; </span><br><span class="line">    bus<span class="variable">.request</span>= <span class="number">1</span>'bO; </span><br><span class="line">	@ (<span class="keyword">negedge</span> bus<span class="variable">.grant</span>); </span><br><span class="line"><span class="keyword">endtask</span> </span><br><span class="line"><span class="keyword">logic</span> [ <span class="number">31</span>: o] addr, data; </span><br><span class="line"><span class="keyword">initial</span> </span><br><span class="line">    <span class="keyword">fork</span> </span><br><span class="line">        bus_read(addr,data); </span><br><span class="line">        thread2: <span class="keyword">begin</span> </span><br><span class="line">            @data;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">"Read th from bus"</span>, data); </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">join</span></span><br></pre></td></tr></table></figure>
<h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>实例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">七ask many (<span class="keyword">input</span> <span class="keyword">int</span> a= <span class="number">1</span>, b= <span class="number">2</span>, c= <span class="number">3</span>, d= <span class="number">4</span>); </span><br><span class="line"><span class="built_in">$display</span> (<span class="string">"%0d %0d %0d %0d"</span>, a, b, c, d); </span><br><span class="line"><span class="keyword">endtask</span> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    many(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>); </span><br><span class="line">    many(); </span><br><span class="line">    many (<span class="variable">.c</span>(<span class="number">5</span>)) ;</span><br><span class="line">    many (,<span class="number">6</span>,<span class="variable">.d</span>(<span class="number">8</span>)) ;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h2><p>通过module端口进行连接：信号名映射的连接方法存在许多缺点：</p>
<ul>
<li>增加了代码输入量</li>
<li>信号多时更加复杂</li>
<li>增加新的信号，需要对模块端口和顶层连接都进行修改</li>
</ul>
<p>接口就是解决这种层次化的配置，将所有连线提取出来封装到一起。在使用时对接口进行例化，依此来简化连接</p>
<h3 id="modport"><a href="#modport" class="headerlink" title="modport"></a>modport</h3><p>接口中使用了点对点的无信号方向的连接方式。在使用该端口的原始网单里包含了方向信息，编译器依此检查连线错误。</p>
<p>接口中使用modport结构能够将信号分组并指定方向。</p>
<p>如在test和dut的接口中引入monitor模块的接口：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> arb_if(<span class="keyword">input</span> clk);</span><br><span class="line">    <span class="keyword">logic</span>[<span class="number">1</span>:<span class="number">0</span>] grant, request;</span><br><span class="line">    <span class="keyword">logic</span>[<span class="number">32</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">modport</span> TEST(</span><br><span class="line">    	<span class="keyword">output</span> request, rst;</span><br><span class="line">        <span class="keyword">input</span> grant, clk;</span><br><span class="line">        <span class="keyword">inout</span> data;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">modport</span> DUT(</span><br><span class="line">    	<span class="keyword">input</span> request, rst, clk;</span><br><span class="line">        <span class="keyword">output</span> grant;</span><br><span class="line">        <span class="keyword">inout</span> data;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">modport</span> MONITOR(</span><br><span class="line">    	<span class="keyword">input</span> request;</span><br><span class="line">        <span class="keyword">input</span> grant;</span><br><span class="line">        <span class="keyword">input</span> data;</span><br><span class="line">        <span class="keyword">input</span> clk;</span><br><span class="line">        <span class="keyword">input</span> rst;</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>
<p>此时接口例化时需要指明modport</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> arb(arb_if<span class="variable">.DUT</span> aif);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//---------------------------</span></span><br><span class="line"><span class="keyword">module</span> test(arb_if<span class="variable">.TEST</span> aif);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="激励时序"><a href="#激励时序" class="headerlink" title="激励时序"></a>激励时序</h3><p>对应时钟周期级的测试平台，需要在相对于时钟信号的合适时间点驱动和接收同步信号。驱动的太晚或采样的太早，测试平台就会错过一个时钟周期。即使在同一个时间片内，设计和测试平台的时间也会引起竞争状态，即在时钟的有效边沿处进行信号的驱动或采样是很容易出现竞争状态的。</p>
<p>对于测试平台来说：</p>
<p>驱动：时钟有效沿时，dut对连接线上的数据进行锁存和处理，测试平台应将本次驱动延时，以保证数据的保持时间</p>
<p>采样：时钟有效沿时，测试平台想要采到当前连接线上的数据，因此需要在dut驱动数据之前，即提前时钟有效沿采样，否侧新的信号被dut驱动到连接线，本次数据丢失</p>
<h1 id="时钟块"><a href="#时钟块" class="headerlink" title="时钟块"></a>时钟块</h1><h2 id="竞争问题实例"><a href="#竞争问题实例" class="headerlink" title="竞争问题实例"></a>竞争问题实例</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210802093251.png" alt="image-20210802093251007" style="zoom:67%;" /></p>
<p><strong>在45ns时，clk1在上升沿处打印结果d1，clk2在45ns处采样的d1应该是多少？</strong></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210802123013.png" alt="image-20210802123013109" style="zoom: 67%;" /></p>
<p>在一般手绘仿真波形的时候，都会将d1的数值变化较时钟上升沿延后，但是在仿真软件中无法直接看出</p>
<p>如何打开delta-cycle模式，捕捉时序关系</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210802093801.png" alt="image-20210802093801071" style="zoom:67%;" /></p>
<p>将detla-cycle展开，看一下实际的时序关系</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210802094007.png" alt="image-20210802094007197" style="zoom:67%;" /></p>
<h2 id="竞争问题的理解"><a href="#竞争问题的理解" class="headerlink" title="竞争问题的理解"></a>竞争问题的理解</h2><ul>
<li><p>由于各种可能性，clk与被采样数据之间如果只存在若干个delta-cycle的延迟，假如出现了时钟的复用，那么采样可能会存在问题，也就如上面例子中所示，相同时钟在同样的时刻中得到的是不同的采样结果，因此采样数据中的竞争问题会成为潜在困扰仿真采样准确性的问题。</p>
<p>如上面的例子所示，45ns处clk1和clk2（实际是45+delta-cycle）的打印结果不同，这显然是不符合逻辑的！！！clk2采样到了新更新的数值，这是不对的</p>
<p>不一定是测试环境，就算是在设计环境中，clk2对通过clk1上升沿时驱动的数据进行采样也都是有问题的</p>
</li>
<li><p>为了避免在RTL仿真行为中发生的信号竞争问题，建议通过非阻塞赋值或特定的信号延迟来解决同步的问题。</p>
</li>
<li><p>默认情况下，时钟对于组合电路的驱动会添加一个无限最小时间(delta-cycle)的延迟，而该延迟无法用绝对时间单位衡量，它要比最小时间单位精度还小。</p>
</li>
<li><p>在一个时间片(time-slot)中可以发生很多事情，例如在仿真器中敲命令“run 0”，即是让仿真器运行一个无限最小时间，一个时间片包含无限多个delta-cycle。 s &gt; </p>
<p>ms &gt; ns &gt; ps &gt; fs &gt; delta-cycle</p>
</li>
<li><p>查看delta-cycle可以观察在特定时间点，时序逻辑或组合逻辑中，参与硬件模拟仿真的硬件变量之间的准确时序前后关系。</p>
</li>
</ul>
<h3 id="竞争问题的解决"><a href="#竞争问题的解决" class="headerlink" title="竞争问题的解决"></a>竞争问题的解决</h3><ul>
<li><p>在驱动时，添加相应的人为延迟。模拟真实的延迟行为（模拟保持时间的驱动要求，即将输入保持一定时间），同时加大clk与变量之间的延迟，以此提高DUT使用信号时的准确性和TB采样信号时的可靠性。</p>
<p>比如说在clk1上升沿到达后，给1个1ps的延时后再做信号变更，此时仿真里面也就不存在delta-cycle的竞争问题</p>
</li>
<li><p>对于一些设计中的没有进行上述延迟处理的信号，<strong>也就是采样时依然存在的delta-cycle延迟的信号</strong>，我们还可以依靠在采样事件前的某段时刻进行采样，来模拟建立时间的采样要求（即信号在时钟到来前已经建立一段时间），确保采样的可靠性。</p>
</li>
</ul>
<h3 id="时钟块怎么用"><a href="#时钟块怎么用" class="headerlink" title="时钟块怎么用"></a>时钟块怎么用</h3><p><img src="https://gitee.com/biongd/img/raw/master/img/20210802102512.png" alt="image-20210802102512667" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210802103404.png" alt="image-20210802103404336" style="zoom:67%;" /></p>
<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://gitee.com/biongd/img/raw/master/img/20210802104050.png" alt="image-20210802104050695" style="zoom: 80%;" /></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210802121605.png" alt="image-20210802121605150" style="zoom: 67%;" /></p>
<ul>
<li>硬件世界和软件世界的连接可以通过灵活的interface实现，也可以通过modport来进一步限定信号传输的方向，避免端口的连接错误。</li>
<li>也可以在接口中声明clocking(时序块)和采样的时钟信号，用来做信号的同步和采样。</li>
<li>clocking块基于时钟周期对信号进行驱动或采样的方式，使得testbench不再苦恼于如何准确及时地对信号驱动或者采样，消除了信号竞争的问题。</li>
<li>clocking块不但可以定义在interface中，也可以定义在module和program中。</li>
<li>clocking中列举的信号不是自己定义的，而是应该由interface或其它声明clocking的模块定义的。</li>
<li>clocking在声明完名字之后，应该伴随着定义默认的采样事件，即“default input/output event”。如果没有定义，则会默认地在clocking采样事件前的1step对输入进行采样，在采样事件后的# 0 对输出进行驱动。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在我看来interface中对于时间块的定义，实际上就是软件系统（tb）对硬件系统（dut）的一个模仿，可以把tb的时钟理解为clk1，dut的时钟理解为clk2，此时在clk1的上升沿，通过驱动的延时，就给了dut相对于clk2的一个保持时间；</p>
<p>另外tb采样的过程和驱动过程是独立起来看的，如果把dut的时钟理解为clk1，tb的时钟理解为clk2，则此时tb的采样结果和dut的输出结果</p>
<p>为了避免可能的采样竞争问题，应该在验证环境的驱动环节就添加固定延迟，使得在仿真波形中更容易体现出时钟与被驱动信号之间的时序前后关系，同时也便于DUT的准确处理和TB的准确采样。<br>如果TB在采样从DUT送出的数据，在时钟与被驱动信号之间在存在delta-cycle时，应该考虑时钟采样沿的更早时间段去模拟建立时间要求采样，这种方法也可以避免由于delta-cycle问题带来的采样竞争问题。<br>当我们把clocking运用到interface中，用来声明各个接口与时钟的采样和驱动关系后，可以大大提高数据驱动和采样的准确性，从根本上消除采样竞争的可能性。</p>
<h1 id="类和包的使用"><a href="#类和包的使用" class="headerlink" title="类和包的使用"></a>类和包的使用</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h2 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h2><ul>
<li><p>包的意义</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SV语言提供了一种在多个module、<span class="keyword">interface</span>和<span class="symbol">program</span>之中共享<span class="symbol">parameter</span>、<span class="symbol">data</span>、<span class="symbol">type</span>、<span class="symbol">task</span>、<span class="symbol">function</span>、<span class="symbol">class</span>等的方法，即利用<span class="symbol">package</span>的方式来实现。通常将不同模块的类定义归整到不同的<span class="symbol">package</span>中。</span><br><span class="line"><span class="symbol">package</span>的好处是将一簇相关的类组织在了单一的命名空间<span class="symbol">namespace</span>下，使得分属于不同模块验证环境的类来自于不同的<span class="symbol">package</span>，这样可以通过<span class="symbol">package</span>来解决类的归属问题。</span><br></pre></td></tr></table></figure>
</li>
<li><p>包的定义</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> regs_pkg;</span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"stimulator.sv"</span> </span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"monitor.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"chker.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"env.sv"</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"><span class="keyword">package</span> arb_pkg;</span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"stimulator.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"monitor.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"chker.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"env.sv"</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：</p>
<p>​        两个package中都定义了4个与模块验证相关的类，而这两个package中同名的类，它们的内容是不相同的，实现的也是不同的功能。将这些重名的类归属到不同的package中编译，不会发生重名的编译冲突，因为package是将命名空间分隔开来的。使用时需要注明使用哪一个package中的类。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mcdf_tb;</span><br><span class="line">	regs_pkg::monitor mon1 = <span class="keyword">new</span>();</span><br><span class="line">	arb_pkg::monitor mon2 = <span class="keyword">new</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>包与库的区分</p>
<p>尽管regs_pkg和arb_pkg中都存在着一个名字为monitor的类，我们可以在引用类名的时候通过域名索引::操作符的方式来显式支出所引用的monitor类具体来自于哪一个package，这样能很好地通过不同名的package来管理同名的类。package这个容器可以对类名做一个隔离的作用。<br>package更多的意义在于将软件(类、类型、方法等)封装在不同的命名空间中，一次来与全局的命名空间进行隔离。package需要额外定义，容纳各种数据、方法、类。<br>library是编译的产物，在没有介绍软件之前，硬件(module、interface、program)都会编译到库中，如果不指定编译库的话，会被编译进入默认的库中。从容纳的类型来看，库既可以容纳硬件类型，也可以容纳软件类型，例如类和方法，也包括package。</p>
</li>
<li><p>包的命名规则</p>
<p>在创建package的时候，已经在指定包名称的时候隐含地指定了包的默认路径，即包文件所在的路径。如果有其他要被包含在包内的文件在默认路径之外，需要在编译包的时候加上额外指定的搜寻路径选项“+incdir+PATH”。<br>如果遵循package的命名习惯，不但要求定义的package名称独一无二，其内部定义的类应该也尽可能的独一无二。<br>如果不同package中定义的类名也不相同时，在顶层的引用也可以通过 import pkg_name::*的形式，来表示在module mcdf_tb中引用的类，如果在当前域中没有定义的话，会搜寻regs_pkg和arb_pkg中定义的类，又由于它们各自包含的类名不相同，因此不用担心搜寻中会遇到同名类冲突问题。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> regs_pkg;</span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"regs_stm.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"regs_mon.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"regs_chk.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"regs_env.sv"</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"><span class="keyword">package</span> arb_pkg;</span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"arb_stm.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"arb_mon.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"arb_chk.sv"</span></span><br><span class="line">	'<span class="keyword">include</span> <span class="string">"arb_env.sv"</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"><span class="keyword">module</span> mcdf_tb;</span><br><span class="line">	<span class="keyword">import</span> regs_pkg::*;</span><br><span class="line">	<span class="keyword">import</span> arb_pkg::*;</span><br><span class="line">	</span><br><span class="line">	regs_mon mon1 = <span class="keyword">new</span>();</span><br><span class="line">	arb_mon  mon2 = <span class="keyword">new</span>();</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用包的注意事项</p>
<p>在包中可以定义类、静态方法和静态变量。<br>如果将类封装在某一个包中，那么它就不应该在其它地方编译，这么做的好处在于之后对类的引用更加方便。<br>包是类的归宿，类是包的子民。<br>一个完整模块的验证环境组件类，应该由一个定义的模块包来封装。<br>使用’include的关键字完成类再包中的封装，要注意编译的前后顺序来放置各个’include的类文件。<br>编译一个包的背后实际是将各个类文件“平铺”在包中，按照顺序完成包和各个类的有序编译。<br>使用类可以通过import完成包中所有类或者某一个类的导入，使得新的环境可以识别出该类，否则类会躺在包这个盒子里不被外部识别。</p>
</li>
</ul>
<h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="1-静态转换"><a href="#1-静态转换" class="headerlink" title="1.静态转换"></a>1.静态转换</h3><p>在需要转换的表达式前面加单引号</p>
<p>这种方式不会对转换值做检查。如果转换失败，我们也无从得知</p>
<h3 id="2-动态转换"><a href="#2-动态转换" class="headerlink" title="2.动态转换"></a>2.动态转换</h3><p>动态转换需要调用系统函数<strong>$cast(tgt,src)</strong>做转换，把src转换成tgt的类型。</p>
<p>比如声明了父类句柄的子类src，转化为子类句柄的tgt</p>
<p>==<code>son tgt = （son）src；</code></p>
<p>类句柄的向下转换</p>
<pre><code>父类句柄转换为子类句柄时，需要使用$cast()函数进行转换，否则会出现编译错误；

$cast()会检查句柄所指向的对象的类型，而不是检查句柄本身;

子类句柄赋值给父类句柄（也就是将子类句柄拷贝成父类句柄），编译器认为合法;

父类句柄拷贝给子类对象，需要使用$cast检查句柄所指向的对象类型，一旦源对象跟目的对象是同一类型，就可以从父类句柄拷贝子类对象的地址给子类句柄。
</code></pre><p>【注意】:</p>
<pre><code>当$cast作为任务来使用时（直接调用，不需要返回值时），如果转换失败会给出一个错误报告
当$cast作为函数使用时（需要返回值），转换失败返回0，不给出错误报告
</code></pre><h3 id="3-显式和隐式转换"><a href="#3-显式和隐式转换" class="headerlink" title="3.显式和隐式转换"></a>3.显式和隐式转换</h3><p>动态转换和静态转换都需要操作符或者系统函数的介入，称为显式转换</p>
<p>不需要转换的操作，称为隐式转换；</p>
<p> 如：右侧是4位的矢量，左侧是5位的矢量，赋值时会隐式的做位扩展，然后再赋值</p>
<h2 id="虚函数（virtual）"><a href="#虚函数（virtual）" class="headerlink" title="虚函数（virtual）"></a>虚函数（virtual）</h2><p>看一下”virtual”关键字有哪些使用场景：</p>
<ol>
<li>主要应用场景在virtual class，virtual interface 以及 virtual task/function。</li>
<li>OOP三大特性（封装，继承，多态）中的 <strong>多态</strong> 在SystemVerilog中一般通过 “<strong>virtual</strong>” 关键字实现。</li>
</ol>
<h3 id="1-virtual-interface"><a href="#1-virtual-interface" class="headerlink" title="1. virtual interface"></a>1. virtual interface</h3><ul>
<li>在interface定义时，如果不使用关键字 “virtual” 那么在多次调用该接口时，在其中的一个实例中对接口中某一信号的修改会影响其他实例接口；如果使用了 “virtual” 关键字，那么每个实例是独立的。</li>
<li>习惯上在声明interface时均添加 “virtual”关键字。</li>
</ul>
<h3 id="2-virtual-task-function"><a href="#2-virtual-task-function" class="headerlink" title="2. virtual task/function"></a>2. virtual task/function</h3><p>子类在实现方法的继承时可以发生方法的重写，此时子类只有通过调用super.fun()才能访问父类方法</p>
<ul>
<li>多态的元素之一，没有声明virtual的方法，父类句柄=子类对象时，父类句柄无法访问到子类，只能访问到父类本身的function（）。一旦声明virtual，则该方法实现动态绑定，父类句柄则可以访问到子类的function（）！！！</li>
<li>virtual方法只需要定义在最顶层的类中，其所有子类及子类的子类中的重写方法都实现了动态绑定，通过<code>最顶层的类的句柄=子类实例</code>都可以实现调用子类的该方法</li>
</ul>
<h3 id="3-virtual-class"><a href="#3-virtual-class" class="headerlink" title="3. virtual class"></a>3. virtual class</h3><p>即抽象类</p>
<p>虚类一般用来定义类的格式,、类的成员、类的参数等，虚类不能被实例化，只能被扩展（重载）后实例化，用于在项目中定义一些标准的类。</p>
<p>虚类中的方法通常使用关键字 “ pure virtual “ 纯虚方法。同时OOP规定，只要class中存在一个没有被实现的pure function，就不允许例化这个class</p>
<p>pure virtual function（纯虚方法）：没有实体的方法原型，相当于一个声明，只能在抽象类中定义。</p>
<h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><p>当需要赋值一个对象，以防止对象的方法修改原始对象的值，或者在一个发生器中保留约束时，可以对对象做拷贝</p>
<h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1. 浅拷贝"></a>1. 浅拷贝</h3><p>只拷贝成员变量：String，int，句柄等</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packet p = p1;packet p = p2;p1 = <span class="keyword">new</span>();p2 = <span class="keyword">new</span>() p1;</span><br></pre></td></tr></table></figure>
<p>此时p1和p2是两个对象，区别于直接句柄赋值：p1=p2</p>
<h3 id="2-自定义拷贝"><a href="#2-自定义拷贝" class="headerlink" title="2. 自定义拷贝"></a>2. 自定义拷贝</h3><p><img src="https://gitee.com/biongd/img/raw/master/img/20210709221729.png" alt="image-20210709221729315" style="zoom:67%;" /></p>
<p>拷贝函数和新对象生成函数分开写：</p>
<ul>
<li>父类和子类成员均可以完成拷贝，拷贝方法声明为virtual，遵循只考虑该类的域成员的原则，父类的成员拷贝调用父类的拷贝函数</li>
<li>copy_data()需要注意句柄的类型转换，保证转换后的句柄可以访问类的成员变量</li>
</ul>
<h1 id="实验进化2"><a href="#实验进化2" class="headerlink" title="实验进化2"></a>实验进化2</h1><p>要从实验1完成哪些进化：</p>
<h2 id="interface的提取"><a href="#interface的提取" class="headerlink" title="interface的提取"></a>interface的提取</h2><ul>
<li><p>test和dut的连接关系(initiator)：</p>
<p>initiator的目的更像是创建虚拟的硬件模型，通过该module的实例化创建具有驱动能力的数据发送模块（给data就能按照需要进行发送，task chnl_write（））</p>
<p>实验1：通过module进行例化</p>
<p>实验2：通过interface实例化再传入module</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实验1的initiator_nodule</span></span><br><span class="line"><span class="keyword">module</span> chnl_initiator(</span><br><span class="line">    <span class="comment">//创建模型的第一部分，创建需要的输入输出接口</span></span><br><span class="line">  <span class="keyword">input</span>               clk,</span><br><span class="line">  <span class="keyword">input</span>               rstn,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] ch_data,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">logic</span>        ch_valid,</span><br><span class="line">  <span class="keyword">input</span>               ch_ready,</span><br><span class="line">  <span class="keyword">input</span>        [ <span class="number">5</span>:<span class="number">0</span>] ch_margin</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> name;</span><br><span class="line"><span class="comment">//给个名字作为标识</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> set_name(<span class="keyword">string</span> s);</span><br><span class="line">  name = s;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="comment">//赋予该模型驱动能力，即给MCDT写入的能力</span></span><br><span class="line"><span class="keyword">task</span> chnl_write(<span class="keyword">input</span> <span class="keyword">logic</span>[<span class="number">31</span>:<span class="number">0</span>] data);</span><br><span class="line">  <span class="comment">// USER TODO</span></span><br><span class="line">  <span class="comment">// drive valid data</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  @(<span class="keyword">posedge</span> clk);</span><br><span class="line">  ch_valid &lt;= <span class="number">1</span>;</span><br><span class="line">  ch_data &lt;= data;</span><br><span class="line">  @(<span class="keyword">negedge</span> clk);</span><br><span class="line">  <span class="keyword">wait</span>(ch_ready === <span class="number">'b1</span>);</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">"%t channel initial [%s] sent data %x"</span>, <span class="built_in">$time</span>, name, data);</span><br><span class="line">  chnl_idle();</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"><span class="comment">//赋予该模型等待的能力</span></span><br><span class="line"><span class="keyword">task</span> chnl_idle();</span><br><span class="line">  <span class="comment">// USER TODO</span></span><br><span class="line">  <span class="comment">// drive idle data</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  @(<span class="keyword">posedge</span> clk);</span><br><span class="line">  ch_valid &lt;= <span class="number">0</span>;</span><br><span class="line">  ch_data &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//实例化为3个channel</span></span><br><span class="line">chnl_initiator chnl0_init(</span><br><span class="line">  <span class="variable">.clk</span>      (clk),</span><br><span class="line">  <span class="variable">.rstn</span>     (rstn),</span><br><span class="line">  <span class="variable">.ch_data</span>  (ch0_data),</span><br><span class="line">  <span class="variable">.ch_valid</span> (ch0_valid),</span><br><span class="line">  <span class="variable">.ch_ready</span> (ch0_ready),</span><br><span class="line">  <span class="variable">.ch_margin</span>(ch0_margin) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">chnl_initiator chnl1_init(</span><br><span class="line">  <span class="variable">.clk</span>      (clk),</span><br><span class="line">  <span class="variable">.rstn</span>     (rstn),</span><br><span class="line">  <span class="variable">.ch_data</span>  (ch1_data),</span><br><span class="line">  <span class="variable">.ch_valid</span> (ch1_valid),</span><br><span class="line">  <span class="variable">.ch_ready</span> (ch1_ready),</span><br><span class="line">  <span class="variable">.ch_margin</span>(ch1_margin) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">chnl_initiator chnl2_init(</span><br><span class="line">  <span class="variable">.clk</span>      (clk),</span><br><span class="line">  <span class="variable">.rstn</span>     (rstn),</span><br><span class="line">  <span class="variable">.ch_data</span>  (ch2_data),</span><br><span class="line">  <span class="variable">.ch_valid</span> (ch2_valid),</span><br><span class="line">  <span class="variable">.ch_ready</span> (ch2_ready),</span><br><span class="line">  <span class="variable">.ch_margin</span>(ch2_margin) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实验2的initiator_interface(添加了clock块，对采样和驱动数据进行过滤)interface chnl_intf(input clk, input rstn);  logic [31:0] ch_data;  logic        ch_valid;  logic        ch_ready;  logic [ 5:0] ch_margin;  clocking drv_ck @(posedge clk);    default input #1ns output #1ns;    output ch_data, ch_valid;    input ch_ready, ch_margin;  endclockingendinterface//用interface把接口摘出去，再建立初始化模型module chnl_initiator(chnl_intf intf);  string name;  int idle_cycles = 1;    //增加模块功能，动态调整idle（等待）周期  function automatic void set_idle_cycles(int n);    idle_cycles = n;  endfunction  function automatic void set_name(string s);    name = s;  endfunction	    //添加赋予驱动的功能  task automatic chnl_write(input logic[31:0] data);    @(posedge intf.clk);    //时钟上升时设置驱动    intf.drv_ck.ch_valid &lt;= 1;    intf.drv_ck.ch_data &lt;= data;    @(negedge intf.clk);    //等待半拍，接收信号reday为高电平则    wait(intf.ch_ready === 'b1);    $display("%t channel initiator [%s] sent data %x", $time, name, data);    //这一步就决定了idle的执行次数    repeat(idle_cycles) chnl_idle();  endtask    //添加空闲等待功能  task automatic chnl_idle();    @(posedge intf.clk);    intf.drv_ck.ch_valid &lt;= 0;    intf.drv_ck.ch_data &lt;= 0;  endtaskendmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="generator的提取"><a href="#generator的提取" class="headerlink" title="generator的提取"></a>generator的提取</h2><ul>
<li><p>驱动数据data的生成：</p>
<p>实验1：在test功能module中进行创建</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>  chnl0_arr = <span class="keyword">new</span>[<span class="number">100</span>];  chnl1_arr = <span class="keyword">new</span>[<span class="number">100</span>];  chnl2_arr = <span class="keyword">new</span>[<span class="number">100</span>];  <span class="keyword">foreach</span>(chnl0_arr[i]) <span class="keyword">begin</span>    chnl0_arr[i] = <span class="number">'h00C0_00000</span> + i;	chnl1_arr[i] = <span class="number">'h00C1_00000</span> + i;	chnl2_arr[i] = <span class="number">'h00C2_00000</span> + i;  endend</span><br></pre></td></tr></table></figure>
<p>实验2：抽象出generator模块，通过interface实例化再传入module，此时结构明显更清晰了</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> chnl_generator;  <span class="keyword">int</span> chnl_arr[$];  <span class="keyword">int</span> num;  <span class="keyword">int</span> id;  <span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">void</span> initialize(<span class="keyword">int</span> n);    id = n;    num = <span class="number">0</span>;  <span class="keyword">endfunction</span>  <span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> get_data();    <span class="keyword">int</span> data;    data = <span class="number">'h00C0_0000</span> + (id&lt;&lt;<span class="number">16</span>) + num;    num++;    chnl_arr<span class="variable">.push_back</span>(data);    <span class="keyword">return</span> data;  endfunctionendmodule</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="将interface和generator的module按照需要进行实例化"><a href="#将interface和generator的module按照需要进行实例化" class="headerlink" title="将interface和generator的module按照需要进行实例化"></a>将interface和generator的module按照需要进行实例化</h2><p>并对实例化结果赋想要的初值</p>
<p>可以看到因为把接口提取出去，module的实例化不需要再对</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chnl_intf chnl0_if(.*);  chnl_intf chnl1_if(.*);  chnl_intf chnl2_if(.*);  chnl_initiator chnl0_init(chnl0_if);  chnl_initiator chnl1_init(chnl1_if);  chnl_initiator chnl2_init(chnl2_if);  chnl_generator chnl0_gen();  chnl_generator chnl1_gen();  chnl_generator chnl2_gen();      <span class="keyword">initial</span> <span class="keyword">begin</span>     <span class="comment">// verification component initializationi    chnl0_gen.initialize(0);    chnl1_gen.initialize(1);    chnl2_gen.initialize(2);    chnl0_init.set_name("chnl0_init");    chnl1_init.set_name("chnl1_init");    chnl2_init.set_name("chnl2_init");    chnl0_init.set_idle_cycles(0);    chnl1_init.set_idle_cycles(0);    chnl2_init.set_idle_cycles(0);     end</span></span><br></pre></td></tr></table></figure>
<h2 id="test的module"><a href="#test的module" class="headerlink" title="test的module"></a>test的module</h2><p>将generator的值装配到initiator中，然后执行</p>
<h1 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h1><h2 id="1-随机约束和分布"><a href="#1-随机约束和分布" class="headerlink" title="1. 随机约束和分布"></a>1. 随机约束和分布</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210707182439.png" alt="img"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="comment">//The random variable</span></span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">randc</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] kind;</span><br><span class="line">    <span class="comment">//Limit the values for src</span></span><br><span class="line">    <span class="keyword">constraint</span> c &#123; src &gt; <span class="number">10</span>;</span><br><span class="line">                   src &lt; <span class="number">15</span>;    &#125;</span><br><span class="line">    <span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line">Packet p;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    p = <span class="keyword">new</span>();    <span class="comment">//Create a packet </span></span><br><span class="line">    <span class="keyword">assert</span> (p<span class="variable">.randomize</span>())     <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">$fatal</span>(<span class="number">0</span>, <span class="string">"Packet::randomize failed"</span>);</span><br><span class="line">    transmit(p);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>rand：以扑克牌为例，每次随机都是抽回一张牌，然后再放回去</p>
<p>randc：每次随机抽回的牌都不放回</p>
<p>随机值必须是二值逻辑，4值逻辑中的x，z随机不出来</p>
<p>assert：==if</p>
<p>p.randomize()：生成随机数，返回是否成功（0则为失败）</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>constraint：约束求解器</p>
<p><strong>父类约束被子类继承</strong></p>
<p>dist：权重分布关键词（主要涉及:=表示赋值和:/表示平均概念的理解）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> src, dst;</span><br><span class="line"><span class="keyword">constraint</span> c_dist&#123;    </span><br><span class="line">    src <span class="keyword">dist</span> &#123;<span class="number">0</span>:=<span class="number">40</span>,[<span class="number">1</span>:<span class="number">3</span>]:=<span class="number">60</span>&#125;;    <span class="comment">//src = 0, weight = 40/220    //src = 1, weight = 60/220    //src = 2, weight = 60/220    //src = 3, weight = 60/220     </span></span><br><span class="line">    dst <span class="keyword">dist</span> &#123;<span class="number">0</span>:/<span class="number">40</span>,[<span class="number">1</span>:<span class="number">3</span>]:/<span class="number">60</span>&#125;;    <span class="comment">//src = 0, weight = 40/100    //src = 1, weight = 20/100    //src = 2, weight = 20/100    //src = 3, weight = 20/100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>inside表示约束中变量是某一值的集合</strong>，除非还存在其他约束，否则随机变量在集合中取值概率相同。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> c;    <span class="comment">//随机变量</span></span><br><span class="line"><span class="keyword">int</span> lo, hi;    <span class="comment">//作为上限和下限的非随机变量</span></span><br><span class="line"><span class="keyword">constraint</span> c_rang&#123;c <span class="keyword">inside</span> &#123;[lo:hi]&#125;;    <span class="comment">//lo&lt;=c&amp;&amp;c&lt;=hi&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用$指定最大值和最小值</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">6</span>:<span class="number">0</span>] b;     <span class="comment">//0 &lt;= b &lt;= 127rand </span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">5</span>:<span class="number">0</span>] e;     <span class="comment">//0 &lt;= e &lt;= 63</span></span><br><span class="line"><span class="keyword">constraint</span> c_range&#123;    </span><br><span class="line">    b <span class="keyword">inside</span> &#123;[$:<span class="number">4</span>], [<span class="number">20</span>:$]&#125;;    <span class="comment">//0&lt;= b &lt;=4 || 20 &lt;= b &lt;=127    </span></span><br><span class="line">	e <span class="keyword">inside</span> &#123;[$:<span class="number">4</span>], [<span class="number">20</span>:$]&#125;;    <span class="comment">//0&lt;= b &lt;=4 || 20 &lt;= b &lt;=63</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<strong>条件约束</strong>，可以通过<strong>-&gt;或者if-else让约束表达式在特定时刻有效</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BusOp;    ...    </span><br><span class="line">    <span class="keyword">constraint</span> c_io &#123;        </span><br><span class="line">        (io_space_mode) -&gt; addr[<span class="number">31</span>] == <span class="number">1'b1</span>; <span class="comment">//1时生效</span></span><br><span class="line">   &#125; </span><br><span class="line"><span class="keyword">class</span> BusOp;    ...    </span><br><span class="line">    <span class="keyword">constraint</span> c_len_rw &#123;        </span><br><span class="line">        <span class="keyword">if</span>(op == READ)            </span><br><span class="line">            len <span class="keyword">inside</span> &#123;[BYTE:LWRD]&#125;;        </span><br><span class="line">        <span class="keyword">else</span>            </span><br><span class="line">            len == LWED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 对于约束而言，是双向约束，是一种声明性质的代码，并行的，不是自上而下的，所有约束表达式同时有效</p>
<p>一旦发生约束冲突，则会同时失败。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] r, s, t;<span class="keyword">constraint</span> c_bidir &#123;    r &lt; t;    s == r;    t &lt; <span class="number">30</span>;    s &gt; <span class="number">25</span>;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-约束块控制"><a href="#2-约束块控制" class="headerlink" title="2. 约束块控制"></a>2. 约束块控制</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210707190458.png" alt="img"></p>
<p>在一个对象中，可能会有很多的约束块，在实际使用时，我们希望一些随机块起作用，一些随机块不起作用，这就需要控制开关来控制约束块。在system verilog中提供了constrian_mode()函数来打开或关闭约束，同时也提供了随机变量的控制函数rand_mode()来控制变量的随机性，当随机变量的随机属性被关闭时，它就不在是一个随机变量，randomize()函数不会对其赋值。</p>
<h3 id="constraint-mode"><a href="#constraint-mode" class="headerlink" title="constraint_mode()"></a>constraint_mode()</h3><p>可以被类调用，也可以被约束块调用，让该作用域下的约束打开或关闭</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;    </span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> length;<span class="comment">//进行两个冲突的约束length    </span></span><br><span class="line">    <span class="keyword">constraint</span> c_short &#123;length <span class="keyword">inside</span> [<span class="number">1</span>:<span class="number">32</span>];&#125;     </span><br><span class="line">    <span class="keyword">constraint</span> c_long  &#123;length <span class="keyword">inside</span> [<span class="number">1000</span>:<span class="number">1023</span>];&#125;</span><br><span class="line">    external <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">int</span> reasonable_constraint_mode (<span class="keyword">bit</span> on_off);</span><br><span class="line"><span class="keyword">endclass</span> Packet p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>    </span><br><span class="line">    p = <span class="keyword">new</span>(); <span class="comment">//Create a long packet by disabling short constraint    </span></span><br><span class="line">    p<span class="variable">.c_short</span><span class="variable">.constraint_mode</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="keyword">assert</span>(p<span class="variable">.randmize</span>());    </span><br><span class="line">    transmit(p); <span class="comment">//Create a short packet by disabling all constraints then enabling only the shart constraint    	</span></span><br><span class="line">    p<span class="variable">.constraint_mode</span>(<span class="number">0</span>);   </span><br><span class="line">    p<span class="variable">.c_short</span><span class="variable">.constraint_mode</span>(<span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">assert</span>(p<span class="variable">.randomize</span>());    </span><br><span class="line">    transmit(p);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="rand-mode"><a href="#rand-mode" class="headerlink" title="rand_mode()"></a><code>rand_mode()</code></h3><p>当rand_mode()作为task调用时，控制随机变量的随机属性开和关；</p>
<p>和constraint_mode的使用方法相同，只是一个是直接屏蔽constraint，一个是不对随机变量进行随机赋值</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">integer</span> source_value, dest_value;</span><br><span class="line">	... other declarations</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">Packet packet_a = <span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// Turn off all variables in object</span></span><br><span class="line">packet_a<span class="variable">.rand_mode</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// ... other code</span></span><br><span class="line"><span class="comment">// Enable source_value</span></span><br><span class="line">packet_a<span class="variable">.source_value</span><span class="variable">.rand_mode</span>(<span class="number">1</span>);</span><br><span class="line">ret = packet_a<span class="variable">.dest_value</span><span class="variable">.rand_mode</span>();</span><br></pre></td></tr></table></figure>
<p>randomize().with可以在外部增加约束，每次生成随机的时候只在当前有效，多次randomize的结果不会互相影响！！！</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210707191159.png" alt="image-20210707191159430"></p>
<blockquote>
<p>问：t.randomize().wiht({addr inside [200,300]； date inside [0,10]；});</p>
<p>这次随机化能不能实现？</p>
</blockquote>
<p>答，可以，soft关键字表示在发生约束冲突时，soft修饰的约束失效！！</p>
<h2 id="3-随机函数"><a href="#3-随机函数" class="headerlink" title="3. 随机函数"></a>3. 随机函数</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210707192755.png" alt="image-20210707192754936" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210707192916.png" alt="image-20210707192915991" style="zoom:67%;" /></p>
<ul>
<li><p>对于上面提到的randomize（）函数的注意点：</p>
<ul>
<li>可以传入参数，rand声明的变量没传入就不会随机化，没被rand声明的变量传入也会被随机化</li>
<li>无论是否传入参数，约束条件都生效</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Rising;</span><br><span class="line">    <span class="keyword">byte</span> low;        <span class="comment">//未被随机约束变量</span></span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">byte</span> med, hi;    <span class="comment">//随机化的变量,8位有符号值</span></span><br><span class="line">    <span class="keyword">constraint</span> up</span><br><span class="line">        &#123;    low &lt; med; med &lt; hi;&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Rising r;</span><br><span class="line">    r = <span class="keyword">new</span>();</span><br><span class="line">    r<span class="variable">.randomize</span>();        <span class="comment">//    随机化hi,但是不改变low</span></span><br><span class="line">    r<span class="variable">.randomize</span>(med);     <span class="comment">//    只随机化med</span></span><br><span class="line">    r<span class="variable">.randomize</span>(low);     <span class="comment">//    只随机化low</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>问：<strong>上述代码中，例化了r之后，先调用r.randomize(low)，那么low,med和hi的组合值可能是下面哪一组？</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（A）low = -1,<span class="attribute">med</span>=0, <span class="attribute">hi</span>=0（B）low = -1,<span class="attribute">med</span>=1, <span class="attribute">hi</span>=2（C）low = 报错,<span class="attribute">med</span>=0, <span class="attribute">hi</span>=0（D）low = 报错,<span class="attribute">med</span>=<span class="literal">null</span>, <span class="attribute">hi</span>=报错</span><br></pre></td></tr></table></figure>
</blockquote>
<p>答：c，因为约束条件不满足，随机化失败</p>
</li>
</ul>
<h2 id="4-数组的约束"><a href="#4-数组的约束" class="headerlink" title="4. 数组的约束"></a>4. 数组的约束</h2><p>可以加约束的两个层面：size（）和content</p>
<p>动态数组分别可以对<strong>其长度和内容</strong>做随机化处理。此外，还可以通过在约束中结合数组的其它方法sum(), product(), and(), or()和xor()。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> good_sum5;    </span><br><span class="line">    <span class="keyword">rand</span> uint len[];    </span><br><span class="line">    <span class="keyword">constraint</span> c_len&#123; </span><br><span class="line">        <span class="keyword">foreach</span> (len[i]) len[i] <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">255</span>]&#125;; <span class="comment">//元素约束        </span></span><br><span class="line">     	len<span class="variable">.sum</span>() &lt; <span class="number">1024</span>;  <span class="comment">//元素求和        </span></span><br><span class="line">     	len<span class="variable">.size</span>() <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">8</span>]&#125;；  <span class="comment">//数组长度    </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h3 id="randc并不能让数组的每个元素随机化时不重复"><a href="#randc并不能让数组的每个元素随机化时不重复" class="headerlink" title="randc并不能让数组的每个元素随机化时不重复"></a><strong>randc并不能让数组的每个元素随机化时不重复</strong></h3><p><strong>可采用以下方法：</strong></p>
<ul>
<li><p>1.数组的每个元素遍历</p>
</li>
<li><p>```verilog<br>class UniqueSlow;    </p>
<pre><code>rand bit [7:0] ua[64];    
constraint c {        
    foreach (ua[i])        //对数组中每一个元素操作            
        foreach (ua[j])                
            if(i != j)     //除了元素自己                    
                ua[i] != ua[j];     //和其它元素比较
}
</code></pre><p>endclass</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- <span class="number">2.</span>创建randc变量，在`pre_randomize()`方法中给数组赋值</span><br><span class="line"></span><br><span class="line">- ```verilog</span><br><span class="line">  <span class="keyword">class</span> randc8;    randc <span class="type">bit</span> [<span class="number">7</span>:<span class="number">0</span>] val;    //随机变量的值的范围为<span class="number">0</span>~<span class="number">255</span>，每一次randmize的<span class="number">256</span>次值都不相同endclass <span class="keyword">class</span> LittleUniqueArray;    <span class="type">bit</span> [<span class="number">7</span>:<span class="number">0</span>] ua [<span class="number">64</span>];      //定义一个含有<span class="number">64</span>个元素的数组    <span class="keyword">function</span> <span class="type">void</span> pre_randomize();        randc8 rc8;        rc8 = <span class="built_in">new</span>();        <span class="keyword">foreach</span> (ua[i])    <span class="keyword">begin</span>            <span class="keyword">assert</span>(rc8.randomize());    //从<span class="number">256</span>个元素中随机化<span class="number">64</span>次，每次随机化的值都不同            ua[i] = rc8.val;            //之后将随机化后的值赋值给数组        <span class="keyword">end</span>    endfunctionendclass</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>案例1：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> packet;    <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>] da[];                  <span class="comment">//rand修饰动态数组    constraint int da    &#123;        da.size() inside &#123;[3:5]&#125;;        //约束数组的个数为3-5        foreach(da[i]) da[i] &lt;= da[i+1];            &#125;endclasspackat p;initial begin    p = new();    p.randomize() with &#123;da.size() inside &#123;3,5&#125;;&#125;;    //约束da数组的个数或者3或者5end</span></span><br></pre></td></tr></table></figure>
<p>本题中考查动态数组的范围，边界范围da[4] &lt; da[5]中超出了范围。</p>
<h3 id="随机化句柄数组"><a href="#随机化句柄数组" class="headerlink" title="随机化句柄数组"></a>随机化句柄数组</h3><p><img src="https://gitee.com/biongd/img/raw/master/img/20210707202150.png" alt="img"></p>
<p>这里需要特别注意的：随机函数会随机每个句柄的对象</p>
<p>案例2：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> MAX_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">class</span> RandStuff;</span><br><span class="line">        <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">class</span> RandArray;</span><br><span class="line">    <span class="keyword">rand</span> RandStuff array[];</span><br><span class="line">    <span class="keyword">constraint</span> c &#123;</span><br><span class="line">        array<span class="variable">.size</span>() <span class="keyword">inside</span></span><br><span class="line">        &#123;[<span class="number">1</span>:MAX]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">    <span class="comment">//分配最大容量</span></span><br><span class="line">    array = <span class="keyword">new</span>[MAX_SIZE];</span><br><span class="line">    <span class="keyword">foreach</span> (array[i])</span><br><span class="line">        array[i] = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line">RandArray ra;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//构造数组所有对象</span></span><br><span class="line">ra = <span class="keyword">new</span>();</span><br><span class="line">    <span class="comment">//随机化数组，但是可能会减小数组</span></span><br><span class="line"><span class="keyword">assert</span>(ra<span class="variable">.randomize</span>());</span><br><span class="line"><span class="keyword">foreach</span> (ra<span class="variable">.array</span>[i])</span><br><span class="line">    <span class="built_in">$display</span>(ra<span class="variable">.array</span>[i]<span class="variable">.value</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>问：ra.randomize() with {array.size == 2}的合法求解是多少呢？</p>
</blockquote>
<p>答：<strong>array[0].value = 1,array[1].value = 1</strong></p>
<p>因为句柄对象没有rand修饰，随意randomize（）进不到对象里面</p>
<blockquote>
<p>问：RandArray类中bit[1:0] value加上rand修饰会怎么样？</p>
</blockquote>
<p>答：此时随机化方法会向句柄对象中继续寻找，然后给value变量进行随机化</p>
<h2 id="5-随机控制"><a href="#5-随机控制" class="headerlink" title="5. 随机控制"></a>5. 随机控制</h2><h3 id="生成随机序列"><a href="#生成随机序列" class="headerlink" title="生成随机序列"></a>生成随机序列</h3><p>（1）产生随机事务序列的另一种方法就是使用SV的 <strong>randsequence结构</strong>。这对于随机安排组织原子（atomic）测试序列很有帮助。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//按照要求发送激励</span></span><br><span class="line">        <span class="keyword">randsequence</span> (stream)</span><br><span class="line">            stream : cfg_read := <span class="number">1</span> | io_read :=<span class="number">2</span> | mem_read :=<span class="number">5</span>;        </span><br><span class="line"><span class="comment">//cfg_read和io_read以及mem_read的可能性1:2:5</span></span><br><span class="line">            cfg_reead : &#123;cfg_read_task;&#125; | &#123;cfg_read_task;&#125; cfg_read;</span><br><span class="line">            mem_reead : &#123;mem_read_task;&#125; | &#123;mem_read_task;&#125; mem_read;</span><br><span class="line">            io_reead  : &#123;io_read_task;&#125;  | &#123;io_read_task;&#125;  io_read;</span><br><span class="line">        <span class="keyword">endsequence</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>（2）randcase来建立随机决策树，但是它带来的 问题就是没有变量 可以提供追踪 调试。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>    <span class="keyword">int</span> len;    <span class="keyword">randcase</span>        <span class="number">1</span>:len = $urandom_range(<span class="number">0</span>,<span class="number">2</span>);    <span class="comment">//10%:0,1,or2        8:len = $urandom_range(3,5);    //80%:3,4,or5        1:len = $urandom_range(6,7);    //10%:6or7    endcase    $dsiplay("len = %0d", len);end</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>（1）randsequence和randcase都是针对轻量级的随机控制应用。而我们可以 通过定义随机类 取代上述随机控制并且由于类的继承 性使得在后期维护代码的时候更加方便。</p>
<p>（2）randsequence的相关功能我们在协调激励组件和测试用例的时候可能会用到。</p>
<p>（3）randcase对应着随机约束中dist权重约束if-else条件约束组合。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>核心：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fork</span> … <span class="keyword">join</span></span><br><span class="line"><span class="keyword">fork</span> … <span class="keyword">join_none</span></span><br><span class="line"><span class="keyword">fork</span> … <span class="keyword">join_any</span></span><br></pre></td></tr></table></figure>
<p>三者区别：执行顺序</p>
<ul>
<li>fork-join：执行完该并行块才继续执行</li>
<li>fork-join_none：先执行后面的，这个块和后面的语句属于并行</li>
<li>fork-join_any：最快的一句执行完，就和后面的语句并行</li>
</ul>
<p>一旦initial块执行结束，线程中未完成的语句也结束</p>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210708100727.png" alt="img"></p>
<ul>
<li><p>如何确保fork-join和fork-none在退出前执行完呢</p>
<p>在end之前调用wait fork</p>
</li>
<li><p><strong>停止多个线程</strong>：disable fork</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    check_trans(tr0);    <span class="comment">//线程0</span></span><br><span class="line">    <span class="comment">//创建一个线程来限制disable fork的作用范围</span></span><br><span class="line">    <span class="keyword">fork</span>    <span class="comment">//线程1</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            check_trans(tr1);    <span class="comment">//线程2</span></span><br><span class="line">            <span class="keyword">fork</span>                 <span class="comment">//线程3</span></span><br><span class="line">                check_tans(tr2);    <span class="comment">//线程4</span></span><br><span class="line">            <span class="keyword">join</span></span><br><span class="line">            <span class="comment">//停止线程1-4，单独保留线程0</span></span><br><span class="line">            <span class="variable">#(TIME_OUT/2)</span> <span class="keyword">disable</span> <span class="keyword">fork</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>disable线程1，以及其衍生出来的线程</p>
</li>
<li><p>停止多次 调用的任务</p>
<p>如果你给某一个任务或者线程<strong>指明标号</strong>，那么当这个<strong>线程被调用多次后</strong>，如果通过disable去禁止这个线程标号，所有<strong>衍生的同名线程</strong>都将被禁止。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> wait_for_time_out (<span class="keyword">int</span> id);</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                #<span class="number">2</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"@%0t: disable wait_for_time_out"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                <span class="keyword">disable</span> wait_for_time_out;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">join_none</span></span><br><span class="line">            <span class="keyword">fork</span>: just_a_little</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="built_in">$display</span>(<span class="string">"@%0t: %m: %0d enteriing thread"</span>, <span class="built_in">$time</span>,id);</span><br><span class="line">                    #TIME_OUT;</span><br><span class="line">                    <span class="built_in">$display</span>(<span class="string">"@%0t； %m: %0d done"</span>, <span class="built_in">$time</span>,id);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">join_none</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<p>可以看到该task占用的线程只是点火启动</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">initial <span class="keyword">begin</span></span><br><span class="line">    wait<span class="constructor">_for_time_out(0)</span>;    <span class="comment">//Spawn thread 0</span></span><br><span class="line">    wait<span class="constructor">_for_time_out(1)</span>;    <span class="comment">//Spawn thread 1</span></span><br><span class="line">    wait<span class="constructor">_for_time_out(2)</span>;    <span class="comment">//Spawn thread 2</span></span><br><span class="line">    #(TIME_OUT*<span class="number">2</span>) <span class="constructor">$display(<span class="string">"@%0t: All done"</span>, $<span class="params">time</span>)</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>若果执行上述语句，则在执行完id=0的task后，所用其他由该task开辟的线程被全部截止</p>
</li>
</ul>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210708101837.png" alt="img"></p>
<h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p><strong>event关键字：声明即实例</strong></p>
<p>看一下线程间的相互阻塞</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span> e1,e2;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"@%0t: 1:before trigger"</span>, <span class="built_in">$time</span>);</span><br><span class="line">        -&gt; e1;</span><br><span class="line">        @e2;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"@%0t: 1:after trigger"</span>, <span class="built_in">$time</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"@%0t: 2:before trigger"</span>, <span class="built_in">$time</span>);</span><br><span class="line">        -&gt;e2;</span><br><span class="line">        @e1;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"@%0t: 2:after trigger"</span>, <span class="built_in">$time</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> e1和e2在同一时刻被触发，但是由于delta  cycle的时间 差是的两个 初始化块可能无法等到e1或者e2</p>
<p>因为存在date-cycle，e1和e2总是有一个先触发，触发e1时等待e2，触发e2时等待e1。打印结果为：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@0:</span><span class="number">1</span>：before trigger    <span class="variable">@0</span>:<span class="number">2</span>：before trigger    <span class="variable">@0</span>:<span class="number">1</span>：after trigger</span><br></pre></td></tr></table></figure>
<p>可以看到@e1导致的阻塞没有办法解决</p>
<h3 id="triggered"><a href="#triggered" class="headerlink" title="triggered()"></a>triggered()</h3><p><strong>此时就可以对阻塞方式进行一下修改：</strong></p>
<p>更加安全的方式使用event的方法triggered()，将边沿触发改为电平触发</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span> e1,e2;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"@%0t: 1:before trigger"</span>, <span class="built_in">$time</span>);</span><br><span class="line">        -&gt; e1;</span><br><span class="line">        <span class="keyword">wait</span> (e2<span class="variable">.tregger</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"@%0t: 1:after trigger"</span>, <span class="built_in">$time</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"@%0t: 2:before trigger"</span>, <span class="built_in">$time</span>);</span><br><span class="line">        -&gt;e2;</span><br><span class="line">        <span class="keyword">wait</span> (e1<span class="variable">.tregger</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"@%0t: 2:after trigger"</span>, <span class="built_in">$time</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>此时只有e1，e2执行就代表电平触发已经完成，不会再造成阻塞</p>
<h3 id="和triggered-的使用时机"><a href="#和triggered-的使用时机" class="headerlink" title="@和triggered()的使用时机"></a>@和triggered()的使用时机</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> road;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    sutomatic <span class="keyword">begin</span></span><br><span class="line">    byd<span class="variable">.drive</span>();</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> car;</span><br><span class="line">    <span class="keyword">bit</span>   <span class="keyword">static</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">task</span>  launch();</span><br><span class="line">        start = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"car is launched"</span>);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    <span class="keyword">task</span> move();</span><br><span class="line">        <span class="keyword">wait</span>(start == <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"car is moving"</span>);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">task</span> drive();</span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        <span class="keyword">this</span><span class="variable">.launch</span>();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.move</span>();</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>为了保证发动方法在前，通过bit位控制move（）方法阻塞</p>
<p>此时只要执行了launch（），move（）方法随便执行</p>
<p>此时可以直接换成event和triggered</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> car;    <span class="keyword">event</span>  e_start;    <span class="keyword">task</span>  launch();        -&gt; e_start;        <span class="built_in">$display</span>(<span class="string">"car is launched"</span>);    <span class="keyword">endtask</span>    <span class="keyword">task</span> move();        <span class="keyword">wait</span>(e_start<span class="variable">.triggered</span>());        <span class="built_in">$display</span>(<span class="string">"car is moving"</span>);    endtasktask drive();    <span class="keyword">fork</span>        <span class="keyword">this</span><span class="variable">.launch</span>();        <span class="keyword">this</span><span class="variable">.move</span>();    joinendtaskendclass</span><br></pre></td></tr></table></figure>
<p>那如果再增加一个显示速度的方法，要求每次增加速度都会显示，此时就要使用边沿触发@，因为电平触发只会发生一次，后续<code>wait(triggered())</code>的返回值会一直为1，阻塞检测激励将不复存在</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lass car;</span><br><span class="line">    <span class="keyword">event</span> e_start;</span><br><span class="line">    <span class="keyword">event</span> e_speedup;</span><br><span class="line">    <span class="keyword">int</span> speed = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">task</span> speedup();</span><br><span class="line">        #<span class="number">10</span>ns;</span><br><span class="line">        -&gt;e_speedup;</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    <span class="keyword">task</span> display();</span><br><span class="line">        <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">            @e_speedup;</span><br><span class="line">            speed++;</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">"speed is %0d"</span>,speed);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    <span class="keyword">task</span> drive();</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">this</span><span class="variable">.speedup</span>();</span><br><span class="line">            <span class="keyword">this</span><span class="variable">.display</span>();</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h3 id="旗语（semaphore）"><a href="#旗语（semaphore）" class="headerlink" title="旗语（semaphore）"></a>旗语（semaphore）</h3><p>也就是锁<img src="https://gitee.com/biongd/img/raw/master/img/20210708110231.png" alt="img"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test(bus_ifc<span class="variable">.TB</span><span class="variable">.bus</span>);</span><br><span class="line">    semaphore sem;    <span class="comment">//创建一个semaphore</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        sem = <span class="keyword">new</span>(<span class="number">1</span>);    <span class="comment">//分配一个钥匙</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            sequencer();    <span class="comment">//产生两个总线实物线程</span></span><br><span class="line">            sequencer();</span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">task</span> sequencer;</span><br><span class="line">        <span class="keyword">repeat</span>($urandom%<span class="number">10</span>)    <span class="comment">//随机等待0-9个周期</span></span><br><span class="line">        @bus<span class="variable">.cb</span>;</span><br><span class="line">        sendTrans();            <span class="comment">//执行总线事务</span></span><br><span class="line">    endTask</span><br><span class="line">    <span class="keyword">task</span> sendTrans;</span><br><span class="line">        sem<span class="variable">.get</span>(<span class="number">1</span>);            <span class="comment">//获取总线钥匙</span></span><br><span class="line">        @bus<span class="variable">.cb</span>;                <span class="comment">//把信号驱动到总线上</span></span><br><span class="line">        bus<span class="variable">.cb</span><span class="variable">.addr</span> &lt;= t<span class="variable">.addr</span>;</span><br><span class="line">        ...</span><br><span class="line">        sem<span class="variable">.put</span>(<span class="number">1</span>);            <span class="comment">//处理完成时把钥匙返回</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p>semaphore 钥匙数是傻瓜式的增减：</p>
<p>new() ：不传参就没钥匙</p>
<p>get（）：调用就少一把</p>
<p>put（）：调用就多一把</p>
<p>上面这种调用方式可能出现的问题，钥匙越来越多</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> car;</span><br><span class="line">    semaphore key;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span><span class="literal">()</span>;</span><br><span class="line">        key = <span class="keyword">new</span>(<span class="number">1</span>);</span><br><span class="line">    endfunction</span><br><span class="line">    task get<span class="constructor">_on(<span class="params">string</span> <span class="params">p</span>)</span>;</span><br><span class="line">        <span class="constructor">$display(<span class="string">"%s is waiting for the key"</span>, <span class="params">p</span>)</span>;</span><br><span class="line">        key.get<span class="literal">()</span>;</span><br><span class="line">        #<span class="number">1n</span>s;</span><br><span class="line">        <span class="constructor">$display(<span class="string">"%s got on zhe car"</span>, <span class="params">p</span>)</span>;</span><br><span class="line">    endtask</span><br><span class="line">    task get<span class="constructor">_off(<span class="params">string</span> <span class="params">p</span>)</span>;</span><br><span class="line">        <span class="constructor">$display(<span class="string">"%s is got off the car"</span>, <span class="params">p</span>)</span>;</span><br><span class="line">        key.put<span class="literal">()</span>;</span><br><span class="line">        #<span class="number">1n</span>s;</span><br><span class="line">        <span class="constructor">$display(<span class="string">"%s return the key"</span>, <span class="params">p</span>)</span>;</span><br><span class="line">    endtask</span><br><span class="line">endlass</span><br><span class="line"><span class="keyword">module</span> family;</span><br><span class="line">car byd = <span class="keyword">new</span><span class="literal">()</span>;</span><br><span class="line"><span class="built_in">string</span> p1 = <span class="string">"husband"</span>;</span><br><span class="line"><span class="built_in">string</span> p2 = <span class="string">"wife"</span>;</span><br><span class="line">initial <span class="keyword">begin</span></span><br><span class="line">    fork</span><br><span class="line">        <span class="keyword">begin</span>    <span class="comment">//    丈夫开车</span></span><br><span class="line">            byd.get<span class="constructor">_on(<span class="params">p1</span>)</span>;</span><br><span class="line">            byd.get<span class="constructor">_off(<span class="params">p1</span>)</span>;  </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">begin</span>    <span class="comment">//    妻子开车</span></span><br><span class="line">            byd.get<span class="constructor">_on(<span class="params">p2</span>)</span>;</span><br><span class="line">            byd.get<span class="constructor">_off(<span class="params">p2</span>)</span>;            </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    jion</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<p>如果没注意还了一把钥匙，就会导致钥匙数在意料之外变多，如何避免这种情况</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> carkeep;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> q[$];            <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">string</span> user;</span><br><span class="line">    <span class="keyword">task</span> keep_car();</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">forever</span> <span class="keyword">begin</span>    <span class="comment">//管理钥匙和分发</span></span><br><span class="line">                <span class="keyword">wait</span>(q<span class="variable">.size</span>() != <span class="number">0</span> &amp;&amp; key != <span class="number">0</span>);</span><br><span class="line">                user = q<span class="variable">.pop_front</span>();    <span class="comment">//等待</span></span><br><span class="line">                key--;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join_none</span>;</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    <span class="keyword">task</span> get_key(<span class="keyword">string</span> p);    <span class="comment">//拿钥匙</span></span><br><span class="line">        q<span class="variable">.push_back</span>(p);        <span class="comment">//把名字告诉</span></span><br><span class="line">        <span class="keyword">wait</span>(user == p);        <span class="comment">//等待了</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    <span class="keyword">task</span> put_key(<span class="keyword">string</span> p);    <span class="comment">//还钥匙</span></span><br><span class="line">        <span class="keyword">if</span>(user == p)    <span class="keyword">begin</span>    <span class="comment">//拿钥匙的和还钥匙的是一个人</span></span><br><span class="line">            user = <span class="string">"none"</span>;</span><br><span class="line">            key++；</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>增加一个用户队列，此时用户没有资格获取钥匙，由keep_car()统一分发！！！用户只可以还钥匙，并将该用户删除</p>
<p>这就保证了最多只能有1把钥匙！！！</p>
<ul>
<li>调用还钥匙方法：user是锁死的，只有同一个user才可以还，还完别的user无法访问，钥匙数最多只能为1</li>
<li>调用取钥匙方法：一旦队列有人，并且有钥匙，马上分配！！此时key为0，队列进入等待，直到取钥匙的user还钥匙</li>
</ul>
<h3 id="mailbox"><a href="#mailbox" class="headerlink" title="mailbox"></a>mailbox</h3><p>线程同步只需要event来保证，只有线程之间传递消息时使用mailbox</p>
<p><img src="https://img-blog.csdnimg.cn/20200502110846540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheV93aG8=,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>try_get()，try_put（)，try_peek()是非阻塞</li>
<li><strong>限定mailbox可以传入的参数类型：<code>mailbox #(int)</code></strong></li>
<li>new() ：表示变长，new（N）表示定长</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> bounded;</span><br><span class="line">    mailbox mbx;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        mbx = <span class="keyword">new</span>(<span class="number">1</span>);    <span class="comment">//容量为1</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="comment">//线程1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;<span class="number">4</span> ; i++) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"Producer: before put(%0d)"</span>, i);</span><br><span class="line">                mbx<span class="variable">.put</span>(i);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"Producer: after put(%0d)"</span>, i);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">//Consumer线程</span></span><br><span class="line">            <span class="keyword">repeat</span>(<span class="number">4</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                #<span class="number">1</span>ns mbx<span class="variable">.get</span>(j);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"Consumer: after put(%0d)"</span>, j);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> bounded;</span><br><span class="line">    mailbox mbx;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        mbx = <span class="keyword">new</span>(<span class="number">1</span>);    <span class="comment">//容量为1</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="comment">//线程1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;<span class="number">4</span> ; i++) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"Producer: before put(%0d)"</span>, i);</span><br><span class="line">                mbx<span class="variable">.put</span>(i);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"Producer: after put(%0d)"</span>, i);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">//Consumer线程</span></span><br><span class="line">            <span class="keyword">repeat</span>(<span class="number">4</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                #<span class="number">1</span>ns mbx<span class="variable">.get</span>(j);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"Consumer: after put(%0d)"</span>, j);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210708161421.png" alt="image-20210708161421701"></p>
<h1 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h1><ul>
<li><p>代码覆盖率：工具会自动搜集已经编写好的代码，常见的代码覆盖率如下：</p>
<ul>
<li>行覆盖率（line coverage）：记录程序的各行代码被执行的情况。</li>
<li>条件覆盖率（condition coverage）：记录各个条件中的逻辑操作数被覆盖的情况。</li>
<li>跳转覆盖率（toggle coverage）：记录单bit信号变量的值为0/1跳转情况，如从0到1，或者从1到0的跳转。</li>
<li>分支覆盖率（branch coverage）：又称路径覆盖率（path coverage），指在if，case，for，forever，while等语句中各个分支的执行情况。</li>
<li>状态机覆盖率（FSM coverage）：用来记录状态机的各种状态被进入的次数以及状态之间的跳转情况</li>
</ul>
</li>
<li><p>功能覆盖率：是一种用户定义的度量，主要是衡量设计所实现的各项功能，是否按预想的行为执行，即是否符合设计说明书的功能点要求，功能覆盖率主要有两种如下所示：</p>
<ul>
<li>面向数据的覆盖率（Data-oriented Coverage）-对已进行的数据组合检查.我们可以通过编写覆盖组（coverage groups）、覆盖点（coverage points）和交叉覆盖（cross coverage）获得面向数据的覆盖率.</li>
<li>面向控制的覆盖率（Control-oriented Coverage）-检查行为序列（sequences of behaviors）是否已经发生.通过编写SVA来获得断言覆盖率(assertion coverage).</li>
</ul>
</li>
</ul>
<p>需要指出的是:  <strong>代码覆盖率达到要求并不意味着功能覆盖率也达到要求，二者无必然的联系</strong>。而为了保证<strong>验证的完备性</strong>，在收集覆盖率时，要求代码覆盖率和功能覆盖率同时达到要求。</p>
<p><strong>功能覆盖率建模</strong></p>
<p>功能覆盖率<code>主要关注设计的输入、输出和内部状态</code>，通常以如下方式描述信号的采样要求；</p>
<p>对于输入，它检测数据端的输入和命令组合类型，以及控制信号与数据传输的组合情况。<br>对于输出，它检测是否有完整的数据传输类别，以及各种情况的反馈时序。<br>对于内部设计，需要检查的信号与验证计划中需要覆盖的功能点相对应。通过对信号的单一覆盖、交叉覆盖或时序覆盖来检查功能是否被触发，以及执行是否正确。</p>
<h2 id="覆盖组——covergroup"><a href="#覆盖组——covergroup" class="headerlink" title="覆盖组——covergroup"></a>覆盖组——covergroup</h2><p>   使用覆盖组结构（covergroup）定义覆盖模型，覆盖组结构（covergroup construct）是一种用户自定义的结构类型，一旦被定义就可以创建多个实例就像类（class）一样,也是通过new()来创建实例的。覆盖组可以定义在module、program、interface以及class中。</p>
<p>每一个覆盖组（covergroup）都必须明确一下内容：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> cov_grp @(<span class="keyword">posedge</span> clk);    <span class="comment">//用时钟明确了覆盖点的采样时间,上升沿采样覆盖点，也可省略clk，在收集覆盖率时在根据情况注明</span></span><br><span class="line">  cov_p1: <span class="keyword">coverpoint</span> a;<span class="comment">//定义覆盖点,cov_p1为覆盖点名，a为覆盖点中的变量名，也就是模块中的变量名</span></span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"> </span><br><span class="line">cov_grp cov_inst = <span class="keyword">new</span>();<span class="comment">//实例化覆盖组</span></span><br></pre></td></tr></table></figure>
<p>上述例子<strong>用时钟明确了覆盖点的采样时间</strong>,上升沿采样覆盖点，也可省略clk，在收集覆盖率时在根据情况注明，如下示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> cov_grp;</span><br><span class="line">  cov_p1: <span class="keyword">coverpoint</span> a;<span class="comment">//cov_p1为覆盖点名，a为覆盖点中的变量名，也就是模块中的变量名</span></span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"> </span><br><span class="line">cov_grp cov_inst = <span class="keyword">new</span>();</span><br><span class="line">cov_inst<span class="variable">.sample</span>();          <span class="comment">//sample函数收集覆盖率</span></span><br></pre></td></tr></table></figure>
<p>上面的例子通过<strong>内建的sample()方法</strong>来触发覆盖点的采样.</p>
<p><strong>覆盖组中允许带形式参数</strong>，外部在引用覆盖组时可以通过传递参数，从而对该覆盖组进行复用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] address;</span><br><span class="line"><span class="keyword">covergroup</span> address_cov (<span class="keyword">ref</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] address,<span class="keyword">input</span> <span class="keyword">int</span> low, <span class="keyword">int</span> high) @ (<span class="keyword">posedge</span> ce);</span><br><span class="line">    ADDRESS : <span class="keyword">coverpoint</span> address &#123;</span><br><span class="line">      <span class="keyword">bins</span> low  = &#123;<span class="number">0</span>,low&#125;;</span><br><span class="line">      <span class="keyword">bins</span> med  = &#123;low,high&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"> </span><br><span class="line">address_cov acov_low  = <span class="keyword">new</span>(addr,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">address_cov acov_med  = <span class="keyword">new</span>(addr,<span class="number">11</span>,<span class="number">20</span>);</span><br><span class="line">address_cov acov_high = <span class="keyword">new</span>(addr,<span class="number">21</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<h2 id="覆盖点——coverpoint"><a href="#覆盖点——coverpoint" class="headerlink" title="覆盖点——coverpoint"></a>覆盖点——coverpoint</h2><p>  <code>一个覆盖组可以包含多个覆盖点,每个覆盖点有一组显式bins值，bins值可由用户自己定义，每个bins值与采样的变量或者变量的转换有关</code>。一个覆盖点可以是一个整型变量也可以是一个整型表达式。<strong>覆盖点为整形表达式的示例如下：注意覆盖点表达式写法。</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction();</span><br><span class="line">   <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">2</span>:<span class="number">0</span>]  hdr_len;       <span class="comment">//取值：0~7</span></span><br><span class="line">   <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>]  payload_len;   <span class="comment">//取值：0~15</span></span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction   tr；</span><br><span class="line"></span><br><span class="line"><span class="keyword">covergroup</span> Cov;</span><br><span class="line">    len16: <span class="keyword">coverpoint</span>(tr<span class="variable">.hdr_len</span> + tr<span class="variable">.payload_len</span>);    <span class="comment">//注：求和结果为3位2进制，取值范围为0~15</span></span><br><span class="line">    len32：<span class="keyword">coverpoint</span>(tr<span class="variable">.hdr_len</span> + tr<span class="variable">.payload_len</span> + <span class="number">5'b0</span>);   <span class="comment">//注：求和结果为5位2进制，取值范围为0~31</span></span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<p> 当进行仿真后，<strong>len16的覆盖点覆盖率最高可达100%</strong>，而<strong>覆盖点len32的覆盖率最高只能达到23/32=71.87%</strong>。由于总的bins数量为32个，而实际最多只能产生产生len_0,len_1,len2,…,len22共23个bins，所以覆盖率永远不可能达到100%</p>
<p>如果要使覆盖点len32达到100%的覆盖率，可以手动添加自定义bins，代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> Cov;</span><br><span class="line">   len32：<span class="keyword">coverpoint</span>(tr<span class="variable">.hdr_len</span> + tr<span class="variable">.payload_len</span> + <span class="number">5'b0</span>);   <span class="comment">//注：取值范围为0~31  </span></span><br><span class="line">                    &#123;<span class="keyword">bins</span>  len[] = &#123;[<span class="number">0</span>:<span class="number">22</span>]&#125;;&#125; </span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<h3 id="盖点元素——隐式bin与显式bins"><a href="#盖点元素——隐式bin与显式bins" class="headerlink" title="盖点元素——隐式bin与显式bins"></a>盖点元素——隐式bin与显式bins</h3><p>隐式或自动bin：覆盖点变量，其取值范围内的每一个值都会有一个对应的bin，这种称为自动或隐式的bin。例如，对于一个位宽为nbit的覆盖点变量，若不指定bin个数，2^n个bin将会由系统自动创建，<strong>需要注意的是自动创建bin的最大数目由auto_bin_max内置参数决定，默认值64。</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test(busifc<span class="variable">.TB</span> ifc);        <span class="comment">//接口例化</span></span><br><span class="line">   <span class="keyword">class</span> Transaction;</span><br><span class="line">      <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>]  data;</span><br><span class="line">      <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>]  port;</span><br><span class="line">   <span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">covergroup</span> Cov;           <span class="comment">//定义覆盖组，未添加时钟信号，此时需要使用sample（）函数采集覆盖率</span></span><br><span class="line">      <span class="keyword">coverpoint</span>  tr<span class="variable">.port</span>;     <span class="comment">//设置覆盖点</span></span><br><span class="line">   <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">      Transaction  tr=<span class="keyword">new</span>();     <span class="comment">//例化数据包</span></span><br><span class="line">      Cov          ck=<span class="keyword">new</span>();     <span class="comment">//例化覆盖组</span></span><br><span class="line">      <span class="keyword">repeat</span>(<span class="number">32</span>) <span class="keyword">begin</span></span><br><span class="line">         tr<span class="variable">.randomize</span>();</span><br><span class="line">         ifc<span class="variable">.cb</span><span class="variable">.port</span> &lt;= tr<span class="variable">.port</span>;</span><br><span class="line">         ifc<span class="variable">.cb</span><span class="variable">.data</span> &lt;= tr<span class="variable">.data</span>;</span><br><span class="line">         ck<span class="variable">.sample</span>();            <span class="comment">//采集覆盖率</span></span><br><span class="line">         @ifc<span class="variable">.cb</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<p>显式bins：”bins”关键字被用来显示定义一个变量的bin，<strong>用户自定义bin可以增加覆盖的准确度</strong>，它属于功能覆盖率的一个衡量单位。在每次采样结束时，生成的数据库中会包含采样后的所有bins，显示其收集到的具体覆盖率值。最终的覆盖率等于采样的bins值除以总的bins值。</p>
<p>针对某一变量，我们关心的可能只是某些区域的值或者跳转点，因此我们可以<strong>在显示定义的bins中指定一组数值（如3，5，6）或者跳转序列（如3-&gt;5-&gt;6）</strong>。 <strong>显示定义bins时，可通过关键字default将未分配到的数值进行分配</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span>  Cov;</span><br><span class="line">    <span class="keyword">coverpoint</span>  tr<span class="variable">.data</span>&#123;             <span class="comment">//data变量的取值范围为0~15，不设置显示bins时，理论上会有2^16个bin</span></span><br><span class="line">               <span class="keyword">bins</span>  zero = &#123;<span class="number">0</span>&#125;;            <span class="comment">//取值：0</span></span><br><span class="line">               <span class="keyword">bins</span>  lo = &#123;[<span class="number">1</span>:<span class="number">3</span>],<span class="number">5</span>&#125;;        <span class="comment">//取值：1,2,3,5</span></span><br><span class="line">               <span class="keyword">bins</span>  hi[] = &#123;[<span class="number">8</span>:$]&#125;;        <span class="comment">//取值：8~15，使用动态数组方法时相当于创建了hi[0],hi[1],...,hi[7]一共8个bins</span></span><br><span class="line">               <span class="keyword">bins</span>  misc = <span class="keyword">default</span>;        <span class="comment">//余下的所有值：4,6,7</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200425001501241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjAyMjQzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="覆盖点的状态跳转——-gt-与-通配符"><a href="#覆盖点的状态跳转——-gt-与-通配符" class="headerlink" title="覆盖点的状态跳转——=&gt; 与 ?通配符"></a>覆盖点的状态跳转——=&gt; 与 ?通配符</h3><p>  除了在bins中定义数值，还可以定义数值之间的跳转，操作符（=&gt;），如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span>[<span class="number">2</span>:<span class="number">0</span>]     v;</span><br><span class="line"><span class="keyword">covergroup</span>  sg@(<span class="keyword">posedge</span> clk);</span><br><span class="line">   <span class="keyword">coverpoint</span>  v&#123;<span class="keyword">bins</span> b1=(<span class="number">3</span>=&gt;<span class="number">4</span>),(<span class="number">4</span>=&gt;<span class="number">5</span>),(<span class="number">5</span>=&gt;<span class="number">6</span>);   </span><br><span class="line">                 <span class="keyword">bins</span> b2=(<span class="number">3</span> =&gt; <span class="number">4</span> =&gt; <span class="number">5</span>);   <span class="comment">//跳转次序为 3-&gt;4-&gt;5，如果没有执行这个次序，则这个bins没有覆盖</span></span><br><span class="line">                 <span class="keyword">bins</span> b3=(<span class="number">1</span>,<span class="number">5</span> =&gt; <span class="number">6</span>,<span class="number">7</span>);   <span class="comment">//(1=&gt;6)、(1=&gt;7)、(5=&gt;6)、(5=&gt;7)</span></span><br><span class="line">                 <span class="keyword">bins</span> b5=(<span class="number">5</span>[*<span class="number">3</span>]);         <span class="comment">//3 consecutive 5's(连续重复，数值5的3次重复连续)</span></span><br><span class="line">                 <span class="keyword">bins</span> b6=(<span class="number">3</span>[*<span class="number">3</span>:<span class="number">5</span>]);       <span class="comment">//(3=&gt;3=&gt;3)、(3=&gt;3=&gt;3=&gt;3)、(3=&gt;3=&gt;3=&gt;3=&gt;3)</span></span><br><span class="line">                 <span class="keyword">bins</span> b7=(<span class="number">4</span>[-&gt;<span class="number">3</span>]=&gt;<span class="number">5</span>);     <span class="comment">//...=&gt;4...=&gt;4...=&gt;4=&gt;5（跟随重复，4出现3次，可以不连续，但在最后一个4出现后，下一个数值为5）</span></span><br><span class="line">                 <span class="keyword">bins</span> b8=(<span class="number">2</span>[=<span class="number">3</span>]=&gt;<span class="number">5</span>);      <span class="comment">//...=&gt;2...=&gt;2...=&gt;2...=&gt;5（非连续重复，数值2出现3次）</span></span><br><span class="line">                 <span class="keyword">bins</span> anothers=default_sequence;</span><br><span class="line">                 &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<p>  除操作符外，还可使用关键词wildcard和通配符?来表示状态和状态跳转</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">wildcard</span> <span class="keyword">bins</span> abc = &#123;<span class="number">2'b1</span>?&#125;;<span class="comment">//覆盖10,11</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">wildcard</span> <span class="keyword">bins</span> abc = (<span class="number">2'b1x</span> =&gt; <span class="number">2'bx0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//覆盖 10=&gt;00 ,10=&gt;10 ,11=&gt;00 ,11=&gt;10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">covergroup</span> address_cov () @ (<span class="keyword">posedge</span> ce);</span><br><span class="line">  ADDRESS : <span class="keyword">coverpoint</span> addr &#123;</span><br><span class="line">    <span class="comment">// Normal transition bibs</span></span><br><span class="line">    <span class="keyword">wildcard</span> <span class="keyword">bins</span> adr0  = &#123;<span class="number">3'b11</span>?&#125;;</span><br><span class="line">    <span class="comment">// We can use wildcard in transition bins also</span></span><br><span class="line">    <span class="keyword">wildcard</span> <span class="keyword">bins</span> adr1  = (<span class="number">3'b1x0</span> =&gt; <span class="number">3'bx00</span>);</span><br><span class="line">    <span class="keyword">wildcard</span> <span class="keyword">bins</span> adr2  = (<span class="number">3'b1</span>?<span class="number">0</span> =&gt; <span class="number">3</span>'b?<span class="number">00</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<h3 id="覆盖点之间的交叉覆盖率——cross"><a href="#覆盖点之间的交叉覆盖率——cross" class="headerlink" title="覆盖点之间的交叉覆盖率——cross"></a>覆盖点之间的交叉覆盖率——cross</h3><p>  交叉覆盖是在覆盖点或变量之间指定的，必须先指定覆盖点，然后通过关键字cross定义<strong>覆盖点之间的交叉覆盖</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过覆盖点来定义交叉覆盖</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line"><span class="keyword">covergroup</span> cg @(<span class="keyword">posedge</span> clk);</span><br><span class="line">  c1: <span class="keyword">coverpoint</span> a;</span><br><span class="line">  c2: <span class="keyword">coverpoint</span> b;</span><br><span class="line">  c1Xc2: <span class="keyword">cross</span> c1,c2;    <span class="comment">//1. 定义交叉覆盖使用关键字cross，利用**覆盖点名字**定义交叉覆盖</span></span><br><span class="line"><span class="keyword">endgroup</span> : cg</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过变量名来定义交叉覆盖</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line"><span class="keyword">covergroup</span> cov @(<span class="keyword">posedge</span> clk);</span><br><span class="line">  aXb : <span class="keyword">cross</span> a, b;      <span class="comment">//2. 定义交叉覆盖使用关键字cross，直接利用**变量名字**定义交叉覆盖</span></span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//交叉覆盖的通用定义格式： </span></span><br><span class="line">交叉覆盖名：<span class="keyword">cross</span> 交叉覆盖点名<span class="number">1</span>，交叉覆盖点名<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>由于上面<strong>每个覆盖点都有16个bin，所以它们的交叉覆盖总共有256（16*16）个交叉积（cross product），也就对应256个bin</strong>。</p>
<h2 id="代码code——约束与覆盖率的运用"><a href="#代码code——约束与覆盖率的运用" class="headerlink" title="代码code——约束与覆盖率的运用"></a>代码code——约束与覆盖率的运用</h2><p>void sample() : Triggers the sampling of covergroup 触发覆盖组的采样<br>real get_coverage() : Calculate coverage number, return value will be 0 to 100 返回覆盖组覆盖率<br>real get_inst_coverage() :Calculate coverage number for given instance, return value will be 0 to 100 返回覆盖组实例的覆盖率<br>void set_inst_name(string) :Set name of the instance with given string 设置实例名<br>void start() :Start collecting coverage 开启覆盖率收集<br>void stop() :Stop collecting coverage 结束收集覆盖率</p>
<h3 id="如何提高覆盖率"><a href="#如何提高覆盖率" class="headerlink" title="如何提高覆盖率"></a>如何提高覆盖率</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] addr;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] addr2;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> addr2 = addr + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">covergroup</span> address_cov;</span><br><span class="line">  ADDRESS : <span class="keyword">coverpoint</span> addr &#123;</span><br><span class="line">    option<span class="variable">.auto_bin_max</span> = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ADDRESS2 : <span class="keyword">coverpoint</span> addr2 &#123;</span><br><span class="line">    option<span class="variable">.auto_bin_max</span> = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"> </span><br><span class="line">address_cov my_cov = <span class="keyword">new</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  my_cov<span class="variable">.ADDRESS</span><span class="variable">.option</span><span class="variable">.at_least</span> = <span class="number">1</span>;</span><br><span class="line">  my_cov<span class="variable">.ADDRESS2</span><span class="variable">.option</span><span class="variable">.at_least</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// start the coverage collection</span></span><br><span class="line">  my_cov<span class="variable">.start</span>();</span><br><span class="line">  <span class="comment">// Set the coverage group name</span></span><br><span class="line">  my_cov<span class="variable">.set_inst_name</span>(<span class="string">"ASIC-WORLD"</span>);</span><br><span class="line">  <span class="built_in">$monitor</span>(<span class="string">"addr 8'h%x addr2 8'h%x"</span>,addr,addr2);</span><br><span class="line">  <span class="keyword">repeat</span> (<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">    addr = $urandom_range(<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="comment">// Sample the covergroup</span></span><br><span class="line">    my_cov<span class="variable">.sample</span>();</span><br><span class="line">    #<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment">// Stop the coverage collection</span></span><br><span class="line">  my_cov<span class="variable">.stop</span>();</span><br><span class="line">  <span class="comment">// Display the coverage</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">"Instance coverage is %e"</span>,my_cov<span class="variable">.get_coverage</span>());</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>通过修改随机化次数——提高覆盖率（覆盖点变量取值范围小）</strong></p>
<p>或者说改变激励的生成和测试次数</p>
<p><strong>通过添加约束constraint、自定义bins——提高覆盖率（覆盖点变量取值范围大）</strong></p>
<p>在<code>自定义bins，而不添加约束constraint</code>的情况下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> cov_demo();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> transaction;</span><br><span class="line">      <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>]  data;        <span class="comment">//2^32种可能</span></span><br><span class="line">      <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">2</span>:<span class="number">0</span>]  port;         <span class="comment">//0~7，一共8种可能</span></span><br><span class="line">  <span class="keyword">endclass</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">covergroup</span> cov_port;</span><br><span class="line">       port_bin : <span class="keyword">coverpoint</span> tr<span class="variable">.port</span>;</span><br><span class="line">       data_bin : <span class="keyword">covergroup</span> tr<span class="variable">.data</span>&#123;</span><br><span class="line">                         <span class="keyword">bins</span> min=&#123;[<span class="number">0</span>:<span class="number">100</span>]&#125;;        <span class="comment">//此时，随机化生成该范围内任意一个数，该bins便被覆盖</span></span><br><span class="line">                         <span class="keyword">bins</span> mid=&#123;[<span class="number">101</span>:<span class="number">9999</span>]&#125;;</span><br><span class="line">                         <span class="keyword">bins</span> max=&#123;[<span class="number">10000</span>:$]&#125;;       <span class="comment">//$—-表示最大的边界</span></span><br><span class="line">                      &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line">     </span><br><span class="line">    transaction    tr=<span class="keyword">new</span>;      <span class="comment">//声明类的句柄，创建对象</span></span><br><span class="line">    cov_port       ck=<span class="keyword">new</span>;      <span class="comment">//声明覆盖组的句柄，创建对象； covergroup和class类似</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">32</span>)<span class="keyword">begin</span>           <span class="comment">//生成得数据包的数量会影响覆盖率，也可以通过添加约束constraint来提升覆盖率，或者自定义bins。</span></span><br><span class="line">            tr<span class="variable">.randomize</span>;        <span class="comment">//随机化生成数据</span></span><br><span class="line">            ck<span class="variable">.sample</span>();         <span class="comment">//搜集覆盖率</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200412130741553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjAyMjQzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /></p>
<p>在<code>自定义bins，并缩小约束constraint</code>范围的情况下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> cov_demo();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> transaction;</span><br><span class="line">      <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>]  data;        <span class="comment">//2^32种可能</span></span><br><span class="line">      <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">2</span>:<span class="number">0</span>]  port;         <span class="comment">//0~7，一共8种可能</span></span><br><span class="line">      <span class="keyword">constraint</span> data_c1&#123;</span><br><span class="line">                    data <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">100</span>],[<span class="number">101</span>:<span class="number">9999</span>],[<span class="number">10000</span>:<span class="number">12000</span>]&#125;;       <span class="comment">//由于data的可能性太多，故对其施加约束</span></span><br><span class="line">                    &#125;</span><br><span class="line">   <span class="keyword">endclass</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">covergroup</span> cov_port;</span><br><span class="line">       port_bin : <span class="keyword">coverpoint</span> tr<span class="variable">.port</span>;</span><br><span class="line">       data_bin : <span class="keyword">covergroup</span> tr<span class="variable">.data</span>&#123;</span><br><span class="line">                         <span class="keyword">bins</span> min=&#123;[<span class="number">0</span>:<span class="number">100</span>]&#125;;        <span class="comment">//此时，随机化生成该范围内任意一个数，该bins便被覆盖</span></span><br><span class="line">                         <span class="keyword">bins</span> mid=&#123;[<span class="number">101</span>:<span class="number">9999</span>]&#125;;</span><br><span class="line">                         <span class="keyword">bins</span> max=&#123;[<span class="number">10000</span>:$]&#125;;       <span class="comment">//$—-表示最大的边界</span></span><br><span class="line">                      &#125;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line">     </span><br><span class="line">    transaction    tr=<span class="keyword">new</span>;      <span class="comment">//声明类的句柄，创建对象</span></span><br><span class="line">    cov_port       ck=<span class="keyword">new</span>;      <span class="comment">//声明覆盖组的句柄，创建对象； covergroup和class类似</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">32</span>)<span class="keyword">begin</span>           <span class="comment">//生成得数据包的数量会影响覆盖率，也可以通过添加约束constraint来提升覆盖率，或者自定义bins。</span></span><br><span class="line">            tr<span class="variable">.randomize</span>;        <span class="comment">//随机化生成数据</span></span><br><span class="line">            ck<span class="variable">.sample</span>();         <span class="comment">//搜集覆盖率</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200412132631177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjAyMjQzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>通过权重dist——调整hit次数分布</strong></p>
<p>将代码中的constraint约束调整为权重dist处理后，其各个bins的hit次数分布更加均匀，如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constraint</span> data_c1&#123;</span><br><span class="line">    data <span class="keyword">dist</span> &#123;[<span class="number">0</span>:<span class="number">100</span>]:/ <span class="number">100</span>, [<span class="number">101</span>:<span class="number">9999</span>]:/ <span class="number">100</span>, [<span class="number">10000</span>:<span class="number">12000</span>]:/ <span class="number">120</span>&#125;;      </span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p><a href="https://www.cnblogs.com/pcc-uvm/p/14771685.html" target="_blank" rel="noopener">https://www.cnblogs.com/pcc-uvm/p/14771685.html</a></p>
<p>断言的理解：断言更像是对信号的一个要求，不满足就不行！</p>
<p>断言被用来：</p>
<p>（1）检查特定条件或事件序列的发生；</p>
<p>（2）提供功能覆盖（functional coverage），使用 <strong>cover</strong> 关键字 ；</p>
<p>存在两种断言：立即断言和并发断言；</p>
<h2 id="1-立即断言-if"><a href="#1-立即断言-if" class="headerlink" title="1. 立即断言=~if"></a>1. 立即断言=~if</h2><p>立即断言在当前仿真时间检查条件，类似于if…else语句，但是断言带有控制.立即断言必须放在过程块定义中.</p>
<p>当断言带了else 语句，则失败后进入else；没带else语句，失败后直接执行$error</p>
<p>失败后的错误信息：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“test<span class="variable">.sv</span>”, <span class="number">7</span>: top<span class="variable">.t1</span><span class="variable">.a1</span>: started at <span class="number">55</span>ns failed at <span class="number">55</span>ns</span><br><span class="line"><span class="comment">//显示和断言定义相违背</span></span><br><span class="line">offending '(bus<span class="variable">.cbb</span><span class="variable">.grant</span> == <span class="number">2'b1</span>)'</span><br></pre></td></tr></table></figure>
<p>下面展示一个简单的断言：</p>
<p><img src="https://img-blog.csdnimg.cn/20190823204638126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsZWF1Y2hhdA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" /></p>
<p>断言格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(condition) </span><br><span class="line"><span class="built_in">$display</span>(“Condition is True”); </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">$display</span>(“Condition is False”);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span>(condition) </span><br><span class="line"><span class="built_in">$display</span>(“Condition is True”);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span>(condition) </span><br><span class="line">$(“Condition is True”); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">$fatal</span>(“Condition is False”);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span>(condition)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">     …….</span><br><span class="line">     …….</span><br><span class="line">    <span class="built_in">$fatal</span>(“Condition is False”);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span>(condition) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">$warning</span>(“Condition is False”);</span><br><span class="line"><span class="comment">//推荐使用的格式 </span></span><br><span class="line">label: <span class="keyword">assert</span>(condition) </span><br><span class="line">$(“Condition is True”); </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">$warning</span>(“Condition is False”);</span><br></pre></td></tr></table></figure>
<p><strong>如果断言失败，并且没有指定任何其他else子句，则默认情况下，该工具将调用$error</strong></p>
<h2 id="2-定制断言"><a href="#2-定制断言" class="headerlink" title="2. 定制断言"></a>2. 定制断言</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1: <span class="keyword">assert</span>(bus<span class="variable">.cb</span><span class="variable">.grant</span>==<span class="number">2'b01</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">$error</span>(<span class="string">"Grant noe asserted"</span>);</span><br></pre></td></tr></table></figure>
<p>4个在断言中输出消息的函数：</p>
<ul>
<li>$info</li>
<li>$warning</li>
<li>$error</li>
<li>$fatal</li>
</ul>
<h2 id="3-并发断言-Concurrent-Assertions-edge采样"><a href="#3-并发断言-Concurrent-Assertions-edge采样" class="headerlink" title="3. 并发断言  Concurrent Assertions(edge采样)"></a>3. 并发断言  Concurrent Assertions(edge采样)</h2><p><strong>与时序相关，常用</strong></p>
<p>并发断言可以认为是一个连续运行的模块，为整个仿真过程检查信号，所以需要在并发断言内指定一个采样时钟。</p>
<p>需要指出的是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">并发断言只有在时钟沿才会执行；</span><br><span class="line"></span><br><span class="line">可以在过程块、<span class="keyword">module</span>、<span class="keyword">interface</span>和<span class="keyword">program</span>块内定义并发断言；</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c_assert:  <span class="keyword">assert</span> <span class="keyword">property</span>(@(<span class="keyword">posedge</span> clk) <span class="keyword">not</span>(a &amp;&amp; b));</span><br><span class="line"><span class="comment">//下面为通用格式</span></span><br><span class="line"> </span><br><span class="line">断言名：<span class="keyword">assert</span> <span class="keyword">property</span> (判断条件);</span><br></pre></td></tr></table></figure>
<p>实例：request信号除了在复位期间，其他任何时候都不能是X或者Z</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> arc_if(<span class="keyword">input</span> <span class="keyword">bit</span> clk);</span><br><span class="line">    <span class="keyword">logic</span>[<span class="number">1</span>:<span class="number">0</span>] grant, request;</span><br><span class="line">    <span class="keyword">logic</span> rst;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">property</span> request_2state;</span><br><span class="line">        @(poseedge clk) <span class="keyword">disable</span> <span class="keyword">iff</span> (rst);</span><br><span class="line">        <span class="built_in">$isunknown</span>(request) == <span class="number">0</span>;<span class="comment">//确保没有z或x存在</span></span><br><span class="line">    <span class="keyword">endproperty</span></span><br><span class="line">    assert_request: <span class="keyword">assert</span> <span class="keyword">property</span>(request_2state);</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>
<p>通用格式：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c_assert:  <span class="keyword">assert</span> <span class="keyword">property</span>(@(<span class="keyword">posedge</span> clk) <span class="keyword">not</span>(a &amp;&amp; b));</span><br><span class="line"><span class="comment">//下面为通用格式</span></span><br><span class="line"> </span><br><span class="line">断言名：<span class="keyword">assert</span> <span class="keyword">property</span> (判断条件);</span><br></pre></td></tr></table></figure>
<h2 id="4-iff的使用"><a href="#4-iff的使用" class="headerlink" title="4. iff的使用"></a>4. iff的使用</h2><p>屏蔽不定态：</p>
<p>  当信号被断言时，如果信号是未复位的不定态，不管怎么断言，都会报告：“断言失败”，为了在不定态不报告问题，在断言时可以屏蔽。</p>
<p>  如： </p>
<p>​    <code>@(posedge clk) (q == $past(d))</code>，当未复位时报错，屏蔽方法是将该句改写为：</p>
<p>​     <code>@(posedge clk) disable iff (!rst_n) (q == $past(d))</code> //rst是低电平有效</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E5%AD%97IC/" rel="tag"># 数字IC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/08/%E7%AE%97%E6%B3%95-%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/" rel="next" title="算法题整理">
                <i class="fa fa-chevron-left"></i> 算法题整理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/16/IC%E9%AA%8C%E8%AF%81-UVM/" rel="prev" title="UVM">
                UVM <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="xujunjie'blog" />
            
              <p class="site-author-name" itemprop="name">xujunjie'blog</p>
              <p class="site-description motion-element" itemprop="description">使一个人有限的生命更加有效也即等于延长了人的生命</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础"><span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语法-数据类型"><span class="nav-text">语法-数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用typedef创建新的类型"><span class="nav-text">使用typedef创建新的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型转换"><span class="nav-text">类型转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举类型"><span class="nav-text">枚举类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举类型的方法"><span class="nav-text">枚举类型的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符"><span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定宽数组"><span class="nav-text">定宽数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#合并数组"><span class="nav-text">合并数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非合并数组"><span class="nav-text">非合并数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常量数组"><span class="nav-text">常量数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组遍历（for、foreach）"><span class="nav-text">数组遍历（for、foreach）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态数组（new）"><span class="nav-text">动态数组（new）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列"><span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联数组"><span class="nav-text">关联数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组方法"><span class="nav-text">数组方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缩减方法"><span class="nav-text">缩减方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组定位方法"><span class="nav-text">数组定位方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的排序"><span class="nav-text">数组的排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量生命周期"><span class="nav-text">变量生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不同位置变量的默认生命周期"><span class="nav-text">不同位置变量的默认生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过程语句和子程序"><span class="nav-text">过程语句和子程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过程语句"><span class="nav-text">过程语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function和task"><span class="nav-text">function和task</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值问题："><span class="nav-text">返回值问题：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传入参数："><span class="nav-text">传入参数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ref专题"><span class="nav-text">ref专题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参数默认值"><span class="nav-text">参数默认值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口interface"><span class="nav-text">接口interface</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#modport"><span class="nav-text">modport</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#激励时序"><span class="nav-text">激励时序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#时钟块"><span class="nav-text">时钟块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#竞争问题实例"><span class="nav-text">竞争问题实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#竞争问题的理解"><span class="nav-text">竞争问题的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#竞争问题的解决"><span class="nav-text">竞争问题的解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时钟块怎么用"><span class="nav-text">时钟块怎么用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例："><span class="nav-text">实例：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论"><span class="nav-text">结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类和包的使用"><span class="nav-text">类和包的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象"><span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包的使用"><span class="nav-text">包的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换-1"><span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-静态转换"><span class="nav-text">1.静态转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-动态转换"><span class="nav-text">2.动态转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-显式和隐式转换"><span class="nav-text">3.显式和隐式转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数（virtual）"><span class="nav-text">虚函数（virtual）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-virtual-interface"><span class="nav-text">1. virtual interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-virtual-task-function"><span class="nav-text">2. virtual task&#x2F;function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-virtual-class"><span class="nav-text">3. virtual class</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象拷贝"><span class="nav-text">对象拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-浅拷贝"><span class="nav-text">1. 浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-自定义拷贝"><span class="nav-text">2. 自定义拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实验进化2"><span class="nav-text">实验进化2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#interface的提取"><span class="nav-text">interface的提取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#generator的提取"><span class="nav-text">generator的提取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将interface和generator的module按照需要进行实例化"><span class="nav-text">将interface和generator的module按照需要进行实例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#test的module"><span class="nav-text">test的module</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#随机"><span class="nav-text">随机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-随机约束和分布"><span class="nav-text">1. 随机约束和分布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#约束"><span class="nav-text">约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-约束块控制"><span class="nav-text">2. 约束块控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#constraint-mode"><span class="nav-text">constraint_mode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rand-mode"><span class="nav-text">rand_mode()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-随机函数"><span class="nav-text">3. 随机函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-数组的约束"><span class="nav-text">4. 数组的约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#randc并不能让数组的每个元素随机化时不重复"><span class="nav-text">randc并不能让数组的每个元素随机化时不重复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机化句柄数组"><span class="nav-text">随机化句柄数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-随机控制"><span class="nav-text">5. 随机控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成随机序列"><span class="nav-text">生成随机序列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程"><span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程控制"><span class="nav-text">线程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程通信"><span class="nav-text">线程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#event"><span class="nav-text">event</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#triggered"><span class="nav-text">triggered()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和triggered-的使用时机"><span class="nav-text">@和triggered()的使用时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旗语（semaphore）"><span class="nav-text">旗语（semaphore）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mailbox"><span class="nav-text">mailbox</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#覆盖率"><span class="nav-text">覆盖率</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#覆盖组——covergroup"><span class="nav-text">覆盖组——covergroup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#覆盖点——coverpoint"><span class="nav-text">覆盖点——coverpoint</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#盖点元素——隐式bin与显式bins"><span class="nav-text">盖点元素——隐式bin与显式bins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖点的状态跳转——-gt-与-通配符"><span class="nav-text">覆盖点的状态跳转——&#x3D;&gt; 与 ?通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖点之间的交叉覆盖率——cross"><span class="nav-text">覆盖点之间的交叉覆盖率——cross</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码code——约束与覆盖率的运用"><span class="nav-text">代码code——约束与覆盖率的运用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何提高覆盖率"><span class="nav-text">如何提高覆盖率</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#断言"><span class="nav-text">断言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-立即断言-if"><span class="nav-text">1. 立即断言&#x3D;~if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-定制断言"><span class="nav-text">2. 定制断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-并发断言-Concurrent-Assertions-edge采样"><span class="nav-text">3. 并发断言  Concurrent Assertions(edge采样)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-iff的使用"><span class="nav-text">4. iff的使用</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xujunjie'blog</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>


  
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
