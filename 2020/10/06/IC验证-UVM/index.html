<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数字IC," />










<meta name="description" content="对UVM的初步理解就是类似于java的spring框架，是编程的方法论并为编程人员制定规则，让编程更加规范 类库：verificationacademy.com&#x2F;verification-methodology-reference&#x2F;uvm&#x2F;docs_1.2&#x2F;html&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="UVM">
<meta property="og:url" content="http://yoursite.com/2020/10/06/IC%E9%AA%8C%E8%AF%81-UVM/index.html">
<meta property="og:site_name" content="悦来客栈">
<meta property="og:description" content="对UVM的初步理解就是类似于java的spring框架，是编程的方法论并为编程人员制定规则，让编程更加规范 类库：verificationacademy.com&#x2F;verification-methodology-reference&#x2F;uvm&#x2F;docs_1.2&#x2F;html&#x2F;">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210712122518.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210712123146.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210712123250.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180821192216319?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzk0MTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716184035.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716183843.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716185653.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210725110050.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210725110135.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180821211122139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzk0MTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716194839.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180821212109982?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzk0MTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716203559.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210726110415.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716220512.png">
<meta property="og:image" content="c:/Users/biongd/AppData/Roaming/Typora/typora-user-images/image-20210725203703986.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210725204216.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210725204218.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210725204546.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210725210258.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210725205704.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210725205119.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210725204210.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210221214124358.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210726162156.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210726162609.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210226133436861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021022613390724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021022613453933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210226135622150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210226140149514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210226145501404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210226164155795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210226165136819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210726200820.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716224448.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210227145215296.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716225157.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716225726.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716230533.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210716233058.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210227183607828.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210227185450915.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210227190542609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202102271936515.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021022719531516.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210727103843.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210227204205519.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210227205409946.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210227210405157.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210301151700264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210301173241577.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210301204714102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021030215312947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210728194621.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210302160513364.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210302163325244.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210302202419345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210304194622343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210304202309412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210728213509.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210305144035371.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210305144754918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210305145852301.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021030515125374.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210729164055.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210729193421.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210305203720293.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210729205101.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210729210221.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20210729210130.png">
<meta property="article:published_time" content="2020-10-06T06:25:30.000Z">
<meta property="article:modified_time" content="2021-07-29T15:01:25.337Z">
<meta property="article:author" content="xujunjie&#39;blog">
<meta property="article:tag" content="数字IC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/biongd/img/raw/master/img/20210712122518.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","display_updated":true,"offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/10/06/IC验证-UVM/"/>





  <title>UVM | 悦来客栈</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">悦来客栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">learn and better</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/06/IC%E9%AA%8C%E8%AF%81-UVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xujunjie'blog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="悦来客栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UVM</h1>
        

        <div class="post-meta">
          <span class="post-time">
              
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-06T14:25:30+08:00">
                2020-10-06
              </time>
            
            
                <span class="post-updated">
                     &nbsp; | &nbsp; 更新于
                     <time itemprop="dateUpdated" datetime="2021-07-29T23:01:25+08:00" content="2021-07-29">
                          2021-07-29
                     </time>
                 </span>
             

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%97-SystemVerilog-verilog%E5%9F%BA%E7%A1%80-mcdf%E5%AE%9E%E9%AA%8C-UVM/" itemprop="url" rel="index">
                    <span itemprop="name">数字-SystemVerilog.verilog基础.mcdf实验.UVM.</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对UVM的初步理解就是类似于java的spring框架，是编程的方法论并为编程人员制定规则，让编程更加规范</p>
<p>类库：verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</p>
 <a id="more"></a>
<h1 id="1-UVM概念"><a href="#1-UVM概念" class="headerlink" title="1. UVM概念"></a>1. UVM概念</h1><ul>
<li>UVM就一种验证方法学而言，它的思想却并不是必须要与某一种语言绑定的。因此，UVM的验证方法学通过吸取eRM、AVM、OVM、UVM等之前不同方法学的优点，集众家之所长。</li>
<li>所有的验证方法学服务目的都在于提供一些可以重用的类来减轻在项目之间水平复用和垂直复用的工作量，而同时对于验证新人又能提供一套可靠的框架，摆脱搭建房子构思图纸的苦恼。</li>
<li>UVM面向所有数字设计，涵盖了从模块级到芯片级，ASIC到FPGA，以及控制逻辑、数据通路到处理器验证的全部场景。</li>
<li>UVM中的Universal(通用)的含义代表的是该方法学可以适用于大多数的验证项目，而它自身提供的基础类库(basic class library)和基本验证结构可以让具有不同软件编程经验的验证人员能够快速构建起一个结构可靠的验证框架。</li>
<li>UVM的框架构建类和测试类能够减轻环境构建的负担，进而将更多的精力集中在如何制定验证计划和创建测试场景。<br>UVM框架，包括UVM的类库和核心机制、核心的UVM组件和层次构建方式、常见的UVM组件间的通信方式、UVM测试场景的构成、UVM的寄存器模型应用。</li>
</ul>
<h2 id="UVM类库地图"><a href="#UVM类库地图" class="headerlink" title="UVM类库地图"></a>UVM类库地图</h2><p>类库网址：<a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/" target="_blank" rel="noopener">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/</a></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210712122518.png" alt="image-20210712122518431" style="zoom:150%;" /></p>
<p><strong>10大类型：</strong></p>
<ul>
<li><p>核心基类</p>
<p>克隆，打印等方法都已经进行了封装</p>
</li>
<li><p>工厂（factory）类</p>
</li>
<li><p>事务（transaction）和序列（sequence）类</p>
<p>trans的有序组合——序列</p>
</li>
<li><p>结构创建（struct creation）类</p>
</li>
<li><p>环境组件（environment component）类</p>
<p>driver，monitor，generator，checker等</p>
</li>
<li><p>通信管道（channel）类</p>
<p>mailbox</p>
</li>
<li><p>信息报告（message report）类</p>
<p>为什么不用$display()?</p>
</li>
<li><p>寄存器模型（register model）类</p>
</li>
<li><p>线程同步（thread synchronizetion）类</p>
<p>event，旗语等</p>
</li>
<li><p>事务接口（transaction interface）类</p>
</li>
</ul>
<h2 id="UVM组件"><a href="#UVM组件" class="headerlink" title="UVM组件"></a>UVM组件</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210712123146.png" alt="image-20210712123146758"></p>
<p>sequencer：承担了generator发送激励的功能，产生激励的部分在架构图中已经看不到了，属于动态部分sequence</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210712123250.png" alt="image-20210712123250858"></p>
<h2 id="UVM环境-phase机制"><a href="#UVM环境-phase机制" class="headerlink" title="UVM环境-phase机制"></a>UVM环境-phase机制</h2><p>硬件：仿真开始前，已经完成了实例化和连接</p>
<p>软件：运行时动态加载对象，并生成连接</p>
<p>多层嵌套的组件，需要在上层次中创建对象和建立连接（monitor和checker）</p>
<p>UVM验证环境是按照UVM_PHASE有序执行的，UVM_PHASE按照是否消耗时间分为function_phase和task_phase.function_phase如build_phase、connect_phase，这些phase是不消耗时间的；task_phase如main_phase、reset_phase这些phase是消耗时间的.</p>
<p>1.function_phase介绍</p>
<p>在function_phase中build_phase实现实例化工作，主要是对uvm_component及其派生类的实例化；connect_phase用来完成诸如port的链接这些动作；</p>
<p>end_of_elaborattion_phase、start_of_simulation_phase不常用，不过也可以根据平台的需要做一些预处理的动作；</p>
<p>report_phase主要在结束时对DUT和RM状态做一下检查；涉及到读取寄存器状态，需要在task_phase中检查.</p>
<p>2.function_phase顺序</p>
<p>build_phase是自顶而下的执行顺序，即从uvm_test_top开始执行，进而到uvm_env、uvm_rm的build_phase；其他function_phase正好相反，是自下而上的执行顺序.</p>
<h2 id="工厂机制"><a href="#工厂机制" class="headerlink" title="工厂机制"></a>工厂机制</h2><p>从设计模式出发就很好理解了，通过工厂类中的生成方法制造需要类型的对象！！</p>
<ul>
<li>UVM中创建的任何一个类都需要工厂注册</li>
<li>注册的两大类型：UVM_component和UVM_object(10大类型里面除了port类外，全都由这两个类制造)<ul>
<li>component：常见组件：不动产，构建验证环境</li>
<li>object：非固定资产，如trans类，帮助实现验证场景，可以动态产生</li>
</ul>
</li>
</ul>
<p>范式：</p>
<ul>
<li>UVM里任何一个组件类都需要注册</li>
<li>构造方法，new函数的参数固定</li>
<li>利用new（）方法创建对象：可以在构造方法中执行，也可以放在build_phase中</li>
<li>工厂机制创建对象：只能在build_phase中执行，因为倘若进行类型覆盖，类型转换就是在new的时候发生，如果直接在new中进行type_id的创建，那覆盖方法将毫无意义！！</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span> uvm_object类型:</span><br><span class="line">   <span class="keyword">class</span> obj <span class="keyword">extends</span> uvm_object;</span><br><span class="line">   <span class="meta">`uvm_object_utlis(obj)</span></span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="number">'ob</span>j');</span><br><span class="line">   	 <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">   	 <span class="built_in">$display</span>($sfortmatf(<span class="string">"%s is ceated"</span>,name));</span><br><span class="line">  <span class="keyword">endfunction</span>：<span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">例<span class="number">2</span> uvm_componet类型：</span><br><span class="line">    <span class="keyword">class</span> comp <span class="keyword">extends</span> uvm_componet;</span><br><span class="line">   <span class="meta">`uvm_componet_utlis(comp)</span></span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name='comp'，uvm_componet parent=<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name,parent);</span><br><span class="line">    <span class="built_in">$display</span>($sfortmatf(<span class="string">"%s is ceated"</span>,name));</span><br><span class="line">    <span class="keyword">endfunction</span>：<span class="keyword">new</span></span><br><span class="line"> 注：</span><br><span class="line"> <span class="number">1</span>.  以上两个代码的注册宏和<span class="keyword">new</span>()函数是范式，结构和参数都不可更改。</span><br><span class="line"> <span class="number">2</span>.  注意两者的注册宏的区别</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂和new创建对象的区别</span></span><br><span class="line">comp1 c1, c2;</span><br><span class="line">obj1 o1, o2;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    c1 = <span class="keyword">new</span>(<span class="string">"c1"</span>);</span><br><span class="line">    o1 = <span class="keyword">new</span>(<span class="string">"o1"</span>);</span><br><span class="line">    c2 = comp1::type_id::create(<span class="string">"c2"</span>, <span class="literal">null</span>);</span><br><span class="line">    o2 = obj1::type_id::create(<span class="string">"o2"</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>问：factory是独有的，有且只有一个，这保证了所有的component的注册都在一个“机构”中。那么，在上面代码以及读者构写的代码中，并没有主动出现factory例化代码，这个factory何时被例化，而隐藏在哪里呢？</p>
<p>component和object虽然在创建时都需要传递create(name, parent)，但是最终创建出来的component是会表示在UVM层次结构中的UVM的核心机制都浓缩在了一个类uvm_coreservice_t，该类内置了UVM世界核心机制的组件和方法，它们主要包括了：</p>
<ul>
<li>唯一的uvm_factory，该组件用来注册、覆盖和例化。</li>
<li>全局的report_server，该组件用来做消息统筹和报告。</li>
<li>全局的tr_database，该组件用来记录transaction记录。</li>
<li>get_root()方法用来返回当前UVM环境的结构顶层对象。</li>
</ul>
</blockquote>
<p>因此，如果在仿真器中寻找这个隐藏的核心服务组件对象，可以先搜寻类uvm_coreservice_t，再在其内部搜寻局部静态变量uvm_coreservice_t::inst。找到之后，进一步展开，就可以发现其其内部的几个主要组件实例factory、report_server、tr_database。无论是对于uvm_coreservice_t::inst，还是uvm_default_coreservice_t的成员变量factory、report_server等，都遵循一个原则，即如果被“需要”，那么会例化只且例化一次。</p>
<p>在上面的简单例码中，由于两个宏<code>define uvm_component_utils(T)和</code>define  uvm_object_utils(T)需要uvm_coreservie_t::inst，所以在仿真开始后，可以从仿真器的对象浏览窗口中看到下面的对象关系图。该图从Synopsys VCS  ‘object’窗口中截取，而今后用来表示对象关系、UVM结构等层次关系的图时，我们也将从VCS工具中截取示例说明。需要额外补充一点的是，之前的SV核心篇章的实例仿真均是在MentorGraphics QuestaSim中进行的，而到了UVM核心篇章的实例仿真均在Synopsys VCS仿真器中进行</p>
<p>在下面这个对象图中，有4列，从左至右分别是层次、类型、对象ID和对象创建时间。对于对象ID和对象创建时间，我们可以从下图的对象中看到，已经被创建的对象均是在0时刻创建的，而且都是它们对应类型的第一个实例（用@1表示，也应该是唯一一个）。</p>
<p><img src="https://img-blog.csdn.net/20180821192216319?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzk0MTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>了解了UVM核心机制组件的建立，我们来继续分解上面的宏<code>define uvm_component_utils(T)和</code>define uvm_object_utils(T)。</p>
<p>这里，以uvm_component_utils(T)为例，其注册的机制发生在该宏的进一步拆解中：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> m_uvm_component_registry_internal(T,S) \</span></span><br><span class="line"><span class="keyword">typedef</span> uvm_component_registry <span class="variable">#(T,`"S`")</span> type_id; \</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">function</span> type_id get_type(); \</span><br><span class="line"><span class="keyword">return</span> type_id::get(); \</span><br><span class="line"><span class="keyword">endfunction</span> \</span><br><span class="line"> </span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">function</span> uvm_object_wrapper get_object_type(); \</span><br><span class="line"><span class="keyword">return</span> type_id::get(); \</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p>component和object虽然在创建时都需要传递create(name, parent)，但是最终创建出来的component是会表示在UVM层次结构中的，而object则不会显示在层次当中。</p>
<ul>
<li><p>uvm_component::new(name, parent)</p>
<p>保留两个参数，且缺一不可就是为了通过类似“钩子”的做法，一层层由底层勾住上一层，这样就能够将整个UVM结构串接起来了。（如agent和driver、monitor）</p>
</li>
<li><p>uvm_object::new(name)则没有parent参数，因此也不会显示在UVM层次中，也只能作为configuration或者transaction等用来做传递的配置结构体或者抽象数据传输的数据结构体，成为uvm_component的成员变量。</p>
</li>
</ul>
<p><strong>注意：</strong>虽然在实际的uvm_default_factory中，它用来注册所有uvm_component和uvm_object的词典只有一个，但是用来覆盖层次中类型的方式却有不止一种。在上面的图中我们将这些可能用来覆盖的类，抽象到一个词典中为了方便简化注册、创建和覆盖的关系。</p>
<p>在注册过程中，我们通过uvm_component_registry或者uvm_object_registry（均继承与uvm_object_wrapper）来分别注册uvm_component和uvm_object。上面的例子以uvm_component_registry来说明，对于这样一种专门用来注册的类而言，它们自身的方法是专门为配合factory的注册、创建和覆盖而生的，这些方法分别是</p>
<ul>
<li>create()</li>
<li>create_component()</li>
<li>get()</li>
<li>get_type_name()</li>
<li>set_inst_override()</li>
<li>set_type_override()</li>
</ul>
<p>我们如果要通过factory来创建对象时，可以使用的方法有：</p>
<ul>
<li>create_component_by_name()</li>
<li>create_component_by_type()</li>
<li>create_object_by_name()</li>
<li>create_object_by_type()</li>
</ul>
<h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>从上面的UVM类型的注册到对象的创建，读者知道了利用factory中注册号的类型，可以通过类型T（类型“箱子”）或者类型名Tname（字符串）来进行。与之类似的，factory也提供了覆盖（override）的特性，用户也可以通过类型覆盖或者实例名覆盖两种方式进行</p>
<p>覆盖后，创建原始类型的请求就可以用来创建新的类型！！</p>
<ul>
<li>无需修改原始代码，保证源代码的封装性</li>
<li>新类型必须与原始类型相兼容</li>
</ul>
<p>使用覆盖的条件：</p>
<ul>
<li><p>原有类型和新类型都需要注册</p>
</li>
<li><p>使用create（）来创建对象时</p>
</li>
<li><p>覆盖一定要发生在实例化之前，否则将毫无意义~</p>
<p>工厂检查是否原有类型被覆盖，如果是，创建新类型，否则创建原有类型</p>
<p>● set_inst_override(uvm_object_wrapper override_type, string inst_path)：实例覆盖，部分UVM对象被覆盖</p>
</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210716184035.png" alt="image-20210716184035535" style="zoom:67%;" /></p>
<p> ● set_type_override(uvm_object_wrapper override_type，bit r)：类型覆盖，UVM结构层面的替换</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210716183843.png" alt="image-20210716183836221" style="zoom:67%;" /></p>
<p>以类型覆盖的方法为例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> factory_override;</span><br><span class="line">  <span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line">  <span class="meta">`<span class="meta-keyword">include</span> "uvm_macros.svh"</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">class</span> comp1 <span class="keyword">extends</span> uvm_component;</span><br><span class="line">    <span class="meta">`uvm_component_utils(comp1)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="string">"comp1"</span>, uvm_component parent=<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">      <span class="built_in">$display</span>(<span class="built_in">$sformatf</span>(<span class="string">"comp1:: %s is created"</span>, name));</span><br><span class="line">    <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> hello(<span class="keyword">string</span> name);</span><br><span class="line">      <span class="built_in">$display</span>(<span class="built_in">$sformatf</span>(<span class="string">"comp1:: %s said hello!"</span>, name));</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">class</span> comp2 <span class="keyword">extends</span> comp1;</span><br><span class="line">    <span class="meta">`uvm_component_utils(comp2)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="string">"comp2"</span>, uvm_component parent=<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">      <span class="built_in">$display</span>(<span class="built_in">$sformatf</span>(<span class="string">"comp2:: %s is created"</span>, name));</span><br><span class="line">    <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> hello(<span class="keyword">string</span> name);</span><br><span class="line">      <span class="built_in">$display</span>(<span class="built_in">$sformatf</span>(<span class="string">"comp2:: %s said hello!"</span>, name));</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line">  comp1 c1, c2;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    comp1::type_id::set_type_override(comp2::get_type());</span><br><span class="line">    c1 = <span class="keyword">new</span>(<span class="string">"c1"</span>);</span><br><span class="line">    c2 = comp1::type_id::create(<span class="string">"c2"</span>, <span class="literal">null</span>);</span><br><span class="line">    c1<span class="variable">.hello</span>(<span class="string">"c1"</span>);</span><br><span class="line">    c2<span class="variable">.hello</span>(<span class="string">"c2"</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">comp1:: c1 is created</span><br><span class="line">comp1:: c2 is created</span><br><span class="line">comp2:: c2 is created</span><br><span class="line">comp1:: c1 said hello!</span><br><span class="line">comp2:: c2 said hello!</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210716185653.png" alt="image-20210716185653552" style="zoom:67%;" /></p>
<p>注意：多级组件对同一类型进行覆盖，高层次的组件的优先级更高！</p>
<h1 id="2-核心基类UVM-object"><a href="#2-核心基类UVM-object" class="headerlink" title="2. 核心基类UVM-object"></a>2. 核心基类UVM-object</h1><h2 id="域的自动化-（Field-Automation）"><a href="#域的自动化-（Field-Automation）" class="headerlink" title="域的自动化 （Field Automation）"></a>域的自动化 （Field Automation）</h2><p>UVM通过一些域的自动化，<strong>使得用户在注册UVM类的同时也可以声明今后会参与到对象拷贝、克隆、打印等等操作的成员变量</strong>。仍然是上面的例子，我们来看看通过UVM与域的自动化相关的宏，如何简化了对象的拷贝。</p>
<p>比如在SV中使用的trans的clone方法，checker的compare方法等，都可以通过这种方式进行替换，同时也要增加对UVM的配置</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> object_copy;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "uvm_macros.svh"</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED, WHITE, BLACK&#125; color_t;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> box <span class="keyword">extends</span> uvm_object;</span><br><span class="line"><span class="keyword">int</span> volume = <span class="number">120</span>;</span><br><span class="line">color_t color = WHITE;</span><br><span class="line"><span class="keyword">string</span> name = <span class="string">"box"</span>;</span><br><span class="line"><span class="meta">`uvm_object_utils_begin(box)</span></span><br><span class="line"><span class="meta">`uvm_field_int(volume, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_field_enum(color_t, color, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_field_string(name, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_object_utils_end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="string">"box"</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">    <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line">box b1, b2;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">b1 = <span class="keyword">new</span>(<span class="string">"box1"</span>);</span><br><span class="line">b1<span class="variable">.volume</span> = <span class="number">80</span>;</span><br><span class="line">b1<span class="variable">.color</span> = BLACK;</span><br><span class="line">b2 = <span class="keyword">new</span>();</span><br><span class="line">b2<span class="variable">.copy</span>(b1);</span><br><span class="line">b2<span class="variable">.name</span> = <span class="string">"box2"</span>;</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">"%s"</span>, b1<span class="variable">.sprint</span>());</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">"%s"</span>, b2<span class="variable">.sprint</span>());</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------</span><br><span class="line">Name Type Size Value</span><br><span class="line">-------------------------------</span><br><span class="line">box1 box - @<span class="number">336</span></span><br><span class="line">volume integral <span class="number">32</span> <span class="number">'h50</span></span><br><span class="line">color color_t <span class="number">32</span> BLACK</span><br><span class="line">name <span class="keyword">string</span> <span class="number">4</span> box1</span><br><span class="line">-------------------------------</span><br><span class="line">-------------------------------</span><br><span class="line">Name Type Size Value</span><br><span class="line">-------------------------------</span><br><span class="line">box box - @<span class="number">337</span></span><br><span class="line">volume integral <span class="number">32</span> <span class="number">'h50</span></span><br><span class="line">color color_t <span class="number">32</span> BLACK</span><br><span class="line">name <span class="keyword">string</span> <span class="number">4</span> box2</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>从uvm_object提供的方法和相关的宏操作来看，它的核心方法主要提供与数据操作的相关服务：</p>
<ul>
<li><p>Copy：深拷贝</p>
<p>对于实例中的句柄成员变量，在拷贝时会额外创建新的对象！！！这就是深拷贝</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210725110050.png" alt="image-20210725110049980" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210725110135.png" alt="image-20210725110134950" style="zoom:67%;" /></p>
<ul>
<li><p>代码中省略了box的new方法中对ball的实例创建，在执行copy方法时，b2对b1进行深拷贝，意味着对ball实例也进行了copy，且可以看到b2中的ball实例和b1的ball不是同一个实例</p>
</li>
<li><p>ball类型的内部同样进行了域自动化，这意味着ball的copy同样遵循域自动化的规则！！！那为啥两个b的diameter和color不一样呢？</p>
<p>因为color的域声明为NOCOPY，所以不对其进行赋值；给copy配置了一个回调函数do_copy，即在执行copy后还会执行do_copy，此时篡改了diameter的值</p>
</li>
</ul>
</li>
<li><p>Clone</p>
</li>
<li><p>Compare</p>
<p>将每一个自动化的域进行比较，一旦失败立即返回（0），后续变量不再比较</p>
<p><code>uvm_default_comparer</code>(<code>uvm_comparer</code>类型)是默认的UVM全局比较器，默认最大错误输出信息是1，即当比较错误信息时，立刻返回</p>
<p>show_max可以设置最大比较结果</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvm_default_comparer<span class="variable">.show_max</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Print</p>
</li>
<li><p>Pack/Unpack</p>
</li>
</ul>
<h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>在uvm_object使用到的方法compare()、print()和pack()，如果没有数据操作配置对象作为参数时，即会使用在uvm_pkg中例化的全局成员。在这里，我们可以从下面的图中看到，在uvm_pkg中例化了不少对象，而在本节中我们会使用到的全局配置包括有：</p>
<ul>
<li>uvm_default_comparer</li>
<li>uvm_default_printer</li>
<li>uvm_default_packer</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180821211122139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzk0MTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>如果不想使用默认的比较配置，用户想自己对比较配置进行设定，可以考虑自行创建一个uvm_comparer对象，或者修改全局的uvm_comparer对象。下面的这段例码，采取了第一种方法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> object_compare2;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "uvm_macros.svh"</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED, WHITE, BLACK&#125; color_t;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> box <span class="keyword">extends</span> uvm_object;</span><br><span class="line"><span class="keyword">int</span> volume = <span class="number">120</span>;</span><br><span class="line">color_t color = WHITE;</span><br><span class="line"><span class="keyword">string</span> name = <span class="string">"box"</span>;</span><br><span class="line"><span class="meta">`uvm_object_utils_begin(box)</span></span><br><span class="line"><span class="meta">`uvm_field_int(volume, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_field_enum(color_t, color, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_field_string(name, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_object_utils_end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="string">"box"</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">    <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line">box b1, b2;</span><br><span class="line">uvm_comparer cmpr;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    b1 = <span class="keyword">new</span>(<span class="string">"box1"</span>);</span><br><span class="line">    b1<span class="variable">.volume</span> = <span class="number">80</span>;</span><br><span class="line">    b1<span class="variable">.color</span> = BLACK;</span><br><span class="line">    b2 = <span class="keyword">new</span>(<span class="string">"box2"</span>);</span><br><span class="line">    b2<span class="variable">.volume</span> = <span class="number">90</span>;</span><br><span class="line">    cmpr = <span class="keyword">new</span>();</span><br><span class="line">    cmpr<span class="variable">.show_max</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(!b2<span class="variable">.compare</span>(b1, cmpr)) <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">`uvm_info("COMPARE", "b2 comapred with b1 failure", UVM_LOW)</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">`uvm_info("COMPARE", "b2 comapred with b1 succes", UVM_LOW)</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [MISCMP] Miscompare <span class="keyword">for</span> box2<span class="variable">.volume</span>: lhs = <span class="number">'h5a</span> : rhs = <span class="number">'h50</span></span><br><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [MISCMP] Miscompare <span class="keyword">for</span> box2<span class="variable">.color</span>: lhs = WHITE : rhs = BLACK</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [MISCMP] Miscompare <span class="keyword">for</span> box2<span class="variable">.name</span>: lhs = <span class="string">"box2"</span> : rhs = <span class="string">"box1"</span></span><br><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [MISCMP] <span class="number">3</span> Miscompare(s) <span class="keyword">for</span> object box1@<span class="number">336</span> vs. box2@<span class="number">337</span></span><br><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [COMPARE] b2 comapred <span class="keyword">with</span> b1 failure</span><br></pre></td></tr></table></figure>
<p>在这段例码中，额外创建了一个比较配置cmpr。这个对象是uvm_comparer类，而此类并不继承与任何其他的UVM类，只是单纯的一个用于存放比较配置信息的类。在设定了最大的比较错误次数之后，将b1与b2进行比较后的结果信息给得更加全面，这一次则将全部的比较错误信息都输出了。</p>
<h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><p>打印方法是核心基类提供的另外一种便于开发和调试的功能。通过field automation，使得声明之后的各个成员域会在调用uvm_object::print()函数时自动打印出来。下面是一段例码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> object_print;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "uvm_macros.svh"</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED, WHITE, BLACK&#125; color_t;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> box <span class="keyword">extends</span> uvm_object;</span><br><span class="line"><span class="keyword">int</span> volume = <span class="number">120</span>;</span><br><span class="line">color_t color = WHITE;</span><br><span class="line"><span class="keyword">string</span> name = <span class="string">"box"</span>;</span><br><span class="line"><span class="meta">`uvm_object_utils_begin(box)</span></span><br><span class="line"><span class="meta">`uvm_field_int(volume, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_field_enum(color_t, color, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_field_string(name, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_object_utils_end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="string">"box"</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">    <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line">box b1;</span><br><span class="line">uvm_table_printer local_printer;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    b1 = <span class="keyword">new</span>(<span class="string">"box1"</span>);</span><br><span class="line">    local_printer = <span class="keyword">new</span>();</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"default table printer format"</span>);</span><br><span class="line">    b1<span class="variable">.print</span>();</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"default line printer format"</span>);</span><br><span class="line">    uvm_default_printer = uvm_default_line_printer;</span><br><span class="line">    b1<span class="variable">.print</span>();</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"default tree printer format"</span>);</span><br><span class="line">    uvm_default_printer = uvm_default_tree_printer;</span><br><span class="line">    b1<span class="variable">.print</span>();</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"customized printer format"</span>);</span><br><span class="line">    local_printer<span class="variable">.knobs</span><span class="variable">.full_name</span> = <span class="number">1</span>;</span><br><span class="line">    b1<span class="variable">.print</span>(local_printer);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">table</span> printer format</span><br><span class="line">-------------------------------</span><br><span class="line">Name Type Size Value</span><br><span class="line">-------------------------------</span><br><span class="line">box1 box - @<span class="number">336</span></span><br><span class="line">volume integral <span class="number">32</span> <span class="number">'h78</span></span><br><span class="line">color color_t <span class="number">32</span> WHITE</span><br><span class="line">name <span class="keyword">string</span> <span class="number">4</span> box1</span><br><span class="line">-------------------------------</span><br><span class="line"><span class="keyword">default</span> line printer format</span><br><span class="line">box1: (box@<span class="number">336</span>) &#123; volume: <span class="number">'h78</span> color: WHITE name: box1 &#125;</span><br><span class="line"><span class="keyword">default</span> tree printer format</span><br><span class="line">box1: (box@<span class="number">336</span>) &#123;</span><br><span class="line">volume: <span class="number">'h78</span></span><br><span class="line">color: WHITE</span><br><span class="line">name: box1</span><br><span class="line">&#125;</span><br><span class="line">customized printer format</span><br><span class="line">------------------------------------</span><br><span class="line">Name Type Size Value</span><br><span class="line">------------------------------------</span><br><span class="line">box1 box - @<span class="number">336</span></span><br><span class="line">box1<span class="variable">.volume</span> integral <span class="number">32</span> <span class="number">'h78</span></span><br><span class="line">box1<span class="variable">.color</span> color_t <span class="number">32</span> WHITE</span><br><span class="line">box1<span class="variable">.name</span> <span class="keyword">string</span> <span class="number">4</span> box1</span><br><span class="line">-----------------------------------</span><br></pre></td></tr></table></figure>
<p>从上面这段例码中，读者可以发现，只要被在field  automation中声明过的域，在稍后的print()函数打印，都将打印出它们的类型、大小和数值。如果用户不对打印的格式做出修改，那么在打印时，UVM会按照uvm_default_printer规定的格式来打印。在上面“比较”一节中，读者已经知道uvm_pkg中在仿真一开始的时候就会例化不少全局的对象，这其中就包括了uvm_default_printer和其它几个用于打印的对象，它们分别是：</p>
<ul>
<li>uvm_default_tree_printer：可以将对象按照数状结构打印。</li>
<li>uvm_default_line_printer ： 可以将对象打印到一行上面。</li>
<li>uvm_default_table_printer ： 可以将对象按照表格的方式打印。</li>
<li>uvm_default_printer ： UVM环境默认的打印设置，该句柄默认指向了uvm_default_table_printer。</li>
</ul>
<p>所以通过给全局打印机uvm_default_printer赋予不同的打印机句柄，就可以在调用任何uvm_object的print()方法时，得到不同的打印格式。如果用户需要自定义一些打印的属性，用户可以自己创建一个打印机，进而通过修改其属性uvm_printer::knobs中的成员，来输出自己的打印格式。每一台打印机中，都有自己的打印属性，用户可以通过查看UVM类的参考手册，查找关于详细的打印属性类uvm_printer_knobs。</p>
<p>除了简单的print()函数，用户还可以通过uvm_object::sprint()将对象的信息作为字符串返回，或者自定义do_print()函数来定制一些额外的打印输出。</p>
<h4 id="打包和解包"><a href="#打包和解包" class="headerlink" title="打包和解包"></a>打包和解包</h4><p>最后，来看看另外一个核心功能，打包和解包。类似于之前的拷贝和打印，uvm_object也分别提供了通过field automation自动实现的打包和解包方法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> pack (<span class="keyword">ref</span> <span class="keyword">bit</span> bitstream[], <span class="keyword">input</span> uvm_packer packer=<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> unpack (<span class="keyword">ref</span> <span class="keyword">bit</span> bitstream[], <span class="keyword">input</span> uvm_packer packer=<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>以及用户可以自定义的回调函数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> do_pack (uvm_packer packer);</span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> do_unpack (uvm_packer packer);</span><br></pre></td></tr></table></figure>
<p>打包和解包实例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> object_pack_unpack;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "uvm_macros.svh"</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED, WHITE, BLACK&#125; color_t;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> box <span class="keyword">extends</span> uvm_object;</span><br><span class="line"><span class="keyword">int</span> volume = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">int</span> height = <span class="number">20</span>;</span><br><span class="line">color_t color = WHITE;</span><br><span class="line"><span class="meta">`uvm_object_utils_begin(box)</span></span><br><span class="line"><span class="meta">`uvm_field_int(volume, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_field_int(height, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_field_enum(color_t, color, UVM_ALL_ON)</span></span><br><span class="line"><span class="meta">`uvm_object_utils_end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="string">"box"</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line">box b1, b2;</span><br><span class="line"><span class="keyword">bit</span> packed_bits[];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    b1 = <span class="keyword">new</span>(<span class="string">"box1"</span>);</span><br><span class="line">    b2 = <span class="keyword">new</span>(<span class="string">"box2"</span>);</span><br><span class="line">    b1<span class="variable">.volume</span> = <span class="number">100</span>;</span><br><span class="line">    b1<span class="variable">.height</span> = <span class="number">40</span>;</span><br><span class="line">    b1<span class="variable">.color</span> = RED;</span><br><span class="line">    b1<span class="variable">.print</span>();</span><br><span class="line">    b1<span class="variable">.pack</span>(packed_bits);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"packed bits stream size is %d \n"</span>, packed_bits<span class="variable">.size</span>());</span><br><span class="line">    b2<span class="variable">.unpack</span>(packed_bits);</span><br><span class="line">    b2<span class="variable">.print</span>();</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------</span><br><span class="line">Name Type Size Value</span><br><span class="line">-------------------------------</span><br><span class="line">box1 box - @<span class="number">336</span></span><br><span class="line">volume integral <span class="number">32</span> <span class="number">'h64</span></span><br><span class="line">height integral <span class="number">32</span> <span class="number">'h28</span></span><br><span class="line">color color_t <span class="number">32</span> RED</span><br><span class="line">-------------------------------</span><br><span class="line"><span class="keyword">packed</span> bits stream size is <span class="number">96</span></span><br><span class="line">-------------------------------</span><br><span class="line">Name Type Size Value</span><br><span class="line">-------------------------------</span><br><span class="line">box2 box - @<span class="number">337</span></span><br><span class="line">volume integral <span class="number">32</span> <span class="number">'h64</span></span><br><span class="line">height integral <span class="number">32</span> <span class="number">'h28</span></span><br><span class="line">color color_t <span class="number">32</span> RED</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure>
<p>上面的例码中b1将自己内部已经声明过的域，首先进行打包，打包好的数据存入到一个比特数组中packed_bits，这个数组中存放着所有经过field  aumation的域值，接下来b2又从packed_bits中解包，将数据存入到自己的各个域中。这么看起来，这个例子是完成一次对象数值的拷贝。如果是这样，那么为什么不适用uvm_object::copy()函数，而是费这么大周折，来将b1内的域值先打包，然后再通过b2解包完成数值的完整传递呢？</p>
<p>实际上，打包和解包的方式并不是主要为软件对象之间的数值拷贝服务的，而是真正地在为从软件对象到硬件接口的赋值服务的。在硬件接口中，所有的接口都是按照一定的比特宽度来放置的，并不像软件对象内的各个域那样声明。因此，要完成一次从软件对象到硬件接口的赋值，一种方法就是利用uvm_object::pack()来实现。同样地，如果要完成对硬件信号的采样，也可以将排列好的硬件信号数值保存，继而通过uvm_object::unpack()来完成到软件对象的数值拷贝。</p>
<h1 id="3-phase机制"><a href="#3-phase机制" class="headerlink" title="3. phase机制"></a>3. phase机制</h1><p>解决new构建的问题：层次化环境下，实例化的先后关系；各个组件在实例化后的连接</p>
<p>在顶层需要对底层进行配置时，SV无法在底层未实例化之前完成配置</p>
<p>phase的目的：更清晰的将仿真环境层次化</p>
<p>如果暂时抛开phase的机制剖析，对于UVM组件的开发者而言，他们主要关心各个phase之间执行的先后顺序。在完成各个phase虚方法的实现之后，UVM环境会按照phase的顺序分别调用这些方法。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210716194839.png" alt="image-20210716194839847"></p>
<p>关于执行的顺序，可以从下面这段简单的例码中得到佐证：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> common_phase_order;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "uvm_macros.svh"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> subcomp <span class="keyword">extends</span> uvm_component;</span><br><span class="line"><span class="meta">`uvm_component_utils(subcomp)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info("build_phase", "", UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info("connect_phase", "", UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> end_of_elaboration_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info("end_of_elaboration_phase", "", UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> start_of_simulation_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info("start_of_simulation_phase", "", UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info("run_phase", "", UVM_LOW)</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> extract_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info("extract_phase", "", UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> check_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info("check_phase", "", UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> report_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info("report_phase", "", UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> final_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info("final_phase", "", UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> topcomp <span class="keyword">extends</span> subcomp;</span><br><span class="line">subcomp c1, c2;</span><br><span class="line"><span class="meta">`uvm_component_utils(topcomp)</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info("build_phase", "", UVM_LOW)</span></span><br><span class="line">    c1 = subcomp::type_id::create(<span class="string">"c1"</span>, <span class="keyword">this</span>);</span><br><span class="line">    c2 = subcomp::type_id::create(<span class="string">"c2"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line">topcomp t1;</span><br><span class="line"><span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    t1 = topcomp::type_id::create(<span class="string">"t1"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//t1 = new("t1", null);</span></span><br><span class="line">run_test(<span class="string">"test1"</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [RNTST] Running test test1...</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span> [build_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c1</span> [build_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c2</span> [build_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c1</span> [connect_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c2</span> [connect_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span> [connect_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c1</span> [end_of_elaboration_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c2</span> [end_of_elaboration_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span> [end_of_elaboration_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c1</span> [start_of_simulation_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c2</span> [start_of_simulation_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span> [start_of_simulation_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c1</span> [run_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c2</span> [run_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span> [run_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c1</span> [extract_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c2</span> [extract_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span> [extract_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c1</span> [check_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c2</span> [check_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span> [check_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c1</span> [report_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c2</span> [report_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span> [report_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span> [final_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c1</span> [final_phase]</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.t1</span><span class="variable">.c2</span> [final_phase]</span><br></pre></td></tr></table></figure>
<p>从这个例子可以看出，上面的九个phase，对于一个测试环境的声明周期而言，是有固定的执行先后顺序的；同时，对于处于同一个phase的组件之间，执行也会按照层次的顺序或者自顶向下、或者自底向上来执行。这个简单的环境中，顶层测试组件test1中，例化了一个t1组件，而t1组件内又进一步例化了c1和c2组件。从执行的打印结果来看，需要注意的地方有：</p>
<ol>
<li>对于build phase，执行顺序按照自顶向下，这符合验证结构建设的逻辑。因为只有先创建高层的组件，才会创建空间来容纳低层的组件。</li>
<li>只有uvm_component及其继承与uvm_component的子类，才会按照phase机制将上面九个phase先后执行完毕。</li>
</ol>
<p>上面介绍的九个phase中，常用的phase包括build、connect、run和report，它们分别完成了组件的建立、连接、运行和报告。这些phase在uvm_component中通过_phase的后缀完成了虚方法的定义，比如build_phase()中可以定义一些例化组件和配置的任务。在这九个phase中，只有run_phase方法是一个可以耗时的任务，这意味着该方法中可以完成一些等待、激励、采样的任务。对于其它phase对应的方法，都是函数，必须即时返回（0耗时）。</p>
<p>在run_phase中，用户如果要完成测试，则通常需要经历下面的激励序列：</p>
<ol>
<li>上电</li>
<li>复位</li>
<li>寄存器配置</li>
<li>主要测试内容</li>
<li>等待DUT完成测试</li>
</ol>
<p>一种简单的方式是，用户在run_phase中完成上面所有的激励；另外一种方式，如果可以将上面的几种典型的序列分到不同的区间，让对应的激励按区搁置的话，也能让测试更有层次。因此，run_phase又可以分为下面的12个phase：</p>
<ol>
<li>pre_reset_phase</li>
<li>reset_phase</li>
<li>post_reset_phase</li>
<li>pre_configure_phase</li>
<li>configure_phase</li>
<li>post_configure_phase</li>
<li>pre_main_phase</li>
<li>main_phase</li>
<li>post_main_phase</li>
<li>pre_shutdown_phase</li>
<li>shutdown_phase</li>
<li>post_shutdown_phase</li>
</ol>
<p>上面的12个phase的执行顺序也是前后排列的。实际上，run_phase任务和上面细分的12个phase是并行进行的。在start_of_simulation_phase任务执行以后，run_phase和reset_phase开始执行，而在shutdown_phase执行完之后，需要等待run_phase执行完以后，才能进入extract_phase。关于执行的关系，可以从下面这张图中得出</p>
<p><img src="https://img-blog.csdn.net/20180821212109982?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzk0MTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>这里需要提醒用户的是，虽然run_phase与细分的12个phase是并行执行的，而12个phase也是按照先后顺序执行的。为了避免不必要的干扰，用户可以选择run_phase，或者12个phase中的若干来完成激励，但是请不要将它们混合起来使用，因为这样容易导致执行关系的不明确。</p>
<h2 id="建立仿真环境"><a href="#建立仿真环境" class="headerlink" title="建立仿真环境"></a>建立仿真环境</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210716203559.png" alt="image-20210716203559281" style="zoom:67%;" /></p>
<ol>
<li>首先在加载硬件模型，调用仿真器之前，需要完成编译和建模阶段。</li>
<li>接下来，在开始仿真之前，会分别执行硬件的always/initial语句，以及UVM的调用测试方法run_test和几个phase，分别是build、connect、end_of_elaboration和start_of_simulation。</li>
<li>在开始仿真后，将会执行run_phase或者对应的12个细化phase。</li>
<li>在仿真结束后，将会执行剩余的phase，分别是extract、check、report和final。</li>
</ol>
<p>如果只是从UVM的应用角度来看，要在仿真开始时建立验证环境，那么用户可以考虑选择下面几种方式：</p>
<ul>
<li>可以通过全局函数（由uvm_pkg提供）run_test()来选择性地指定要运行哪一个uvm_test。这里的test类均继承于uvm_test。这样的话，指定的test类将被例化并指定为顶层的组件。一般而言，run_test()函数可以在合适的module中initial进程块中调用。</li>
<li>如果没有任何参数传递给run_test()，那么用户可以在仿真时通过传递参数+UVM_TESTNAME=<test_name>，来指定仿真时调用的uvm_test。当然，即便run_test()函数在调用时已经有test传递进去，在仿真时的+UVM_TESTNAME=<test_name>也可以从顶层覆盖底层的指定。这种方式使得在仿真开始时，不需要通过再次修改run_test()调用的test名字和重复编译，而可以灵活选定test</li>
</ul>
<p>无论上面哪一种方式，都必须有顶层调用全局函数run_test()，用户可以考虑不传递test名字作为参数，而在仿真时通过传递参数+UVM_TESTNAME=<test_name>实现。全局函数run_test()的重要性，正是从uvm_root创建了一个UVM的世界。来看看这一段代码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> run_test (<span class="keyword">string</span> test_name=<span class="string">""</span>);</span><br><span class="line">uvm_root top;</span><br><span class="line">uvm_coreservice_t cs;</span><br><span class="line">cs = uvm_coreservice_t::get();</span><br><span class="line">top = cs<span class="variable">.get_root</span>();</span><br><span class="line">top<span class="variable">.run_test</span>(test_name);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"> </span><br><span class="line">uvm-<span class="number">1</span><span class="variable">.2</span>/base/uvm_globals<span class="variable">.svh</span></span><br></pre></td></tr></table></figure>
<p>这里需要先来了解UVM的顶层类uvm_root。该类也继承与uvm_component，说明它必然是UVM环境结构中的一员，而他可以作为顶层结构类，它提供了一些像run_test这种方法，来充当了UVM世界中的核心角色。在uvm_pkg中，有且只有一个顶层类uvm_root例化的对象，即uvm_top。这就同“道生一，一生二，二生三，三生万物”的古语一般。在UVM的世界中，“道”就是uvm_pkg，“一”就是uvm_top，而后来的“万物”就是uvm_top下例化的uvm_test及其更多的子组件。</p>
<p>uvm_top充当的主要核心任务包括：</p>
<ul>
<li>作为隐形的UVM世界顶层，任何其它的组件都在它之下，通过创建组件时指定parent来构成层次。如果parent设定为null，那么它将作为uvm_top的子组件。</li>
<li>phase控制。控制所有组件的phase顺序。</li>
<li>索引功能。通过层次名称来索引组件实例。</li>
<li>报告配置。通过uvm_top来全局配置报告的繁简度（verbosity）。</li>
<li>全局报告设备。由于uvm_top全局可以访问，因此UVM的报告配置在组件内部和组件外部（例如module和seequence）都可以访问。</li>
</ul>
<p>通过uvm_top调用方法run_test(test_name)，uvm_top做了如下的初始化：</p>
<ul>
<li>得到正确的test_name。</li>
<li>初始化objection机制。</li>
<li>创建uvm_test_top实例。</li>
<li>调用phase控制方法，安排所有组件的phase方法执行顺序。</li>
<li>等待所有phase执行结束，关闭phase控制进程。</li>
<li>报告总结和结束仿真。</li>
</ul>
<h2 id="uvm仿真结束"><a href="#uvm仿真结束" class="headerlink" title="uvm仿真结束"></a>uvm仿真结束</h2><p>从之前的例子和上面的图中，UVM的环境建立和各个phase的先后调用的入口，都是从run_test()进入的。默认情况下，如果run_test()方法执行完毕，那么系统函数$finish则会被调用，来终止仿真。此外还有什么方法可以结束仿真呢？——objection挂起机制</p>
<p>从这一版本的结束机制可以看到：</p>
<ul>
<li>默认情况下，如果没有objection反停止标记挂起的，所有的run_phase任务在执行时，会直接放入到fork-join_none进程当中。因此run_phase()中的任务会在后台执行，但不会阻止run_phase()结束，进入下一个phase。因此，objection机制是控制仿真退出run phase的一种办法。</li>
</ul>
<p>uvm_objection类提供了一种供所有component和sequence共享的计数器。如果有组件来挂起objection，那么它还应该记得落下objection。参与到objection机制中的参与组件，可以独立的各自挂起objection，来防止run phase退出，但是只有这些组件都落下objection后，uvm_objection共享的counter才会变为0，这意味run  phase推出的条件满足，因此可以退出run phase。</p>
<p>对于uvm_objection类，用来反停止的控制方法包括：</p>
<ul>
<li><p>raise_objection ( uvm_object bj = null, string description = “” , int count = 1) 挂起objection</p>
</li>
<li><p>drop_objection ( uvm_object bj = null, string description = “” , int count = 1) 落下objection</p>
</li>
<li>set_drain_time ( uvm_object bj = null, time drain) 设置退出时间</li>
</ul>
<p>对这几种典型方法，在实际应用中的建议包括：</p>
<ul>
<li>对于component()而言，用户可以在run_phase()中使用phase.raise_objection()/phase.drop_objection()来控制run phase退出。</li>
<li>用户最好提供对于description字符串参数用来描述，这有利于后期的调试。</li>
<li>应该使用默认count值。</li>
<li>对于uvm_top或者uvm_test_top应该尽可能少使用set_drain_time()。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line"><span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">    phase<span class="variable">.raise_objection</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="meta">`uvm_info("run_phase", "entered ..", UVM_LOW)</span></span><br><span class="line">    #<span class="number">1</span>us;</span><br><span class="line">    <span class="meta">`uvm_info("run_phase", "exited ..", UVM_LOW)</span></span><br><span class="line">    phase<span class="variable">.drop_objection</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    run_test(<span class="string">"test1"</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [RNTST] Running test test1...</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top [run_phase] entered ..</span><br><span class="line">UVM_INFO @ <span class="number">1000000</span>: uvm_test_top [run_phase] exited ..</span><br><span class="line">UVM_INFO @ <span class="number">1000000</span>: reporter [TEST_DONE] 'run' phase is ready to proceed to the 'extract' phase</span><br><span class="line">UVM_INFO @ <span class="number">1000000</span>: reporter [UVM/REPORT/CATCHER]</span><br></pre></td></tr></table></figure>
<p>从输出结果来看，uvm_pkg::uvm_test_done实例会在test1的run_phase()执行完毕之后，才会退出run  phase。这得益于test1::run_phase()中在仿真一开始就挂起了objection。在执行完毕之后，才落下了objection。这时，uvm_pkg::uvm_test_done认为run phase已经可以退出，进而转向了下一个extract phase。直到退出所有的phase之后，UVM进入了报告总结阶段</p>
<p>反之，如果在整个test及其子组件和sequence中，都没有通过objection()机制来控制run phase退出，那么所有组件的run  phase都会通过fork-join_none线程提交之后，立即转入到extract  phase。所以objection机制的应用是必不可少的。那么，在什么时间点应该挂起objection呢？再来看下面这段例码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> objection_application;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "uvm_macros.svh"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line"><span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">    #<span class="number">1</span>ps;</span><br><span class="line">    phase<span class="variable">.raise_objection</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="meta">`uvm_info("run_phase", "entered ..", UVM_LOW)</span></span><br><span class="line">    #<span class="number">1</span>us;</span><br><span class="line">    <span class="meta">`uvm_info("run_phase", "exited ..", UVM_LOW)</span></span><br><span class="line">    phase<span class="variable">.drop_objection</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    run_test(<span class="string">"test1"</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [RNTST] Running test test1...</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [UVM/REPORT/CATCHER]</span><br></pre></td></tr></table></figure>
<p>这段代码中，看起来挂起objection()已经晚了，因为run  phase还是立即退出了。这是因为在挂起objection之前还需要运行1ps，而处于fork-join_none后的run_phase任务在0时刻被调用后，run phase退出机制在0时刻发现没有挂起的objection，因此终止所有的run_phase()任务，继而转入了extract  phase。所以，如果要在component中挂起objection，建议在一进入run_phase()后就挂起，保证objection  counter及时被增加；</p>
<p>另外，需要习惯在sequence中挂起objection，由于sequence不是uvm_component类，而是uvm_object类，因此它只有body()方法，而没有run_phase()方法。所以，在sequence中使用objection机制，可以在body()中的首尾部分分别调用uvm_test_done.raise_objection()和uvm_test_done.drop_objection()。对于习惯在pre_body()中调用uvm_test_done.raise_objection()，在post_body()中调用uvm_test_done.drop_objection()，这么做在多数情况下可以起到objection的防退出机制，但是一些情况下，sequence的pre_body()和post_body()并不会调用，所以objection机制也没有起到作用。因此，我们建议在sequence body()任务中raise/drop objection。</p>
<h1 id="4-config机制"><a href="#4-config机制" class="headerlink" title="4.config机制"></a>4.config机制</h1><p>buildphase中，除了组件的实例化，配置也是必不可少的</p>
<p>UVM提供了uvm_config_db的配置类以及几种很方便的变量设置方法来实现在仿真时的环境控制。常见的uvm_config_db的使用方式包括有：</p>
<ul>
<li>传递virtual interface到环境中。</li>
<li>设置单一变量值，例如int、string、enum等。</li>
<li>传递配置对象（config object）到环境。</li>
</ul>
<p>config机制的路径传递基于字符串层次：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210726110415.png" alt="image-20210726110415288"></p>
<p>和工厂机制的关系；</p>
<p>工厂的实例方法：由parent构成的层次关系，基于name构成的基于字符串的层次关系</p>
<p>注意点：</p>
<p>parent win，即多层对底层的同一变量做不同的配置时，上层的优先级更高</p>
<h2 id="interface传递"><a href="#interface传递" class="headerlink" title="interface传递"></a>interface传递</h2><p>首先来看看interface的传递，通过这种方便的传递方式很好地解决了连接硬件世界和软件世界。而在之前关于SV的核心篇章中，读者们可以看到，虽然SV可以通过层次化interface的索引来完成传递，但是这种方式不利于软件环境的封装和复用。下面这种方式，使得接口的传递和获取彻底分离开来，而在后台对virtual interface的传递立下功劳的便是uvm_config_db。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> intf1;</span><br><span class="line"><span class="keyword">logic</span> enable = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> config_interface;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "uvm_macros.svh"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> comp1 <span class="keyword">extends</span> uvm_component;</span><br><span class="line"><span class="meta">`uvm_component_utils(comp1)</span></span><br><span class="line"><span class="keyword">virtual</span> intf1 vif;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">if</span>(!uvm_config_db<span class="variable">#(virtual intf1)::get(this, "", "vif", vif))</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">`uvm_error("GETVIF", "no virtual interface is assigned")</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="meta">`uvm_info("SETVAL", $sformatf("vif.enable is %b before set", vif.enable), UVM_LOW)</span></span><br><span class="line">    vif<span class="variable">.enable</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">`uvm_info("SETVAL", $sformatf("vif.enable is %b after set", vif.enable), UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line"><span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line">comp1 c1;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    c1 = comp1::type_id::create(<span class="string">"c1"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line">intf1 intf();</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    uvm_config_db<span class="variable">#(virtual intf1)::set(uvm_root::get(), "uvm_test_top.c1", "vif", intf)</span>;</span><br><span class="line">    run_test(<span class="string">"test1"</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [RNTST] Running test test1...</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.c1</span> [SETVAL] vif<span class="variable">.enable</span> is <span class="number">0</span> <span class="keyword">before</span> set</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.c1</span> [SETVAL] vif<span class="variable">.enable</span> is <span class="number">1</span> after set</span><br></pre></td></tr></table></figure>
<p><strong>最关键的两个方法：存和取</strong></p>
<ul>
<li><p><strong>对<code>uvm_config_db#(virtual intf1)::set(uvm_root::get(), &quot;uvm_test_top.c1&quot;, &quot;vif&quot;, intf);</code>参数的理解：</strong></p>
<p>所有参数实际上构建的是一个hash表！前三个参数实际上对应的是path，最后一个参数对应的是传入的interface</p>
<p>首先run_test(“test1”)构建了一个root - test - c1 的层次结构。uvm_root::get()获取的是最顶层的句柄root，第二个参数说明是test_top下的c1，第三个参数实际上可以理解为一个key，此时对应的一个path就是：root.test.c1.vif</p>
</li>
<li><p><strong>对在comp1组件类中声明的<code>uvm_config_db#(virtual intf1)::get(this, &quot;&quot;, &quot;vif&quot;, vif)</code>这里的get方法和set刚好对应</strong>：</p>
<ul>
<li>this：当前实例的路径（root.test.c1）</li>
<li>vif：对应接口名的key：vif，此时相当于把set中存储的intf拿了出来，赋给了vif</li>
</ul>
</li>
<li>set：顶层把信息（如interface）set进来</li>
<li>get：底层把信息获取到</li>
<li>set和get的发生场景：组件中</li>
</ul>
<p>从上面这个例子可以看到，接口的传递从硬件世界到UVM环境中的传递可以通过uvm_config_db来实现。在实现过程中需要注意几点：</p>
<ul>
<li>接口的传递应该发生在run_test()之前。这保证了在进入build phase之前，virtual interface已经传递进入uvm_config_db中。</li>
<li><strong>用户应当把interface与virtual interface的声明区分开来。在传递过程中的类型应当为virtual interface，即实际接口的句柄。</strong></li>
</ul>
<h2 id="object传递"><a href="#object传递" class="headerlink" title="object传递"></a>object传递</h2><p>在实际的test配置中，需要配置的参数不单单数量多，而且还分属于不同的组件。那么，如果对这么多层次中的变量做出类似上面的单一变量设置，一方面需要更多的代码，这就容易出错，不易于阅读，另外一方面也不易于复用，毕竟底层组件的变量有添加或者减少，通过uvm_config_db::set是无法得知是否设置成功的。因此，如果将每个组件中的变量加以整合，首先放置到一个uvm_object中用于传递，那么将会更有利于整体进行配置。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "uvm_macros.svh"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> config1 <span class="keyword">extends</span> uvm_object;</span><br><span class="line"><span class="keyword">int</span> val1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> str1 = <span class="string">"null"</span>;</span><br><span class="line"><span class="meta">`uvm_object_utils(config1)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">"config1"</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> comp1 <span class="keyword">extends</span> uvm_component;</span><br><span class="line"><span class="meta">`uvm_component_utils(comp1)</span></span><br><span class="line">config1 cfg;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    uvm_object tmp;</span><br><span class="line">    uvm_config_db<span class="variable">#(uvm_object)::get(this, "", "cfg", tmp)</span>;</span><br><span class="line">    <span class="keyword">void</span>'(<span class="built_in">$cast</span>(cfg, tmp));</span><br><span class="line">    <span class="meta">`uvm_info("SETVAL", $sformatf("cfg.val1 is %d after get", cfg.val1), UVM_LOW)</span></span><br><span class="line">    <span class="meta">`uvm_info("SETVAL", $sformatf("cfg.str1 is %s after get", cfg.str1), UVM_LOW)</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line"><span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line">comp1 c1, c2;</span><br><span class="line">config1 cfg1, cfg2;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    cfg1 = config1::type_id::create(<span class="string">"cfg1"</span>);</span><br><span class="line">    cfg2 = config1::type_id::create(<span class="string">"cfg2"</span>);</span><br><span class="line">    cfg1<span class="variable">.val1</span> = <span class="number">30</span>;</span><br><span class="line">    cfg1<span class="variable">.str1</span>= <span class="string">"c1"</span>;</span><br><span class="line">    cfg2<span class="variable">.val1</span> = <span class="number">50</span>;</span><br><span class="line">    cfg2<span class="variable">.str1</span>= <span class="string">"c2"</span>;</span><br><span class="line">    uvm_config_db<span class="variable">#(uvm_object)::set(this, "c1", "cfg", cfg1)</span>;</span><br><span class="line">    uvm_config_db<span class="variable">#(uvm_object)::set(this, "c2", "cfg", cfg2)</span>;</span><br><span class="line">    c1 = comp1::type_id::create(<span class="string">"c1"</span>, <span class="keyword">this</span>);</span><br><span class="line">    c2 = comp1::type_id::create(<span class="string">"c2"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    run_test(<span class="string">"test1"</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [RNTST] Running test test1...</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.c1</span> [SETVAL] cfg<span class="variable">.val1</span> is <span class="number">30</span> after get</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.c1</span> [SETVAL] cfg<span class="variable">.str1</span> is c1 after get</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.c2</span> [SETVAL] cfg<span class="variable">.val1</span> is <span class="number">50</span> after get</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: uvm_test_top<span class="variable">.c2</span> [SETVAL] cfg<span class="variable">.str1</span> is c2 after get</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>和上面的interface传递类似，不需要在initial块中就对interface进行set，只需要在调用object的组件类（comp1）创建之前进行set就可以了！！如代码的47-50行</p>
</li>
<li><p>set和get的通配符，即对象类型必须完全一致，子类和父类的关系也不行</p>
</li>
<li>如果set的是一个子类对象，用一个父类句柄进行get，必须通过$cast(a,b)进行类型转换</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210716220512.png" alt="image-20210716220512126" style="zoom:67%;" />、</p>
<h1 id="5-消息（message）管理"><a href="#5-消息（message）管理" class="headerlink" title="5. 消息（message）管理"></a>5. 消息（message）管理</h1><p>一个好的验证系统应该具有消息管理特性，它们是：<strong>通过一种标准化的方式打印信息、过滤重要级别信息、打印通道</strong>。UVM中提供了一系列的类和方法来生成和过滤消息，包括<strong>消息方法、消息处理、消息机制</strong>。</p>
<h2 id="5-1-消息方法"><a href="#5-1-消息方法" class="headerlink" title="5.1 消息方法"></a>5.1 消息方法</h2><p>在UVM环境中或者环境外，只有引入<code>uvm_pkg</code>，都可以通过下面的方法来按照消息的严重级别和冗余度打印消息。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_report_info(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity=UVM_MEDIUM, <span class="keyword">string</span> filename=<span class="string">""</span>, <span class="keyword">int</span> line=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_report_warning(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity=UVM_MEDIUM, <span class="keyword">string</span> filename=<span class="string">""</span>, <span class="keyword">int</span> line=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_report_error(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity=UVM_LOW, <span class="keyword">string</span> filename=<span class="string">""</span>, <span class="keyword">int</span> line=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_report_fatal(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity=UVM_NONE, <span class="keyword">string</span> filename=<span class="string">""</span>, <span class="keyword">int</span> line=<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>filename：当前执行的文件名；line：该条消息来自于哪一行</p>
<p>这两个变量不需要传入，系统自动添加</p>
<p><img src="C:/Users/biongd/AppData/Roaming/Typora/typora-user-images/image-20210725203703986.png" alt="image-20210725203703986" style="zoom:67%;" /></p>
<p>非常关键的是一个冗余度的级别，可以对信息进行过滤，NONE的等级最高，无法被过滤。约往下就越低，越容易被过滤掉</p>
<h2 id="5-2-消息处理"><a href="#5-2-消息处理" class="headerlink" title="5.2 消息处理"></a>5.2 消息处理</h2><p>与每一条消息对应的是如何处理这些消息。通过情况下，消息处理的方式是同消息的严重级别对应的，也可以修改对各个严重级别的消息处理方式。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210725204216.png" alt="在这里插入图片描述"></p>
<p>不同的严重级别消息，可以使用默认的消息处理方式</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210725204218.png" alt="在这里插入图片描述"></p>
<h3 id="uvm-report-handler和uvm-report-server"><a href="#uvm-report-handler和uvm-report-server" class="headerlink" title="uvm_report_handler和uvm_report_server"></a>uvm_report_handler和uvm_report_server</h3><p>消息处理是由uvm_report_handler类来完成的，而每一个uvm_report_object类中都有一个uvm_report_handler实例。</p>
<p>uvm_report_object消息处理方法或者uvm_component消息处理方法，都是针对于这些uvm_report_handler做出的配置。<br><img src="https://gitee.com/biongd/img/raw/master/img/20210725204546.png" alt="image-20210725204546777" style="zoom:67%;" /></p>
<p>除了每一个uvm_report_object中都内置一个uvm_report_handler实例之外，所有的uvm_report_handler实例也都依赖于uvm_pkg中。uvm_report_server的唯一实例，但是该实例并没有作为全局变量，需要自行调用uvm_report_server::get_server()方法来获取。uvm_report_server是一个全局的消息处理设备，用来处理从所有uvm_report_handler中产生的消息，这个唯一的uvm_report_server之所以没有直接暴露在uvm_pkg中，一个原因在于对消息的处理方式。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210725210258.png" alt="在这里插入图片描述" style="zoom:67%;" /></p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>在处理信息时除默认的处理方式外还想做其他处理，可以使用回调函数</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> report_hook(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity, <span class="keyword">string</span> filename, <span class="keyword">int</span> line)</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> report_info_hook(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity, <span class="keyword">string</span> filename, <span class="keyword">int</span> line)</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> report_warning_hook(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity, <span class="keyword">string</span> filename, <span class="keyword">int</span> line)</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> report_error_hook(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity, <span class="keyword">string</span> filename, <span class="keyword">int</span> line)</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> report_fatal_hook(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity, <span class="keyword">string</span> filename, <span class="keyword">int</span> line)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210725205704.png" alt="image-20210725205649830" style="zoom:67%;" /></p>
<p>实例：</p>
<ul>
<li>对UVM_ERROR的消息处理方式进行了修改，此时其可以触发回调函数，report_hook必须设置，如果返回值唯一，则可以进行其细分一级的hook回调函数，如果定义report_hook的返回值为0，则report_hook执行完即截止</li>
<li>设置了过滤等级</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line">	<span class="keyword">integer</span> f;</span><br><span class="line">	<span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase, phase);</span><br><span class="line">		set_report_severity_action(UVM_ERROR, UVM_DISPLAY|UVM_CALL_HOOK);	<span class="comment">//设置不同严重级别的处理操作</span></span><br><span class="line">		set_report_severity_level(UVM_LOW);		<span class="comment">//设置过滤消息等级</span></span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase, phase);</span><br><span class="line">		uvm_report_info(<span class="string">"RUN"</span>, <span class="string">"info1"</span>, UVM_MEDIUM);</span><br><span class="line">		uvm_report_info(<span class="string">"RUN"</span>, <span class="string">"info2"</span>, UVM_LOW);</span><br><span class="line">		uvm_report_warning(<span class="string">"RUN"</span>, <span class="string">"warning1"</span>, UVM_LOW);</span><br><span class="line">		uvm_report_error(<span class="string">"RUN"</span>, <span class="string">"error1"</span>, UVM_LOW);</span><br><span class="line">		uvm_report_error(<span class="string">"RUN"</span>, <span class="string">"error2"</span>, UVM_HIGH);</span><br><span class="line">		uvm_report_error(<span class="string">"RUN"</span>, <span class="string">"error3"</span>, UVM_LOW);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> report_phase(uvm_phase, phase);</span><br><span class="line">		<span class="built_in">$fclose</span>(f);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">bit</span> report_hook(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity, <span class="keyword">string</span> filename, <span class="keyword">int</span> line);</span><br><span class="line">		uvm_report_info(<span class="string">"RPTHOOK"</span>, <span class="built_in">$sformatf</span>(<span class="string">"%s : %s"</span>, id, message), UVM_LOW);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">bit</span> report_error_hook(<span class="keyword">string</span> id, <span class="keyword">string</span> message, <span class="keyword">int</span> verbosity, <span class="keyword">string</span> filename, <span class="keyword">int</span> line);</span><br><span class="line">		uvm_report_info(<span class="string">"ERRHOOK"</span>, <span class="built_in">$sformatf</span>(<span class="string">"%s : %s"</span>, id, message), UVM_LOW);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210725205119.png" alt="在这里插入图片描述" style="zoom:67%;" /></p>
<h2 id="5-3-消息的创建"><a href="#5-3-消息的创建" class="headerlink" title="5.3 消息的创建"></a>5.3 消息的创建</h2><p>如果要做自定义的消息处理方式，可以通过<code>uvm_report_object</code>类提供的方法进行配置，<code>uvm_report_object</code>类是间于<code>uvm_object</code>类与<code>uvm_component</code>类之间的中间类，它的主要功能是完成消息打印和管理。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210725204210.png" alt="在这里插入图片描述" style="zoom:67%;" /></p>
<p>处理消息的方法和宏：</p>
<p><img src="https://img-blog.csdnimg.cn/20210221214124358.png" alt="在这里插入图片描述"></p>
<h1 id="6-UVM结构回顾"><a href="#6-UVM结构回顾" class="headerlink" title="6. UVM结构回顾"></a>6. UVM结构回顾</h1><p>类库地图中可以看到，用来创建组件的uvm_factory和用来构建环境的uvm_root都是找不到的，</p>
<h2 id="6-1-uvm-top"><a href="#6-1-uvm-top" class="headerlink" title="6.1 uvm_top"></a>6.1 uvm_top</h2><ul>
<li>uvm_top是uvm_root类的唯一实例，UVM世界的“一”，它由UVM创建和管理，它所在的域是uvm_pkg。</li>
<li>uvm_top是所有test组件的顶层，所有验证环境中的组件在创建时都需要指明它的父一级，如果某些组件在创建时指定父级的参数为null，那么它将<strong>直接隶属于uvm_top。</strong></li>
<li>uvm_top提供一系列的方法来控制仿真，例如phase机制、objection防止仿真退出机制等。</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210726162156.png" alt="image-20210726162156389" style="zoom:67%;" /></p>
<h2 id="6-2-uvm-test"><a href="#6-2-uvm-test" class="headerlink" title="6.2 uvm_test"></a>6.2 uvm_test</h2><p>所有的test类必须继承uvm_test，否则uvm_top不识别！！！（run_test（）就废了）</p>
<p><code>test</code>的目标包括：</p>
<ul>
<li>提供不同的配置，包括环境结构配置、测试模式配置等，然后再创建验证环境；</li>
<li>例化测试序列，并且挂载到目标<code>sequencer</code>，使其命令<code>driver</code>发送激励。</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210726162609.png" alt="image-20210726162609205" style="zoom:67%;" /></p>
<h2 id="6-3-构建环境的主要组件"><a href="#6-3-构建环境的主要组件" class="headerlink" title="6.3 构建环境的主要组件"></a>6.3 构建环境的主要组件</h2><p>uvm_component</p>
<ul>
<li><strong>继承于uvm_report_object（进一步继承于object），提供消息方法。</strong></li>
<li><strong>所有的验证环境组件都继承于uvm_component。</strong></li>
<li><strong>管理验证的层次。</strong></li>
</ul>
<p>uvm_env</p>
<ul>
<li>继承于uvm_component。</li>
<li>没有额外的功能。</li>
<li>用来为验证环境结构提供一个容器。</li>
</ul>
<p>uvm_test</p>
<ul>
<li>继承于uvm_component。</li>
<li>没有额外的功能。</li>
<li>用来提供对uvm_env的额外配置以及挂载励。</li>
</ul>
<h2 id="6-4-uvm-component"><a href="#6-4-uvm-component" class="headerlink" title="6.4 uvm_component"></a>6.4 uvm_component</h2><p>该类是一个虚类，所有环境组件都继承于该类，所有继承于该类的子类，都称之为组件或者环境组件。由于环境中所有的组件都继承于uvm_component，因此也就可以使得UVM提供统一的方式来管理层次结构和组件方法。</p>
<p>该类提供以下接口或者API：</p>
<ul>
<li>结构，例如get_full_name()，get_parent()，get_num_children()</li>
<li>阶段（phase）机制，例如build_phase()，connect_phase()，run_phase()</li>
<li>配置（configuration）机制，例如print_config()，print_override_info()</li>
<li>报告（report）机制，例如report_hook()，set_report_verbosity_level_hier()</li>
<li>事务记录（transaction recording），例如record()</li>
<li>工厂（factory）机制，例如set_inst_override()，set_type_override()</li>
</ul>
<p>对于组件的构建函数，固定形式为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br></pre></td></tr></table></figure>
<ul>
<li>string name用来声明当前例化组件的名称，用来自动和它所在的父级层次组合为组件的整个层次名称，可以get_full_name()方法获取。</li>
<li>uvm_component parent用来指示所例化的父级句柄，通常用this指代，即例化在当前的父级组件中。</li>
<li>uvm_object并不参与组件的层次构建，因此只有一个形参string name。</li>
</ul>
<h1 id="7-MCDF顶层验证方案"><a href="#7-MCDF顶层验证方案" class="headerlink" title="7. MCDF顶层验证方案"></a>7. MCDF顶层验证方案</h1><p>MCDF的主要功能是将输入端的三个通道数据，通过数据整形和过滤，最终输出。</p>
<p>可以将MCDF的设计结构分别四个模块：</p>
<ul>
<li>上行数据的通道从端（channel slave）</li>
<li>仲裁器（arbiter）</li>
<li>整形器（formatter）</li>
<li>控制寄存器（control registers）</li>
</ul>
<h2 id="7-1-reg-env"><a href="#7-1-reg-env" class="headerlink" title="7.1 reg_env"></a>7.1 reg_env</h2><p>对于寄存器模块的验证环境<code>reg_env</code>，它的组织包括：</p>
<ul>
<li><code>reg_master_agent</code>，提供寄存器接口驱动信号。</li>
<li><code>reg_slave_agent</code>，提供寄存器接口反馈信号。</li>
<li><code>scoreboard</code>，分别从<code>reg_master_agent</code>内的<code>monitor</code>和<code>reg_slave_agent</code>内的<code>monitor</code>获取监测数据，并且进行数据对比。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210226133436861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="7-2-chnl-env"><a href="#7-2-chnl-env" class="headerlink" title="7.2 chnl_env"></a>7.2 chnl_env</h2><p>数据通道从端的验证环境<code>chnl_env</code>的组件包括：</p>
<ul>
<li>chnl_master_agent，提供上行的激励数据。</li>
<li>chnl_slave_agent，提供用来模拟arbiter仲裁信号，并且接受流出数据。</li>
<li>reg_cfg_agent，用来提供模拟寄存器的配置信号，并且接收内置FIFO的余量信号。</li>
<li>scoreboard，分别从chnl_master_agent、chnl_slave_agent、reg_cfg_agent的monitor接收检测数据，并且对channel的流入流出数据进行比对。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2021022613390724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /></p>
<h2 id="7-3-arb-env"><a href="#7-3-arb-env" class="headerlink" title="7.3 arb_env"></a>7.3 arb_env</h2><p>仲裁器的验证环境arb_env的组件包括：</p>
<ul>
<li>模拟channel输出接口的arbiter_master_agent的三个实例，用来对arbiter提供并行数据输入，同时对arbiter反馈的仲裁信号做出响应。</li>
<li>arbiter_slave_agent，用来接收arbiter的输出数据，模拟formatter的行为，对arbiter的输出信号做出响应。</li>
<li>reg_cfg_agent，提供用来模拟寄存器的配置信号，对三个channel数据源分别做出不同的优先级配置。</li>
<li>scoreboard，从三个arbiter_master_agent、arbiter_slave_agent、reg_cfg_agent中的monitor获取监测数据，对arbiter的仲裁机制做出预测，并且将输入输出数据按照预测的优先级做出比对</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2021022613453933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /></p>
<h2 id="7-4-fmt-env"><a href="#7-4-fmt-env" class="headerlink" title="7.4 fmt_env"></a>7.4 fmt_env</h2><p>整形器的验证环境fmt_env的组件包括：</p>
<ul>
<li>fmt_master_agent，用来模拟arbiter的输出数据。</li>
<li>fmt_slave_agent，用来模拟MCDF的下行数据接收端。</li>
<li>reg_cfg_agent，用来模拟寄存器的配置信号，用来指定输出数据包的长度。</li>
<li>scoreboard，从fmt_master_agent、fmt_slave_agent、reg_cfg_agent的monitor获取检测数据，通过数据包长度来预测输出的数据包，与formatter输出的数据包进行比对。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210226135622150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /></p>
<h2 id="7-5-环境集成方案一"><a href="#7-5-环境集成方案一" class="headerlink" title="7.5 环境集成方案一"></a>7.5 环境集成方案一</h2><p>CDF顶层验证环境复用了这些模块验证环境的组件，<code>reg_master_agent</code>、<code>chnl_master_agent</code>、<code>fmt_slave_agent</code>，通过这三个激励组件可以有效生成新的激励序列，而将各个agent的sequencer句柄合并在一起时，<code>virtual sequencer</code>的作用就体现出来了，可以通过这个中心化的序列分发管道，将各个agent的sequencer也集中管理。MCDF的scoreboard提供了一个完整的数据通路覆盖方案，即从各个agent的monitor的数据检测端口将数据收集起来，同时建立MCDF的参考模型，预测输出数据包，最终进行数据比对。</p>
<p><img src="https://img-blog.csdnimg.cn/20210226140149514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> mcdf_env1 <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	<span class="meta">`uvm_component_utils(mcdf_env1)</span></span><br><span class="line">	reg_master_agent reg_mst;</span><br><span class="line">	chnl_master_agent chnl_mst1;</span><br><span class="line">	chnl_master_agent chnl_mst2;</span><br><span class="line">	chnl_master_agent chnl_mst3;</span><br><span class="line">	fmt_slave_agent fmt_slv;</span><br><span class="line">	mcdf_virtual_sequencer virt_sqr;</span><br><span class="line">	mcdf_scoreboard sb;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">		reg_mst = reg_master_agent::type_id::create(<span class="string">"reg_mst"</span>, <span class="keyword">this</span>);</span><br><span class="line">		chnl_mst1 = chnl_master_agent::type_id::create(<span class="string">"chnl_mst1"</span>, <span class="keyword">this</span>);</span><br><span class="line">		chnl_mst2 = chnl_master_agent::type_id::create(<span class="string">"chnl_mst2"</span>, <span class="keyword">this</span>);</span><br><span class="line">		chnl_mst3 = chnl_master_agent::type_id::create(<span class="string">"chnl_mst3"</span>, <span class="keyword">this</span>);</span><br><span class="line">		fmt_slv = fmt_slave_agent::type_id::create(<span class="string">"fmt_slv"</span>, <span class="keyword">this</span>);</span><br><span class="line">		virt_sqr = mcdf_virtual_sequencer::type_id::create(<span class="string">"virt_sqr"</span>, <span class="keyword">this</span>);</span><br><span class="line">		sb = mcdf_scoreboard::type_id::create(<span class="string">"sb"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">		<span class="comment">//virtual sequencer connect</span></span><br><span class="line">		virt_sqr<span class="variable">.reg_sqr</span> = reg_mst<span class="variable">.sequencer</span>;</span><br><span class="line">		virt_sqr<span class="variable">.chnl_sqr1</span> = chnl_mst1<span class="variable">.sequencer</span>;</span><br><span class="line">		virt_sqr<span class="variable">.chnl_sqr2</span> = chnl_mst2<span class="variable">.sequencer</span>;</span><br><span class="line">		virt_sqr<span class="variable">.chnl_sqr3</span> = chnl_mst3<span class="variable">.sequencer</span>;</span><br><span class="line">		virt_sqr<span class="variable">.fmt_sqr</span> = fmt_slv<span class="variable">.sequencer</span>;</span><br><span class="line">		<span class="comment">//monitor transactions to scoreboard</span></span><br><span class="line">		reg_mst<span class="variable">.monitor</span><span class="variable">.ap</span><span class="variable">.connect</span>(sb<span class="variable">.reg_export</span>);</span><br><span class="line">		chnl_mst1<span class="variable">.monitor</span><span class="variable">.ap</span><span class="variable">.connect</span>(sb<span class="variable">.chnl1_export</span>);</span><br><span class="line">		chnl_mst2<span class="variable">.monitor</span><span class="variable">.ap</span><span class="variable">.connect</span>(sb<span class="variable">.chnl2_export</span>);</span><br><span class="line">		chnl_mst3<span class="variable">.monitor</span><span class="variable">.ap</span><span class="variable">.connect</span>(sb<span class="variable">.chnl3_export</span>);</span><br><span class="line">		fmt_slv<span class="variable">.monitor</span><span class="variable">.ap</span><span class="variable">.connect</span>(sb<span class="variable">.fmt_export</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h2 id="7-6-环境集成方案二"><a href="#7-6-环境集成方案二" class="headerlink" title="7.6 环境集成方案二"></a>7.6 环境集成方案二</h2><p>在方案一中最大的额外投入在于<strong>需要新建一个scoreboard</strong>用来检查MCDF的整体功能，而方案二的目的在于<strong>复用底层模块环境的scoreboard</strong>，减少顶层环境的额外成本，顶层环境的组件都直接复用了各个模块验证环境，顶层环境在集成模块验证环境时，需要将各个子模块中的agent配置为不同模式(active或者passive)，以此适应顶层场景，所以不需要实现新的scoreboard，而是可以复用原有模块验证环境的scoreboard。</p>
<p><img src="https://img-blog.csdnimg.cn/20210226145501404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> mcdf_env1 <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	<span class="meta">`uvm_component_utils(mcdf_env1)</span></span><br><span class="line">	reg_env reg_e;</span><br><span class="line">	chnl_env chnl_e1;</span><br><span class="line">	chnl_env chnl_e2;</span><br><span class="line">	chnl_env chnl_e3;</span><br><span class="line">	fmt_env fmt_e;</span><br><span class="line">	arb_env arb_e;</span><br><span class="line">	mcdf_virtual_sequencer virt_sqr;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">		<span class="comment">//将子环境配置为active或者passive模式</span></span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "reg_e.slave", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "chnl_e1.slave", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "chnl_e1.reg_cfg", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "chnl_e2.slave", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "chnl_e2.reg_cfg", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "chnl_e3.slave", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "chnl_e3.reg_cfg", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "arb_e.master1", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "arb_e.master2", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "arb_e.master3", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "arb_e.slave", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "arb_e.reg_cfg", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "fmt_e.master", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		uvm_config_db<span class="variable">#(int)::set(this, "fmt_e.reg_cfg", "is_active", UVM_PASSIVE)</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建子环境</span></span><br><span class="line">		reg_e = reg_env::type_id::create(<span class="string">"reg_e"</span>, <span class="keyword">this</span>);</span><br><span class="line">		chnl_e1 = chnl_env::type_id::create(<span class="string">"chnl_e1"</span>, <span class="keyword">this</span>);</span><br><span class="line">		chnl_e2 = chnl_env::type_id::create(<span class="string">"chnl_e2"</span>, <span class="keyword">this</span>);</span><br><span class="line">		chnl_e3 = chnl_env::type_id::create(<span class="string">"chnl_e3"</span>, <span class="keyword">this</span>);</span><br><span class="line">		virt_sqr = mcdf_virtual_sequencer::type_id::create(<span class="string">"virt_sqr"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">		<span class="comment">//virtual sequencer connection</span></span><br><span class="line">		virt_sqr<span class="variable">.reg_sqr</span> = reg_e<span class="variable">.master</span><span class="variable">.sequencer</span>;</span><br><span class="line">		virt_sqr<span class="variable">.chnl_sqr1</span> = chnl_e1<span class="variable">.master</span><span class="variable">.sequencer</span>;</span><br><span class="line">		virt_sqr<span class="variable">.chnl_sqr2</span> = chnl_e2<span class="variable">.master</span><span class="variable">.sequencer</span>;</span><br><span class="line">		virt_sqr<span class="variable">.chnl_sqr3</span> = chnl_e3<span class="variable">.master</span><span class="variable">.sequencer</span>;</span><br><span class="line">		virt_sqr<span class="variable">.fmt_sqr</span> = fmt_e<span class="variable">.slave</span><span class="variable">.sequencer</span>;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h2 id="7-7-总结"><a href="#7-7-总结" class="headerlink" title="7.7 总结"></a>7.7 总结</h2><h3 id="1-方案1和方案2的区别"><a href="#1-方案1和方案2的区别" class="headerlink" title="1. 方案1和方案2的区别"></a>1. 方案1和方案2的区别</h3><p>方案一和方案二相同的地方在于，顶层都需要新建virtual sequencer和sequence，用来生成顶层的测试序列。而virtual sequencer也不是从零创建的，它本身也是利用原有模块环境的序列库，进行了有机的组合，最后协调生成了新的测试序列。从方案二可以看出，mcdf_env的子组件不再是uvm_agent类，而是各个模块的验证环境uvm_env类。通过直接复用这些子环境，也间接复用了它们内部的scoreboard，在build阶段，需要将各个子环境中不需要再产生激励的agent，配置为passive模式，而默认情况下这些agent均为active模式。这种复用方式使得我们无需再新建一个MCDF scoreboard，只需要确保MCDF的各个子模块都有scoreboard会检查功能，这样从整体上便可以覆盖完整的数据通路。</p>
<h3 id="2-UVM的环境复用相较于SV的优势"><a href="#2-UVM的环境复用相较于SV的优势" class="headerlink" title="2. UVM的环境复用相较于SV的优势"></a>2. UVM的环境复用相较于SV的优势</h3><ul>
<li>各个模块的验证环境是独立封装的，对外不需要保留数据端口，因此便于环境的进一步集成复用。</li>
<li>由于UVM自身的phase机制，在顶层协调各个子环境时，无需考虑由于子环境之间的例化顺序而导致的对象句柄引用悬空的问题。</li>
<li>由于子环境的测试序列是相对独立的，这使得顶层在复用子环境测试序列而构成<code>virtual sequence</code>时，不需要其它额外的迁移成本。</li>
<li>UVM提供的<code>config_db</code>配置方式，使得整体环境的结构和运行模式都可以从树状的<code>config</code>对象中获取，这也使得顶层环境可以在不同<code>uvm_test</code>进行集中管理配置。</li>
</ul>
<h1 id="8-环境构建的四要素"><a href="#8-环境构建的四要素" class="headerlink" title="8. 环境构建的四要素"></a>8. 环境构建的四要素</h1><p>在发送测试序列之前，首先需要创建一个结构化的环境，将环境建立的核心要素拆解开来，可以分为四个部分：</p>
<ul>
<li>单元组件的自闭性</li>
<li>回归创建</li>
<li>通信端口连接</li>
<li>顶层配置</li>
</ul>
<h2 id="8-1-自闭性"><a href="#8-1-自闭性" class="headerlink" title="8.1 自闭性"></a>8.1 自闭性</h2><p>自闭性指的是单元组件(例如uvm_agent或者uvm_env)自身可以成为独立行为、不依赖于其它并行的组件。举例来说，driver同sequencer之间，虽然driver需要获取sequencer的transaction item，但是它本身可以独立例化，而它们之间的通信也是基于TLM端对端的连接实现的。这种单元组件的自闭性为之后的组件复用提供了良好的基础，各个子环境也可以独立集成于顶层环境，互相也不需要额外的通信连接。</p>
<h2 id="8-2-回归创建"><a href="#8-2-回归创建" class="headerlink" title="8.2 回归创建"></a>8.2 回归创建</h2><p>通过回归创建这种方式，上一级的组件在例化自身(执行new()函数)之后，会执行各个phase阶段，通过build_phase可以进一步创建子组件，而这些子组件也通过一样的过程去创建下一级组件。</p>
<p>回归创建之所以可以实现，这要依赖于自顶向下执行顺序的build_phase。通过build_phase这种结构化执行顺序可以保证父组件必先于子组件创建，而创建过程还包括：</p>
<ul>
<li>在定义成员变量时赋予默认值，或者在new()函数赋予初始值。</li>
<li>结构配置变量用来决定组件的条件生成，例如uvm_agent依靠is_active变量来判断是否需要例化uvm_sequencer和uvm_driver。</li>
<li>模式配置变量用来决定各个子组件的工作模式。</li>
<li>子组件按照自顶向下、从前到后的顺序依次生成。</li>
</ul>
<h2 id="8-3-通信端口连接"><a href="#8-3-通信端口连接" class="headerlink" title="8.3 通信端口连接"></a>8.3 通信端口连接</h2><p>在完成了整个环境创建以后，各个组件会通过通信端口的连接进行数据通信，常见的端口通信用途包括：</p>
<ul>
<li>driver的端口连接到sequencer，并且对sequencer采取blocking pull的形式获取transaction item。</li>
<li>monitor的端口连接到scoreboard内部的analysis fifo，将监测的数据写入其中。</li>
</ul>
<h2 id="8-4-顶层配置"><a href="#8-4-顶层配置" class="headerlink" title="8.4 顶层配置"></a>8.4 顶层配置</h2><p>由于单元组件的自闭性，UVM结构不建议通过引用子环境句柄，继而索引更深层次的变量进行顶层配置，因此会增加顶层环境同子环境的粘性，无法做到更好的分离。</p>
<p>所以更好的方式是通过配置化对象，作为绑定于顶层环境的部分传递到子环境，而子环境的各个组件又可以从结构化配置对象中获取自身的配置参数，从而在build_phase、connect_phase以及run_phase中来决定它们的结构和运行模式。</p>
<p><img src="https://img-blog.csdnimg.cn/20210226164155795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /></p>
<p>顶层配置对象可以在子环境没有例化时就将其配置到将来会创建的子环境当中，无需考虑顶层配置对象会先于子环境生成，这也为UVM验证结构提供了安全的配置方式：</p>
<ul>
<li><p>无论在哪一层使用配置，应该尽量将所有配置都置于子组件创建之前，保证配置已经完成。</p>
</li>
<li><p>配置的作用域应该只关注当前层次及以下，而不涉及更高的层次。</p>
</li>
<li><p>配置的对象结构应该尽量独立，最好同环境结构一样形成一个树状结构。这样独立的配置对象会对应独立的子环境，如果将独立的配置合并为一个树状顶层配置结</p>
<p>构，那么顶层配置对象更便于使用和维护。</p>
</li>
<li><p>由于config_db的配置特性使得高层的配置会覆盖底层的配置，这也使得在uvm_test层次做出的配置可以控制整体的结构和模式。</p>
</li>
</ul>
<p><strong>顶层配置框图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210226165136819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>见config机制：变量，句柄，接口都可以在test层次上进行配置</p>
<h2 id="8-5-环境元素分类"><a href="#8-5-环境元素分类" class="headerlink" title="8.5 环境元素分类"></a>8.5 环境元素分类</h2><p>将uvm_test层作为比uvm_env更高的层次绘制出来，这是因为uvm_test层会有一些配置的部分传递给子环境。包括构成环境的组件uvm_component在内，环境元素可以分为以下部分：</p>
<ul>
<li>成员变量：一般变量、结构变量、模式变量。</li>
<li>子组件：固定组件、条件组件、引用组件。</li>
<li>子对象：自生对象、克隆对象、引用对象。</li>
</ul>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ul>
<li>一般变量用于对象内部的操作，或者为外部访问提供状态值。</li>
<li>结构变量则用来决定内部子组件是否需要创建和连接，例如顶层的is_active变量即用作该目的。</li>
<li>模式变量用来控制组件的行为，例如driver变量经过模式配置，可以在run_phase做出不同的激励行为。</li>
<li>对于结构变量和模式变量，一般由int或者enum类型定义，可以在uvm_test层通过uvm_config_db的配置方法直接设置，也可以通过结构化的配置对象来进行系统配置。对于复杂的验证环境，配置对象的方式会容易操作和维护。</li>
</ul>
<h3 id="子组件（固定，条件，引用）"><a href="#子组件（固定，条件，引用）" class="headerlink" title="子组件（固定，条件，引用）"></a>子组件（固定，条件，引用）</h3><ul>
<li><p>环境必须创建的组件称之为<strong>固定组件</strong>，例如agent中的monitor无论对于active模式或者passive模式，都需要创建，又或者顶层环境中的scoreboard，也需要创建来比较数据。</p>
</li>
<li><p><strong>条件组件</strong>则是通过结构变量的配置来决定是否需要创建，例如sequencer和driver只允许在active模式下创建。</p>
</li>
<li><p><strong>引用组件</strong>是内部声明一个类型句柄，同时通过自向下的句柄传递，使得该句柄可以指向外部的一个对象。例如在uvm_test一层，首先例化了一个寄存器模型</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210726200820.png" alt="image-20210726200813273" style="zoom:67%;" /></p>
<p>rgm(固定组件)，其后将该模型的句柄通过配置传递到reg_env层中的rgm句柄(引用组件)。利用引用组件的方式，使得环境各个层次在需要的情况下，都可以共享一个组件。</p>
</li>
</ul>
<h3 id="子对象"><a href="#子对象" class="headerlink" title="子对象"></a>子对象</h3><ul>
<li><p>在某一层中首先会创建一个对象，该对象可以称之为<strong>自生对象</strong>。</p>
</li>
<li><p>对象传递过程中，该对象经过克隆从而生成一个成员数值相同的对象，称之为<strong>克隆对象</strong>。</p>
</li>
<li><p>如果对象经过了端口传递，到达另一个组件，而该组件对其未经过克隆而直接进行操作的话，称之为<strong>引用对象的操作</strong>。例如在virtual sequence会生成送往</p>
<p>reg_master_agent和reg_slave_agent的transaction item，分别是mst_t和slv_t，这些连续发送的mst_t和slv_t通过uvm_sequencer，最终到达uvm_driver。</p>
<p>uvm_driver拿到这些transaction对象之后，如果首先进行克隆，而后利用克隆数据对象进行激励是一种方式；uvm_driver也可以不克隆数据对象而直接对这些对象(引用对象)进行操作。</p>
</li>
</ul>
<h1 id="9-TML通信"><a href="#9-TML通信" class="headerlink" title="9. TML通信"></a>9. TML通信</h1><h2 id="9-1-通信概论"><a href="#9-1-通信概论" class="headerlink" title="9.1 通信概论"></a>9.1 通信概论</h2><ul>
<li>TLM是一个基于事务（transaction）的通信方式，通常在高抽象级的语言中被引用作为模块之间的通讯方式，例如SystemC或者UVM。TLM成功地将模块内的计算和模块之间的通信从时间跨度方面剥离开了。</li>
</ul>
<ul>
<li>在实现的过程中，TLM通信需要两个通信的对象，这两个对象分别称之为initiator object和target  object。区分它们的方法在于，谁首先发起通信的要求，谁就属于initiator，而谁作为发起通信的响应方，谁就属于target。在初学过程中，读者们还应该注意，通信发起方并不代表了transaction的流向起点，即不一定数据是从initiator流向target，也可能是从target流向了initiator。因此，按照transaction的流向，我们又可以将两个对象分为producer和consumer。区分它们的方法是，数据从哪里产生，它就属于producer，而数据流向了哪里，它就属于consumer。</li>
</ul>
<p>从下面的这张图可以看出，initiator与target的关系同producer与consumer的关系，不是固定的。而有了两个参与通信的对象之后，用户需要将TLM的通信方法在target一端中实现，以便于initiator将来作为发起方可以调用target内的通信方法，实现数据传输。在target实现了必要的通信方法之后，最后一步需要将两个对象进行连接。这需要首先在两个对象内创建端口，继而在更高的层次中将这两个对象进行连接。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210716224448.png" alt="image-20210716224447966" style="zoom:67%;" /></p>
<p><strong>所以，抽象来看TLM通信的步骤可以分解为：</strong></p>
<ol>
<li>分辨出initiator和target，producer和consumer。</li>
<li><strong>在target中实现TLM通信方法</strong>。</li>
<li>在两个对象中创建TLM端口。</li>
<li>在更高的层次中将两个对象的端口进行连接。（initiator作为连接的发起端：。connect（））</li>
</ol>
<p>例如，monitor和checker：monitor是initator；generator和driver：driver是initator（通过get请求数据）</p>
<p><strong>从数据流向的方向来看，传输的方向可以分为单向（unidirection）和双向（bidirection）。</strong></p>
<ul>
<li>单向传输：由initiator发起request transaction。</li>
<li>双向传输：由initiator发起request transaction，传送至target；而target在消化了request transaction后，也会发起response transaction，继而返回给initiator。</li>
</ul>
<p><strong>端口的按照类型可以划分为三种：</strong></p>
<ul>
<li>port：经常作为initiator的发起端，也凭借port，initiator才可以访问target中实现的TLM通信方法。</li>
<li>export：作为initiator和target中间层次的端口。</li>
<li>imp：只能是作为target接收request的末端，它无法作为中间层次的端口，所以imp的连接无法再次延伸。</li>
</ul>
<p><strong>如果将传输方向和端口类型加以组合，就形成了TLM端口的继承树，TLM端口一共可以分为六类：</strong></p>
<ul>
<li><p>uvm_UNDIR_port #(trans_t)</p>
</li>
<li><p>uvm_UNDIR_export #(trans_t)</p>
</li>
<li><p>uvm_UNDIR_imp #(trans_t，imp_parent_t)</p>
<p>问：为啥imp就要多传入一个parent呢？</p>
<p>答：port和imp之间存在隔间，真正在顶层建立连接后，port通过connect找到imp，imp又通过其所在类的类名找到相应的方法给port调用</p>
</li>
<li><p>uvm_BIDIR_port #(req_trans_t，rsp_trans_t)</p>
</li>
<li><p>uvm_BIDIR_export #(req_trans_t，rsp_trans_t)</p>
</li>
<li><p>uvm_BIDIR_imp #(req_trans_t，imp_parent_t)</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210227145215296.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p>
<h3 id="端口使用"><a href="#端口使用" class="headerlink" title="端口使用"></a>端口使用</h3><p><img src="https://gitee.com/biongd/img/raw/master/img/20210716225157.png" alt="image-20210716225157393" style="zoom: 67%;" /></p>
<ul>
<li>就单向端口而言，声明port和export作为request发起方，需要指定transaction类型参数，而声明imp作为request接收方，不但需要指定transaction类型，也需要指定它所在的component类型。</li>
<li>就声明双向端口而言，指定参数需要考虑双向传输的因素，将传输类型transaction拆分为request transaction类型和response transaction类型。</li>
</ul>
<p><strong>从对应连接关系得出TLM端口连接的一般做法：</strong></p>
<ul>
<li>在initiator端例化port，在中间层次例化export，在target端例化imp。</li>
<li>多个port可以连接到同一个export或者imp，但是单个port或者export无法连接多个imp。</li>
<li>port应为request起点，imp应为request终点，而中间可以穿越多个层次。基于单元组件的自闭性考虑，在穿越的中间层次声明export，继而通过层次连接实现数据通路。</li>
<li>port可以连接port、export或者imp，export可以连接export或者imp，imp只能作为数据传送的终点，无法扩展连接。</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210716225726.png" alt="image-20210716225726756" style="zoom:67%;" /></p>
<p>代码实例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> request <span class="keyword">extends</span> uvm_transaction;</span><br><span class="line">	<span class="keyword">byte</span> cmd;</span><br><span class="line">	<span class="keyword">int</span> addr;</span><br><span class="line">	<span class="keyword">int</span> req;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> response <span class="keyword">extends</span> uvm_transaction;</span><br><span class="line">	<span class="keyword">byte</span> cmd;</span><br><span class="line">	<span class="keyword">int</span> addr;</span><br><span class="line">	<span class="keyword">int</span> rsp;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> comp1 <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">	uvm_blocking_get_port <span class="variable">#(request)</span> bg_port;</span><br><span class="line">	<span class="meta">`uvm_component_utils(comp1)</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> comp2 <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">	uvm_blocking_get_port <span class="variable">#(request)</span> bg_port;</span><br><span class="line">	uvm_noblocking_put_imp <span class="variable">#(request, comp2)</span> nbp_imp;</span><br><span class="line">	<span class="meta">`uvm_component_utils(comp2)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">bit</span> try_put(request req);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">bit</span> can_put();</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> comp3 <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">	uvm_blocking_transport_port <span class="variable">#(request, response)</span> bt_port;</span><br><span class="line">	<span class="meta">`uvm_component_utils(comp3)</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> comp4 <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">	uvm_blocking_get_imp <span class="variable">#(request, comp4)</span> bg_imp;</span><br><span class="line">	uvm_noblocking_put_port <span class="variable">#(request)</span> nbp_port;</span><br><span class="line">	<span class="meta">`uvm_component_utils(comp4)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> get(<span class="keyword">output</span> request req);</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> comp5 <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">	uvm_blocking_transport_imp <span class="variable">#(request ,response, comp5)</span> bt_imp;</span><br><span class="line">	<span class="meta">`uvm_component_utils(comp5)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> transport(request req, <span class="keyword">output</span> response rsp);</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> agent1 <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">	uvm_blocking_get_port <span class="variable">#(request)</span> bg_port;</span><br><span class="line">	uvm_noblocking_put_export <span class="variable">#(request)</span> nbp_exp;</span><br><span class="line">	uvm_blocking_transport_port <span class="variable">#(request, response)</span> bt_port;</span><br><span class="line">	comp1 c1;</span><br><span class="line">	comp2 c2;</span><br><span class="line">	comp3 c3;</span><br><span class="line">	<span class="meta">`uvm_component_utils(agent1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">		c1 = comp1::type_id::create(<span class="string">"c1"</span>, <span class="keyword">this</span>);</span><br><span class="line">		c2 = comp2::type_id::create(<span class="string">"c2"</span>, <span class="keyword">this</span>);</span><br><span class="line">		c3 = comp3::type_id::create(<span class="string">"c3"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">		c1<span class="variable">.bg_port</span><span class="variable">.connect</span>(<span class="keyword">this</span><span class="variable">.bg_port</span>);		<span class="comment">//connect左侧可以是initiator、export	，右侧是target	</span></span><br><span class="line">		c2<span class="variable">.bg_port</span><span class="variable">.connect</span>(<span class="keyword">this</span><span class="variable">.bg_port</span>);</span><br><span class="line">		<span class="keyword">this</span><span class="variable">.nbp_exp</span><span class="variable">.connect</span>(c2<span class="variable">.nbp_imp</span>);		<span class="comment">//连接方向从agent的export到c2的import</span></span><br><span class="line">		c3<span class="variable">.bt_port</span><span class="variable">.connect</span>(<span class="keyword">this</span><span class="variable">.bt_port</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">class</span> env1 <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	agent1 a1;</span><br><span class="line">	comp4 c4;</span><br><span class="line">	comp5 c5;</span><br><span class="line">	<span class="meta">`uvm_component_utils(env1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">		a1 = agent1::type_id::create(<span class="string">"a1"</span>, <span class="keyword">this</span>);</span><br><span class="line">		c4 = comp4::type_id::create(<span class="string">"c4"</span>, <span class="keyword">this</span>);</span><br><span class="line">		c5 = comp5::type_id::create(<span class="string">"c5"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">		a1<span class="variable">.bg_port</span><span class="variable">.connect</span>(c4<span class="variable">.bg_imp</span>);</span><br><span class="line">		c4<span class="variable">.nbp_port</span><span class="variable">.connect</span>(a1<span class="variable">.nbp_exp</span>);</span><br><span class="line">		a1<span class="variable">.bt_port</span><span class="variable">.connect</span>(c5<span class="variable">.bt_imp</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>从代码可以得出建立TLM通信的常规步骤：</p>
<ul>
<li>定义TLM传输中的数据类型，上面分别定义了request类和response类。</li>
<li>分别在各个层次的component中声明和创建TLM端口对象。</li>
<li>通过connect()函数完成端口之间的连接。</li>
<li>在imp端口类中要实现需要提供给initiator的可调用方法，例如在comp2中由于有一个<code>uvm_noblocking_put_imp #(request, comp2) nbp_imp</code>，因此需要实现两个方法<code>try_put()</code>和<code>can_put()</code>，而comp4中有一个<code>uvm_blocking_get_imp #(request, comp4) bg_imp</code>，则需要实现对应的方法<code>get()</code>。</li>
<li>需要注意的是，必须在imp端口类中实现对应方法，否则端口即使连接也无法实现数据传输。</li>
</ul>
<h2 id="9-2-单向通信"><a href="#9-2-单向通信" class="headerlink" title="9.2 单向通信"></a>9.2 单向通信</h2><p>单向通信指的是从initiator到target之间的数据流向是单一方向的，或者说initiator和target只能扮演producer和consumer中的一个角色。在UVM中，对应数据流向的TLM单向端口有很多的类型：</p>
<ul>
<li>uvm_blocking_put_PORT</li>
<li>uvm_nonblocking_put_PORT</li>
<li>uvm_put_PORT</li>
<li>uvm_blocking_get_PORT</li>
<li>uvm_nonblocking_get_PORT</li>
<li>uvm_get_PORT</li>
<li>uvm_blocking_peek_PORT</li>
<li>uvm_nonblocking_peek_PORT</li>
<li>uvm_peek_PORT</li>
<li>uvm_blocking_get_peek_PORT</li>
<li>uvm_nonblocking_get_peek_PORT</li>
<li>uvm_get_peek_PORT</li>
</ul>
<p>这里的PORT代表了三种端口名：port、export和imp。这么一计算的话，那么对于单一方向的传输端口一共有36种。看起来这么多的端口类型似乎对读者的记忆不太友好，实际上记忆这么多的端口名是有技巧的。按照每一个端口名的命名规则，它们也指出了通信的两个要素：</p>
<ul>
<li>是否是阻塞的方式（即可以等待延时）:blocking or nonblocking</li>
<li>何种通信方法：get or put or peek</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210716230533.png" alt="image-20210716230533075" style="zoom:80%;" /></p>
<p><strong>数据blocking阻塞传输的方法分别包含：</strong></p>
<ul>
<li>put：initiator通过该方法可以自己生成数据T t，同时将该数据传送至target。</li>
<li>get：initiator通过该方法可以从target获取数据T t，而target中的该数据则应消耗。</li>
<li>peek：initiator通过该方法可以从target获取数据T t，而target中的该数据还应该保留。</li>
</ul>
<p>此时target就相当于一个buffer，可以对数据进行存储~</p>
<p>特别注意：任务实现必须要task</p>
<p><strong>与上述三种task对应的nonblocking非阻塞的方法分别是：</strong></p>
<ul>
<li>try_put</li>
<li>can_put</li>
<li>try_get</li>
<li>can_get</li>
<li>try_peek</li>
<li>can_peek</li>
</ul>
<p>这六个函数与其对应的任务的区别在于，它们必须立即返回，如果try_xxx函数可以发送或者获取数据，那么函数还应该返回1，如果执行失败则应该返回0。或者通过can_xxx函数先试探target是否可以接收数据，通过返回值，再通过try_xxx函数发送，提高数据发送的成功率。</p>
<p>实例代码：</p>
<p>注意代码中相应方法的创建！！！</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> itrans <span class="keyword">extends</span> uvm_transaction;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> otrans <span class="keyword">extends</span> uvm_transaction;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> comp1 <span class="keyword">extends</span> uvm_component;</span><br><span class="line">	uvm_blocking_put_port <span class="variable">#(itrans)</span> bp_port;</span><br><span class="line">	uvm_nonblocking_get_port <span class="variable">#(otrans)</span> nbg_port;</span><br><span class="line">	<span class="meta">`uvm_component_utils(comp1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		itrans itr;</span><br><span class="line">		otrans otr;</span><br><span class="line">		<span class="keyword">int</span> trans_num = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">fork</span></span><br><span class="line">			<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trans_num; i++) <span class="keyword">begin</span></span><br><span class="line">					itr = <span class="keyword">new</span>(<span class="string">"itr"</span>, <span class="keyword">this</span>);</span><br><span class="line">					itr<span class="variable">.data</span> = <span class="number">'h10</span> + i;</span><br><span class="line">					<span class="keyword">this</span><span class="variable">.bp_port</span><span class="variable">.put</span>(itr);</span><br><span class="line">					<span class="meta">`uvm_info("PUT", $sformatf("put itrans id: 'h%0x, data: 'h%0x", itr.id, itr.data), UVM_LOW)</span></span><br><span class="line">				<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; trans_num; j++) <span class="keyword">begin</span></span><br><span class="line">					<span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">						<span class="keyword">if</span>(<span class="keyword">this</span><span class="variable">.nbg_port</span><span class="variable">.try_get</span>(otr) == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">						<span class="keyword">else</span> #<span class="number">1</span>ns;</span><br><span class="line">					<span class="keyword">end</span></span><br><span class="line">					<span class="meta">`uvm_info("TRYGET", $sformatf("get otrans id: 'h%0x, data: 'h%0x", otr.id, otr.data), UVM_LOW)</span></span><br><span class="line">				<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">join</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> comp2 <span class="keyword">extends</span> uvm_component;</span><br><span class="line">	uvm_blocking_put_imp <span class="variable">#(itrans, comp2)</span> bp_imp;</span><br><span class="line">	uvm_nonblocking_get_imp <span class="variable">#(otrans, comp2)</span> nbg_imp;</span><br><span class="line">    itrans itr_q[$];    <span class="comment">//同样需要自己声明队列</span></span><br><span class="line">	<span class="meta">`uvm_component_utils(comp2)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> put(itrans t);</span><br><span class="line">		itr_q<span class="variable">.push_back</span>(t);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">bit</span> try_get(<span class="keyword">output</span> otrans t);</span><br><span class="line">		itrans i;</span><br><span class="line">		<span class="keyword">if</span>(itr_q<span class="variable">.size</span>() != <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">			i = itr_q<span class="variable">.pop_front</span>();</span><br><span class="line">			t = <span class="keyword">new</span>(<span class="string">"t"</span>, <span class="keyword">this</span>);</span><br><span class="line">			t<span class="variable">.id</span> = i<span class="variable">.id</span>;</span><br><span class="line">			t<span class="variable">.data</span> = i<span class="variable">.data</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">bit</span> can_get();</span><br><span class="line">		<span class="keyword">if</span>(itr_q<span class="variable">.size</span>() != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> env1 <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	comp1 c1;</span><br><span class="line">	comp2 c2;</span><br><span class="line">	<span class="meta">`uvm_component_utils(env1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">		c1 = comp1::type_id::create(<span class="string">"c1"</span>, <span class="keyword">this</span>);</span><br><span class="line">		c2 = comp2::type_id::create(<span class="string">"c2"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">		c1<span class="variable">.bp_port</span><span class="variable">.connect</span>(c2<span class="variable">.bp_imp</span>);</span><br><span class="line">		c1<span class="variable">.nbg_port</span><span class="variable">.connect</span>(c2<span class="variable">.nbg_imp</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><code>class comp1</code>的run_phase任务：<code>bp_port.put(itr)</code>实际上并不是在comp1中定义put方法，而是在imp端或者说target端定义的put方法，这里就实现了通信的隔离！！这时实现put方法的可以是任一一个类~只有当bp_port上没有建立连接时才会报错！！！</p>
<p><strong>class comp2中的put方法</strong>：实际上就是将数据放入队列；get方法：就是将数据从队列中取出，此时initiator端可以直接调用这里定义的方法</p>
<h2 id="9-3-双向通信"><a href="#9-3-双向通信" class="headerlink" title="9.3 双向通信"></a>9.3 双向通信</h2><p>与单向通信相同的是，双向通信的两端也分为initiator和target，但是数据流向在端对端之间是双向的。双向通信中的两端同时扮演着producer和consumer的角色，而initiator作为request发起方，在发起request之后，还会等待response返回。</p>
<p>UVM双向端口分为以下类型：</p>
<ul>
<li>uvm_blocking_transport_PORT</li>
<li>uvm_nonblocking_transport_PORT</li>
<li>uvm_transport_PORT</li>
<li>uvm_blocking_master_PORT</li>
<li>uvm_nonblocking_master_PORT</li>
<li>uvm_master_PORT</li>
<li>uvm_blocking_slave_PORT</li>
<li>uvm_nonblocking_slave_PORT</li>
<li>uvm_slave_PORT </li>
</ul>
<p><strong>PORT代表了port、export</strong>，不能代表imp</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210716233058.png" alt="image-20210716233057904" style="zoom: 80%;" /></p>
<p>双向端口按照通信握手方式可以分为：</p>
<ul>
<li>transaction双向通信方式</li>
<li>master和slave双向通信方式</li>
</ul>
<p>transport端口通过<code>transport()</code>方法，可以在同一方法调用过程中完成REQ和RSP的发出和返回(未收到RSP就不结束)。</p>
<p>master和slave的通信方式必须分别通过put、get和peek的调用，使用两个方法才可以完成一次握手通信。master端口和slave端口的区别在于，当initiator作为master时，它会发起REQ送至target，而后再从target端获取RSP，当initiator使用slave端口时，它会先从target端获取REQ，而后将RSP送至target端。</p>
<h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><p><img src="https://img-blog.csdnimg.cn/20210227183607828.png" alt="在这里插入图片描述"></p>
<p>代码实例:</p>
<p>可以看到transport的方法实现非常简单，直接把REQ赋值给RSP（也可以进行修改后再赋值），齐活~</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> comp1 <span class="keyword">extends</span> uvm_component;</span><br><span class="line">	uvm_blocking_transport_port <span class="variable">#(itrans, otrans)</span> bt_port;</span><br><span class="line">	<span class="meta">`uvm_component_utils(comp1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		itrans itr;</span><br><span class="line">		otrans otr;</span><br><span class="line">		<span class="keyword">int</span> trans_num = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trans_num; i++) <span class="keyword">begin</span></span><br><span class="line">			itr = <span class="keyword">new</span>(<span class="string">"itr"</span>, <span class="keyword">this</span>);</span><br><span class="line">			itr<span class="variable">.id</span> = i;</span><br><span class="line">			itr<span class="variable">.data</span> = <span class="number">'h10</span> + i;</span><br><span class="line">			<span class="keyword">this</span><span class="variable">.bt_port</span><span class="variable">.transport</span>(itr, otr);</span><br><span class="line">			<span class="meta">`uvm_info("TRSPT", $sformatf("put itrans id: 'h%0x, data: 'h%0x | get otrans id: 'h%0x, data: 'h%0x", itr.id, itr.data, otr.id, otr.data), UVM_LOW)</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">		</span><br><span class="line"><span class="keyword">class</span> comp2 <span class="keyword">extends</span> uvm_component;</span><br><span class="line">	uvm_blocking_transport_imp <span class="variable">#(itrans, otrans, comp2)</span> bt_imp;</span><br><span class="line">	<span class="meta">`uvm_component_utils(comp2)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> transport(itrans req, <span class="keyword">output</span> otrans rsp);</span><br><span class="line">		rsp = <span class="keyword">new</span>(<span class="string">"rsp"</span>, <span class="keyword">this</span>);</span><br><span class="line">		rsp<span class="variable">.id</span> = req<span class="variable">.id</span>;</span><br><span class="line">		rsp<span class="variable">.data</span> = req<span class="variable">.data</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> env1 <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	comp1 c1;</span><br><span class="line">	comp2 c2;</span><br><span class="line">	<span class="meta">`uvm_component_utils(env1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">		c1 = comp1::type_id::create(<span class="string">"c1"</span>, <span class="keyword">this</span>);</span><br><span class="line">		c2 = comp2::type_id::create(<span class="string">"c2"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">		c1<span class="variable">.bt_port</span><span class="variable">.connect</span>(c2<span class="variable">.bt_imp</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h2 id="9-4-多向通信"><a href="#9-4-多向通信" class="headerlink" title="9.4 多向通信"></a>9.4 多向通信</h2><ul>
<li>多向通信这种方式服务的仍然是<strong>两个组件之间的通信</strong>，而不是多个组件之间的通信，毕竟多个组件的通信r仍然可以由基础的两个组件的通信方式来构建。</li>
<li>多向通信指的是，如果initiator与target之间的<strong>相同TLM端口数目超过一个</strong>时的处理解决办法。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210227185450915.png" alt="在这里插入图片描述"></p>
<p><strong>相同TLM端口数目超过一个</strong>，<strong>会产生什么问题呢</strong>？</p>
<ul>
<li><p>comp1有两个uvm_blocking_put_port，而comp2有两个uvm_blocking_put_imp端口。对于端口例化可以给不同名字，连接也可以通过不同名字来索引，但问题在于</p>
<p>comp2中需要实现两个task put(itrans t)，又因为不同端口之间要求在imp端口一侧实现专属方法，这就造成了方法命名冲突，即无法在comp2中定义两个同名的put任务。</p>
</li>
</ul>
<p><strong>解决方法：</strong></p>
<p>UVM通过端口宏声明方式来解决这一问题，它解决问题的核心在于让不同端口对应不同名的任务。UVM为解决多向通信问题的宏按照端口名的命名方式分为：</p>
<p><img src="https://img-blog.csdnimg.cn/20210227190542609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>实例代码：</p>
<p>最关键的就是头两句的宏定义</p>
<ul>
<li>initiator端不用管，该怎么定义怎么定义，调用方法也只需要<code>put()</code>就行了</li>
<li>target需要改动<ul>
<li>imp的端口声明，将宏定义括号中的扩展加进去：<code>uvm_blocking_put_imp_p1 #(itrans, comp2) bt_imp_p1;</code></li>
<li>方法声明类似：<code>task put_p1(itrans t);</code></li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">`uvm_blocking_put_imp_decl(_p1)</span></span><br><span class="line"><span class="meta">`uvm_blocking_put_imp_decl(_p2)</span></span><br><span class="line"><span class="keyword">class</span> comp1 <span class="keyword">extends</span> uvm_component;</span><br><span class="line">	uvm_blocking_put_port <span class="variable">#(itrans)</span> bp_port1;</span><br><span class="line">	uvm_blocking_put_port <span class="variable">#(itrans)</span> bp_port2;</span><br><span class="line">	<span class="meta">`uvm_component_utils(comp1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		itrans itr1, itr2;</span><br><span class="line">		<span class="keyword">int</span> trans_num = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">fork</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trans_num; i++) <span class="keyword">begin</span></span><br><span class="line">				itr1 = <span class="keyword">new</span>(<span class="string">"itr1"</span>, <span class="keyword">this</span>);</span><br><span class="line">				itr1<span class="variable">.id</span> = i;</span><br><span class="line">				itr1<span class="variable">.data</span> = <span class="number">'h10</span> + i;</span><br><span class="line">				<span class="keyword">this</span><span class="variable">.bp_port1</span><span class="variable">.put</span>(itr1);</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; trans_num; j++) <span class="keyword">begin</span></span><br><span class="line">				itr2 = <span class="keyword">new</span>(<span class="string">"itr2"</span>, <span class="keyword">this</span>);</span><br><span class="line">				itr2<span class="variable">.id</span> = i;</span><br><span class="line">				itr2<span class="variable">.data</span> = <span class="number">'h10</span> + i;</span><br><span class="line">				<span class="keyword">this</span><span class="variable">.bp_port2</span><span class="variable">.put</span>(itr2);</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">join</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> comp2 <span class="keyword">extends</span> uvm_component;</span><br><span class="line">	uvm_blocking_put_imp_p1 <span class="variable">#(itrans, comp2)</span> bt_imp_p1;</span><br><span class="line">	uvm_blocking_put_imp_p2 <span class="variable">#(itrans, comp2)</span> bt_imp_p2;</span><br><span class="line">	itrans itr_q[$];</span><br><span class="line">	semaphore key;</span><br><span class="line">	<span class="meta">`uvm_component_utils(comp2)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> put_p1(itrans t);</span><br><span class="line">		key<span class="variable">.get</span>();</span><br><span class="line">		itr_q<span class="variable">.push_back</span>(t);</span><br><span class="line">		<span class="meta">`uvm_info("PUTP1", $sformatf("get otrans id: 'h%0x, data: 'h%0x", t.id, t.data), UVM_LOW)</span></span><br><span class="line">		key<span class="variable">.put</span>();</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line">	<span class="keyword">task</span> put_p2(itrans t);</span><br><span class="line">		key<span class="variable">.get</span>();</span><br><span class="line">		itr_q<span class="variable">.push_back</span>(t);</span><br><span class="line">		<span class="meta">`uvm_info("PUTP2", $sformatf("get otrans id: 'h%0x, data: 'h%0x", t.id, t.data), UVM_LOW)</span></span><br><span class="line">		key<span class="variable">.put</span>();</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> env1 <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	comp1 c1;</span><br><span class="line">	comp2 c2;</span><br><span class="line">	<span class="meta">`uvm_component_utils(env1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">		c1 = comp1::type_id::create(<span class="string">"c1"</span>, <span class="keyword">this</span>);</span><br><span class="line">		c2 = comp2::type_id::create(<span class="string">"c2"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">		c1<span class="variable">.bt_port1</span><span class="variable">.connect</span>(c2<span class="variable">.bt_imp_p1</span>);</span><br><span class="line">		c1<span class="variable">.bt_port2</span><span class="variable">.connect</span>(c2<span class="variable">.bt_imp_p2</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h2 id="9-5-通信管道-插盘"><a href="#9-5-通信管道-插盘" class="headerlink" title="9.5 通信管道-插盘"></a>9.5 通信管道-插盘</h2><p>以上通信有一个共同的地方即都是端对端的方式，同时在target一端需要实现传输方法，例如put()或者get()。这种方式在实际使用过程中也不免会给用户带来一些烦恼：</p>
<ul>
<li>如何可以不自己实现这些传输方法，同时可以享受到TLM的好处</li>
<li>对于monitor、coverage collector等组件在传输数据时，会存在一端到多端的传输，如何解决这一问题</li>
</ul>
<h3 id="UVM-TLM-FIFO"><a href="#UVM-TLM-FIFO" class="headerlink" title="UVM_TLM_FIFO"></a>UVM_TLM_FIFO</h3><p><img src="https://img-blog.csdnimg.cn/202102271936515.png" alt="在这里插入图片描述"></p>
<ul>
<li>在一般TLM传输过程中，无论是initiator给target发起一个transaction，还是initiator从target获取一个transaction，transaction最终都会流向consumer中。consumer在没有分析transaction时，先将该对象存储到本地FIFO中。</li>
<li>需要分别在两个组件中例化端口，同时在target中实现相应的传输方法。多数情况下，需要实现的传输方法都是相似的，方法的主要内容即是为了实现一个数据缓存功能。</li>
<li>TLM_FIFO：uvm_tlm_fifo类是一个新组件，它继承于uvm_component类，而且已经预先内置了多个端口以及实现了多个对应方法。</li>
</ul>
<p>uvm_tlm_fifo的功能类似于mailbox，不同的地方在于uvm_tlm_fifo提供了各种端口可以使用，在initiator端例化put_port或者get_peek_port，来匹配uvm_tlm_fifo的端口类型。如果例化了其它类型的端口，uvm_tlm_fifo还提供put、get以及peek对应的端口</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uvm_put_imp <span class="variable">#(T，this_type)</span> blocking_put_export</span><br><span class="line">uvm_put_imp <span class="variable">#(T，this_type)</span> nonblocking_put_export</span><br><span class="line">uvm_get_peek_imp <span class="variable">#(T，this_type)</span> blocking_get_export</span><br><span class="line">uvm_get_peek_imp <span class="variable">#(T，this_type)</span> nonblocking_get_export</span><br><span class="line">uvm_get_peek_imp <span class="variable">#(T，this_type)</span> get_export</span><br><span class="line">uvm_get_peek_imp <span class="variable">#(T，this_type)</span> blocking_peek_export</span><br><span class="line">uvm_get_peek_imp <span class="variable">#(T，this_type)</span> nonblocking_peek_export</span><br><span class="line">uvm_get_peek_imp <span class="variable">#(T，this_type)</span> peek_export</span><br><span class="line">uvm_get_peek_imp <span class="variable">#(T，this_type)</span> blocking_get_peek_export</span><br><span class="line">uvm_get_peek_imp <span class="variable">#(T，this_type)</span> nonblocking_get_peek_export</span><br></pre></td></tr></table></figure>
<p>写作export，其本质还是imp，即target</p>
<h3 id="Analysis-Port"><a href="#Analysis-Port" class="headerlink" title="Analysis Port"></a>Analysis Port</h3><p><img src="https://img-blog.csdnimg.cn/2021022719531516.png" alt="在这里插入图片描述"></p>
<p>除了端对端的传输，在一些情况下还有多个组件会对同一个数据进行运算处理。如果这个数据从同一个源的TLM端口发出到达不同的组件，这就要求该种端口可以满足从一端到多端的需求。如果数据源端发生变化需要通知跟它关联的多个组件时，可以利用软件设计模式的观察者模式（广播模式）来实现。</p>
<p>观察者模式的核心在于：</p>
<ul>
<li>这是从一个initiator端到多个target端的方式。</li>
<li>analysis port采取的是“push”模式，即从initiator端调用多个target端的<strong>write()函数</strong>来实现数据传输。</li>
<li>调用write函数时，实际上是对所有target中的write函数进行遍历调用</li>
<li>因为函数时立即返回的，无论连接多少个target，都可以立即返回；且就算没有连接，调用write（）函数也不会报错！！！</li>
</ul>
<p>注意：这里target端的方法使用的是write函数</p>
<p>实例代码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initiator<span class="variable">.ap</span><span class="variable">.connect</span>(target1<span class="variable">.aimp</span>);</span><br><span class="line">initiator<span class="variable">.ap</span><span class="variable">.connect</span>(target2<span class="variable">.aimp</span>);</span><br><span class="line">initiator<span class="variable">.ap</span><span class="variable">.connect</span>(target3<span class="variable">.aimp</span>);</span><br></pre></td></tr></table></figure>
<h3 id="TLM-Analysis-FIFO（继承与tlm-fifo）"><a href="#TLM-Analysis-FIFO（继承与tlm-fifo）" class="headerlink" title="TLM Analysis FIFO（继承与tlm_fifo）"></a>TLM Analysis FIFO（继承与tlm_fifo）</h3><p><img src="https://gitee.com/biongd/img/raw/master/img/20210727103843.png" alt="image-20210727103843459" style="zoom:67%;" /></p>
<ul>
<li>由于analysis端口提出实现了一端到多端的TLM数据传输，而一个<strong>新的数据存储组件类uvm_tlm_analysis_fifo</strong>提供了可以搭配uvm_analysis_port端口、uvm_analysis_imp端口和write()函数。</li>
<li>uvm_tlm_analysis_fifo类继承于uvm_tlm_fifo，这表明它本身具有面向单一TLM端口的数据缓存特性，而同时该类又有一个uvm_analysis_imp端口analysis_export并且实现了write()函数：<code>uvm_analysis_imp #(T, uvm_tlm_analysis_fifo #(T)) analysis_export</code>;</li>
</ul>
<p>基于initiator到多个target的连接方式，如果实现一端到多端的数据传输，可以插入多个uvm_tlm_analysis_fifo，连接方式如下：</p>
<ul>
<li>将<strong>initiator的analysis port连接到tlm_analysis_fifo的analysis_export端口</strong>，这样数据可以从initiator发起，写入到各个tlm_analysis_fifo的缓存中。</li>
<li>将<strong>多个target的get_port连接到tlm_analysis_fifo的get_export端口</strong>，注意保持端口类型的匹配，这样从target一侧只需要调用get()方法就可以得到先前存储在tlm_analysis_fifo中的数据。</li>
</ul>
<p>总结：</p>
<ol>
<li>在一个analysis_port和多个analysis_imp之间加上，多个tml_analysis_fifo</li>
<li>把write方法和buffer都写到<code>tml_analysis_fifo</code>里面，每个<code>tml_analysis_fifo</code>预留两个imp端口</li>
</ol>
<h3 id="Request-amp-Response通信管道"><a href="#Request-amp-Response通信管道" class="headerlink" title="Request &amp; Response通信管道"></a>Request &amp; Response通信管道</h3><p>双向通信端口transport，即通过在target端实现transport()方法可以在一次传输中既发送request又可以接收response。UVM提供了两种简便的通信管道，它们作为数据缓存区域，既有TLM端口从外侧接收request和response，同时也有TLM端口供外侧获取request和response。</p>
<p>这两种TLM通信管道分别是<code>uvm_tlm_req_rsp_channel</code>和<code>uvm_tlm_transport_channel</code></p>
<ul>
<li><p><code>uvm_tlm_req_rsp_channel</code></p>
<p>它提供的端口首先是单一方向的</p>
<p><img src="https://img-blog.csdnimg.cn/20210227204205519.png" alt="在这里插入图片描述"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uvm_put_export <span class="variable">#(REQ)</span> put_request_export;</span><br><span class="line">uvm_put_export <span class="variable">#(RSP)</span> put_response_export;</span><br><span class="line">uvm_get_peek_export <span class="variable">#(RSP)</span> get_peek_response_export;</span><br><span class="line">uvm_get_peek_export <span class="variable">#(REQ)</span> get_peek_request_export;</span><br><span class="line">uvm_analysis_port <span class="variable">#(REQ)</span> request_ap;</span><br><span class="line">uvm_analysis_port <span class="variable">#(RSP)</span> response_ap;</span><br><span class="line">uvm_master_imp <span class="variable">#(REQ, RSP, this_type, uvm_tlm_fifo #(REQ), uvm_tlm_fifo #(RSP))</span> master_export;</span><br><span class="line">uvm_slave_imp <span class="variable">#(REQ, RSP, this_type, uvm_tlm_fifo #(REQ), uvm_tlm_fifo #(RSP))</span> slave_export;</span><br></pre></td></tr></table></figure>
<p>可以在使用成对的端口进行数据的存储和访问。需要注意的是，<code>uvm_tlm_req_rsp_channel</code>内部例化了两个mailbox分别用来存储request和response</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protect uvm_tlm_fifo <span class="variable">#(REQ)</span> m_request_fifo;</span><br><span class="line">protect uvm_tlm_fifo <span class="variable">#(RSP)</span> m_response_fifo;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>initiator端可以连接channel的put_request_export，target连接channel的get_peek_request_export</p>
</li>
<li><p>target连接channel的put_response_export，initiator连接channel的get_peek_response_export端口。</p>
</li>
</ul>
<p>通过这种对应的方式，使得initiator与target可以利用uvm_tlm_req_rsp_channel进行request与response的数据交换</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initiator<span class="variable">.put_port</span><span class="variable">.connect</span>(req_rsp_channel<span class="variable">.put_request_export</span>);</span><br><span class="line">target<span class="variable">.get_peek_port</span><span class="variable">.connect</span>(req_rsp_channel<span class="variable">.get_peek_request_export</span>);</span><br><span class="line">target<span class="variable">.put_port</span><span class="variable">.connect</span>(req_rsp_channel<span class="variable">.put_response_export</span>);</span><br><span class="line">initiator<span class="variable">.get_peek_port</span><span class="variable">.connect</span>(req_rsp_channel<span class="variable">.get_peek_response_export</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>也可以利用另一种连接方式</strong></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initiator<span class="variable">.master_port</span><span class="variable">.connect</span>(req_rsp_channel<span class="variable">.master_export</span>);</span><br><span class="line">target<span class="variable">.slave_port</span><span class="variable">.connect</span>(req_rsp_channel<span class="variable">.slave_export</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210227205409946.png" alt="在这里插入图片描述"></p>
<p>虽然看起来连接变少了，但put和get方法的调用还是和上面一样</p>
</li>
<li><p><code>uvm_tlm_transport_channel</code></p>
<p>在uvm_tlm_req_rsp_channel的基础上，UVM又添加了具备transport端口的管道组件uvm_tlm_transport_channel类，它<strong>继承于uvm_tlm_req_rsp_channel</strong>，并且例化了transport端口<code>uvm_transport_imp #(REQ, RSP, this_type) transport_export</code></p>
<p>新添加的这个TLM FIFO组件类型是针对于一些无法流水化处理的request和response传输，例如initiator一端要求每次发送完request，必须等到response接收到以后才可以发送下一个request，这时transport()方法就可以满足这一需求。<br><img src="https://img-blog.csdnimg.cn/20210227210405157.png" alt="在这里插入图片描述"></p>
<p>将initiator端到<code>req_rsp_channel</code>的连接修改为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initiator<span class="variable">.transport_port</span><span class="variable">.connect</span>(transport_channel<span class="variable">.transport_export</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="10-Sequence-和-Item"><a href="#10-Sequence-和-Item" class="headerlink" title="10. Sequence 和 Item"></a>10. Sequence 和 Item</h1><ul>
<li><code>sequence</code>指的是<code>uvm_sequence</code>类，而<code>item</code>指的是<code>uvm_sequence_item</code>类。</li>
<li>对于激励生成和场景控制，是由<code>sequence</code>来编织的，而对于激励所需要的具体数据和控制要求，则是从<code>item</code>的成员数据得到的。</li>
</ul>
<h2 id="10-1-Item"><a href="#10-1-Item" class="headerlink" title="10.1 Item"></a>10.1 Item</h2><p>item是基于uvm_object类，这表明了它具备UVM核心基类所必要的数据操作方法，例如copy()、clone()、compare()、record()。item根据数据成员的类型，将划分为：</p>
<ul>
<li>控制类。例如总线协议上的读写类型、数据长度、传送模式等。</li>
<li>负载类。一般指的是数据总线上的数据包。</li>
<li>配置类。用来控制driver的驱动行为，例如命令driver的发送间隔或者有无错误插入。</li>
<li>调试类。用来标记一些额外信息方便调试，例如该对象的实例序号、创建时间、被driver解析的时间始末等。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> bus_trans <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span> write;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> addr;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> delay;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> id_num;</span><br><span class="line">	<span class="meta">`uvm_object_utils_begin(bus_trans)</span></span><br><span class="line">		<span class="meta">`uvm_field_int ...</span></span><br><span class="line">	<span class="meta">`uvm_object_utils_end</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line">	<span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		bus_trans t1, t2;</span><br><span class="line">		phase<span class="variable">.raise_objection</span>(phase);</span><br><span class="line">		# <span class="number">100</span>ns;</span><br><span class="line">		t1 = <span class="keyword">new</span>(<span class="string">"t1"</span>);</span><br><span class="line">		t1<span class="variable">.print</span>();</span><br><span class="line">		#<span class="number">200</span>ns;</span><br><span class="line">		t2 = <span class="keyword">new</span>(<span class="string">"t2"</span>);</span><br><span class="line">		<span class="keyword">void</span>'(t2<span class="variable">.randomize</span>());</span><br><span class="line">		t2<span class="variable">.print</span>();</span><br><span class="line">		phase<span class="variable">.drop_objection</span>(phase);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20210301151700264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>item使用时的特点：</strong></p>
<ul>
<li>如果数据域属于需要用来做驱动，那么应考虑定义为rand类型，同时按照驱动协议给出合适的<strong>constraint。</strong></li>
<li>由于item本身的数据属性，为了充分利用UVM域声明的特性，将必要的数据成员都通过<strong>‘uvm_field_XXX宏来声明</strong>，方便使用基本数据方法自动实现。</li>
<li>t1没有被随机化而t2被随机化了，这种差别在item通往sequencer之前是很明显的。<strong>UVM要求item的创建和随机化都应该发生在sequence的body()任务中</strong>，而不是在sequencer或者driver中。</li>
<li>按照item对象的生命周期来区分，<strong>它的生命应该开始于sequence的body()方法，而后经历了随机化并穿越sequencer最终到达driver，直到被driver消化之后，它的生命一般来讲才会结束。</strong></li>
</ul>
<h2 id="10-2-Sequence"><a href="#10-2-Sequence" class="headerlink" title="10.2 Sequence"></a>10.2 Sequence</h2><p><strong>Item和Sequence的关系</strong>:</p>
<p>一个sequence可以包含一些有序组织起来的item实例，考虑到item在创建后需要被随机化，sequence在声明时也需要预留一些可供外部随机化的变量，这些随机变量一部分是用来通过层次传递约束来最终控制item对象的随机变量，一部分是用来对item对象之间加以组织和时序控制的。</p>
<p>为了区分几种常见的<code>sequence</code>定义方式，将其分类为：</p>
<ul>
<li>扁平类。这一类往往只用来组织更细小的粒度，即item实例构成的组织。</li>
<li>层次类。这一类是由更高层的sequence用来组织底层的sequence，进而让这些sequence按照顺序方法，或者按照并行方式，挂载到同一个sequencer上。</li>
<li>虚拟类。这一类则是最终控制整个测试场景的方式，鉴于整个环境中往往存在不同种类的sequencer和其对应的sequence，因此需要一个虚拟的sequence来协调顶层的测试场景。之所以称这个方式为虚拟类，是因为该序列本身并不会固定挂载于某一种sequencer类型上，而是将其内部不同类型sequence最终挂载到不同的目标sequencer上。</li>
</ul>
<h3 id="扁平类"><a href="#扁平类" class="headerlink" title="扁平类"></a>扁平类</h3><p>一个flat sequence往往是由细小的sequence item群落构成，在此之上sequence还有更多的信息来完备它需要实现的激励场景。</p>
<p>一般对于flat sequence而言，它包含的信息：</p>
<ul>
<li><p>sequence item以及相关的constraint用来关联生成的item之间的关系，从而完善出一个flat sequence的时序形态。</p>
</li>
<li><p>除了限制sequence item的内容，各个item之间的时序信息也需要由flat sequence给定，例如何时生成下一个item并且发送至driver。</p>
</li>
<li><p>对于需要driver握手的情况(例如读操作)，或者等待monitor事件从而做出反应(例如slave的memory response数据响应操作)，都需要sequence在收到另外一侧组件</p>
<p>的状态后，再决定下一步操作，即响应具体事件从而创建对应的item并且发送出去。</p>
</li>
</ul>
<p><code>flat sequence</code>示例1</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> flat_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> addr;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> data[];</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span> write;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> delay;</span><br><span class="line">	<span class="keyword">constraint</span> cstr&#123;</span><br><span class="line">		data<span class="variable">.size</span>() == length;</span><br><span class="line">		<span class="keyword">foreach</span>(data[i])  <span class="keyword">soft</span> data[i] == i;</span><br><span class="line">		<span class="keyword">soft</span> addr == <span class="number">'h100</span>;</span><br><span class="line">		<span class="keyword">soft</span> write == <span class="number">1</span>;</span><br><span class="line">		delay <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">5</span>]&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="meta">`uvm_object_utils(flat_seq)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		bus_trans tmp;</span><br><span class="line">		<span class="keyword">foreach</span>(data[i]) <span class="keyword">begin</span></span><br><span class="line">			tmp = <span class="keyword">new</span>();</span><br><span class="line">			tmp<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;</span><br><span class="line">				data == <span class="keyword">local</span>::data[i];</span><br><span class="line">				addr == <span class="keyword">local</span>::addr + i &lt;&lt; <span class="number">2</span>;</span><br><span class="line">				write == <span class="keyword">local</span>::write;</span><br><span class="line">				delay == <span class="keyword">local</span>::delay;</span><br><span class="line">			&#125;;</span><br><span class="line">			tmp<span class="variable">.print</span>();</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line">	<span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);	</span><br><span class="line">		flat_seq seq;</span><br><span class="line">		phase<span class="variable">.raise_objection</span>(phase);</span><br><span class="line">		seq = <span class="keyword">new</span>();</span><br><span class="line">		seq<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;addr == <span class="number">'h200</span>; length == <span class="number">100</span>&#125;;</span><br><span class="line">		seq<span class="variable">.body</span>();</span><br><span class="line">		phase<span class="variable">.drop_objection</span>(phase);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><code>flat sequence</code>示例2</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> bus_trans <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span> write;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> data[];	<span class="comment">//颗粒度变大，可以传输更多的数据</span></span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> addr;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> delay;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> id_num;</span><br><span class="line">	<span class="keyword">constraint</span> cstr&#123;</span><br><span class="line">		data<span class="variable">.size</span>() == length;</span><br><span class="line">		<span class="keyword">foreach</span>(data[i])  <span class="keyword">soft</span> data[i] == i;</span><br><span class="line">		<span class="keyword">soft</span> addr == <span class="number">'h100</span>;</span><br><span class="line">		<span class="keyword">soft</span> write == <span class="number">1</span>;</span><br><span class="line">		delay <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">5</span>]&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="meta">`uvm_object_utils_begin(bus_trans)</span></span><br><span class="line">		<span class="meta">`uvm_field_int ...</span></span><br><span class="line">	<span class="meta">`uvm_object_utils_end</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> flat_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> addr;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> length;</span><br><span class="line">	<span class="meta">`uvm_object_utils(flat_seq)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		bus_trans tmp;</span><br><span class="line">		tmp<span class="variable">.new</span>();</span><br><span class="line">		tmp<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;length == <span class="keyword">local</span>::length;</span><br><span class="line">							  addr == <span class="keyword">local</span>::addr;&#125;;</span><br><span class="line">		tmp<span class="variable">.print</span>();</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line">	<span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);	</span><br><span class="line">		flat_seq seq;</span><br><span class="line">		phase<span class="variable">.raise_objection</span>(phase);</span><br><span class="line">		seq = <span class="keyword">new</span>();</span><br><span class="line">		seq<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;addr == <span class="number">'h200</span>; length == <span class="number">3</span>&#125;;</span><br><span class="line">		seq<span class="variable">.body</span>();</span><br><span class="line">		phase<span class="variable">.drop_objection</span>(phase);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>这个示例将一段完整发生在数据传输中的、更长的数据都“收编”在一个bug_trans类中，<strong>提高这个item粒度的抽象层次</strong>，使得item更成熟、更适合切割。这样<strong>flat sequence更倾向于控制，不用去关注数据内容</strong>，而只关注这个数据包的长度、地址等信息即可，<strong>扩充随机数据的责任一般由item负责</strong></p>
<h3 id="层次类"><a href="#层次类" class="headerlink" title="层次类"></a>层次类</h3><ul>
<li><p>hierarchical sequence区别于flat sequence的地方在于，它可以使用其他sequence，还有item，这么做是为了创建更丰富的激励场景。</p>
</li>
<li><p>通过层次嵌套关系，可以让hierarchical sequence使用其它hierarchical sequence、flat sequence和sequence item，这也就意味着，如果底层的sequence item和</p>
<p>flat sequence的粒度得当，那么就可以充分复用这些flat sequence和sequence来构成形式更多样的hierarchical sequence。</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> hier_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	<span class="meta">`uvm_object_utils(hier_seq)</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">"hier_seq"</span>);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		bus_trans t1, t2;</span><br><span class="line">		flat_seq s1, s2;</span><br><span class="line">		<span class="meta">`uvm_do_with(t1, &#123;length == 2;&#125;)</span></span><br><span class="line">		<span class="keyword">fork</span></span><br><span class="line">			<span class="meta">`uvm_do_with(s1, &#123;length == 5;&#125;)</span></span><br><span class="line">			<span class="meta">`uvm_do_with(s2, &#123;length == 8;&#125;)</span></span><br><span class="line">		<span class="keyword">join</span></span><br><span class="line">		<span class="meta">`uvm_do_with(t2, &#123;length == 3;&#125;)</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h1 id="11-Sequencer和driver"><a href="#11-Sequencer和driver" class="headerlink" title="11. Sequencer和driver"></a>11. Sequencer和driver</h1><p><img src="https://img-blog.csdnimg.cn/20210301173241577.png" alt="在这里插入图片描述" style="zoom:80%;" /></p>
<p>driver同sequencer之间的TLM通信采取了get模式，即由driver发起请求，从sequencer一端获得item，再由sequencer将其传递至driver。作为driver，永远停不下来，只要它可以从sequencer获取item，它就一直工作。sequencer和item只应该在合适的时间点产生需要的数据，而至于怎么处理数据，则会由driver来实现。</p>
<p>sequencer是sequence和driver之间的一道关卡，里面只有RSP的fifo，没有REQ的fifo。REQ类型的item到sequencer一侧时就被卡住，driver发送request信号时就开闸放行~</p>
<p>为了便于item传输，UVM专门定义了匹配的TLM端口供sequencer和driver使用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uvm_seq_item_pull_port <span class="variable">#(type REQ=int, type RSP=REQ)</span></span><br><span class="line">uvm_seq_item_pull_export <span class="variable">#(type REQ=int, type RSP=REQ)</span></span><br><span class="line">uvm_seq_item_pull_imp <span class="variable">#(type REQ=int, type RSP=REQ, type imp=int)</span></span><br></pre></td></tr></table></figure>
<p>由于<code>driver</code>是请求发起端，所以<code>driver</code>一侧例化了下面两种端口：</p>
<p>一般只用第一种就够了</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uvm_seq_item_pull_port <span class="variable">#(REQ, RSP)</span> seq_item_port;</span><br><span class="line">uvm_analysis_port <span class="variable">#(RSP)</span> rsp_port;</span><br></pre></td></tr></table></figure>
<p>而<code>sequencer</code>一侧则为请求的响应端，在<code>sequencer</code>一侧例化了对应的两种端口：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uvm_seq_item_pull_imp <span class="variable">#(REQ, RSP, this_type)</span> seq_item_export</span><br><span class="line">uvm_analysis_export <span class="variable">#(RSP)</span> rsp_export</span><br></pre></td></tr></table></figure>
<h2 id="11-1-端口和方法"><a href="#11-1-端口和方法" class="headerlink" title="11.1 端口和方法"></a>11.1 端口和方法</h2><p>通常情况下，可以通过匹配的一对TLM端口完成item的完整传送，即driver::seq_item_port和sequencer::seq_item_export。这一对端口在连接时同其它端口连接方式一样，即通过driver::seq_item_port.connect(sequencer::seq_item_export)完成。这一类端口功能主要用来实现driver与sequencer的request获取和response返回。</p>
<p>这一种类型的TLM端口支持如下方法：</p>
<p>本身端口类就是从tlm端口继承而来，所以get，peek，put方法都在</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采取blocking的方式等待从sequence获取下一个item</span></span><br><span class="line"><span class="keyword">task</span> get_next_item(<span class="keyword">output</span> REQ req_arg)</span><br><span class="line"><span class="comment">//采取blocking的方式等待从sequence获取下一个item，如果立即返回的结果req_arg为null，则表示sequence还没有准备好</span></span><br><span class="line"><span class="keyword">task</span> try_next_item(<span class="keyword">output</span> REQ req_arg)</span><br><span class="line"><span class="comment">//用来通知sequence当前的sequence item已经消化完毕，可以选择性地传递RSP参数，返回状态值。</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> item_done(<span class="keyword">input</span> RSP rsp_arg=<span class="literal">null</span>)</span><br><span class="line"><span class="comment">//等待当前的sequence直到产生下一个有效的item</span></span><br><span class="line"><span class="keyword">task</span> wait_for_sequences()</span><br><span class="line"><span class="comment">//如果当前的sequence准备好而且可以获取下一个有效item，则返回1，否则返回0</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> has_do_available()</span><br><span class="line"><span class="comment">//采取nonblocking方式发送response，如果成功返回1，否则返回0</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> put_response(<span class="keyword">input</span> RSP rsp_arg)</span><br><span class="line"><span class="comment">//采用get方式获取item</span></span><br><span class="line"><span class="keyword">task</span> get(<span class="keyword">output</span> REQ req_arg)</span><br><span class="line"><span class="comment">//采用peek方式获取item</span></span><br><span class="line"><span class="keyword">task</span> peek(<span class="keyword">output</span> REQ req_arg)</span><br><span class="line"><span class="comment">//采取blocking方式将response发送回sequence</span></span><br><span class="line"><span class="keyword">task</span> put(<span class="keyword">input</span> RSP rsp_arg)</span><br></pre></td></tr></table></figure>
<p>关于<code>REQ</code>和<code>RSP</code>类型的一致性，由于<code>uvm_sequencer</code>与<code>uvm_driver</code>实际上都是参数化的类：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uvm_sequencer <span class="variable">#(type REQ=uvm_sequence_item, RSP=REQ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这有一个潜在的类型转换要求，即driver得到REQ对象在进行下一步处理时，</span></span><br><span class="line"><span class="comment">//需要进行动态的类型转换，将REQ转换为uvm_sequence_item的子类型才可以从中获取有效的成员数据。</span></span><br><span class="line">uvm_driver <span class="variable">#(type REQ=uvm_sequence_item, RSP=REQ)</span></span><br></pre></td></tr></table></figure>
<p>通常情况下RSP类型与REQ类型保持一致，这么做的好处是为了便于统一处理，方便item对象的拷贝、修改等操作。driver消化完当前的request后，可以通过</p>
<p>item_done(input RSP rsp_arg=null)方法来告知sequence此次传输已经结束，参数中的RSP可以选择填入，返回相应的状态值。driver也可以通过put_response()或者</p>
<p>put()方法来单独发送response。此外发送response还可以通过成对的uvm_driver::rsp_port和uvm_driver::rsp_export端口来完成，方法为</p>
<p>uvm_driver::rsp_port::write(RSP)。</p>
<h2 id="11-2-item传输实例"><a href="#11-2-item传输实例" class="headerlink" title="11.2 item传输实例"></a>11.2 item传输实例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> bus_trans <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="meta">`uvm_object_utils_begin(bus_trans)</span></span><br><span class="line">		<span class="meta">`uvm_field_int(data, UVM_ALL_ON)</span></span><br><span class="line">	<span class="meta">`uvm_object_utils_end</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> flat_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	<span class="meta">`uvm_object_utils(flat_seq)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		uvm_sequence_item tmp;</span><br><span class="line">		bus_trans req, rsp;</span><br><span class="line">		tmp = create_item(bus_trans::get_type(), m_sequencer, <span class="string">"req"</span>);</span><br><span class="line">		<span class="keyword">void</span>'(<span class="built_in">$cast</span>(req, tmp));</span><br><span class="line">		start_item(req);</span><br><span class="line">		req<span class="variable">.randomize</span> <span class="keyword">with</span> &#123;data == <span class="number">10</span>;&#125;;</span><br><span class="line">		<span class="meta">`uvm_info("SEQ", $sformatf("sent a item \n %s", req.sprint()), UVM_LOW)</span></span><br><span class="line">		finish_item(req);</span><br><span class="line">		get_response(tmp);</span><br><span class="line">		<span class="keyword">void</span>'(<span class="built_in">$cast</span>(rsp, tmp));</span><br><span class="line">		<span class="meta">`uvm_info("SEQ", $sformatf("got a item \n %s", rsp.sprint()), UVM_LOW)</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> sequencer <span class="keyword">extends</span> uvm_sequencer;</span><br><span class="line">	<span class="meta">`uvm_component_utils(sequencer)</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> driver <span class="keyword">extends</span> uvm_driver;</span><br><span class="line">	<span class="meta">`uvm_component_utils(driver)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		REQ tmp;</span><br><span class="line">		bus_trans req, rsp;</span><br><span class="line">		seq_item_port<span class="variable">.get_next_item</span>(tmp);</span><br><span class="line">		<span class="keyword">void</span>'(<span class="built_in">$cast</span>(req, tmp));</span><br><span class="line">		<span class="meta">`uvm_info("DRV", $sformatf("got a item \n %s", rsp.sprint()), UVM_LOW)</span></span><br><span class="line">		<span class="keyword">void</span>'(<span class="built_in">$cast</span>(rsp, req<span class="variable">.clone</span>()));</span><br><span class="line">		rsp<span class="variable">.set_sequence_id</span>(req<span class="variable">.get_sequence_id</span>());</span><br><span class="line">		rsp<span class="variable">.data</span> += <span class="number">100</span>;</span><br><span class="line">		seq_item_port_done(rsp);</span><br><span class="line">		<span class="meta">`uvm_info("DRV", $sformatf("sent a item \n %s", rsp.sprint()), UVM_LOW)</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> env <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	sequencer sqr;</span><br><span class="line">	driver drv;</span><br><span class="line">	<span class="meta">`uvm_component_utils(env)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		sqr = sequencer::type_id::create(<span class="string">"sqr"</span>, <span class="keyword">this</span>);</span><br><span class="line">		drv = driver::type_id::create(<span class="string">"drv"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		drv<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sqr<span class="variable">.seq_item_export</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line">	env e;</span><br><span class="line">	<span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		e = env::type_id::create(<span class="string">"e"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);	</span><br><span class="line">		flat_seq seq;</span><br><span class="line">		phase<span class="variable">.raise_objection</span>(phase);</span><br><span class="line">		seq = <span class="keyword">new</span>();</span><br><span class="line">		seq<span class="variable">.start</span>(e<span class="variable">.sqr</span>);</span><br><span class="line">		phase<span class="variable">.drop_objection</span>(phase);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><strong>解析：</strong></p>
<p>在定义sequencer时，默认了REQ类型为uvm_sequence_item类型，这与定义driver时采取默认REQ类型保持一致。</p>
<p>flat_seq作为动态创建的数据生成载体，它的主任务flat_seq::body()做了下面几件事情：</p>
<ul>
<li><p>通过方法create_item()创建request item对象。</p>
</li>
<li><p>调用start_item()准备发送item（立刻返回）。</p>
</li>
<li><p>在完成发送item之前对item进行随机处理。</p>
</li>
<li><p>调用finish_item()完成item发送（阻塞，等待sequencer放行）。</p>
</li>
<li><p>有必要的情况下可以从driver获取response item。（</p>
<p>​    注意：这里的get_response(tmp)，是要和driver匹配的，driver返回RSP，这里就接收，driver不返回，这里就不能写，否则就被阻塞</p>
<p>）</p>
</li>
<li><p>把get到的uvm_sequence_item返回类型进行类型转换</p>
</li>
</ul>
<p>在定义driver时，它的主任务driver::run_phase()也应通常做出如下处理：</p>
<ul>
<li>通过seq_item_port.get_next_item(REQ)从sequencer获取有效的request item。</li>
<li>从request item中获取数据，进而产生数据激励。</li>
<li>对request item进行克隆生成新的对象response item。</li>
<li>修改response item中的数据成员，最终通过seq_item_port.item_done(RSP)将response item对象返回给sequence。</li>
</ul>
<p><strong>注意点：</strong></p>
<p>对于uvm_sequence::get_response(RSP)和uvm_driver::item_done(RSP)这种成对得到操作，是可选的而不是必须的，即可以选择uvm_driver不返回response item，同时sequence也无需获取response item。</p>
<p>在高层环境中，应该在connect_phase中完成driver到sequencer的TLM端口连接，比如在env::connect_phase()中通过drv.seq_item_port.connect(sqr.seq_item_export)完成了driver与sequencer的连接。</p>
<p>在完成了flat_seq、sequencer、driver和env的定义后，到了test1层，除了需要考虑挂起objection防止提前退出，便可以利用uvm_sequence类的方法uvm_sequence::start(SEQUENCER)来实现sequence到sequencer的挂载。</p>
<h2 id="11-3-通信时序"><a href="#11-3-通信时序" class="headerlink" title="11.3 通信时序"></a>11.3 通信时序</h2><p><img src="https://img-blog.csdnimg.cn/20210301204714102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>无论是sequence还是driver，它们通话的对象都是sequencer。当多个sequence试图挂载到同一个sequencer上时，涉及sequencer的仲裁功能。</li>
<li>对于sequence而言，无论是flat sequence还是hierarchical sequence，进一步切分的话，流向sequencer的都是sequence item，所以就每个item的”成长周期“来看，它起始于create_item()，继而通过start_item()尝试从sequencer获取可以通过的权限。</li>
<li>driver一侧将一直处于”吃不饱“的状态，如果没有了item可以使用，将调用get_next_item()来尝试从sequencer一侧获取item。</li>
<li>在sequencer将通过权限交给某一个底层的sequence前，目标sequence中的item应该完成随机化，继而在获取sequencer的通过权限后，执行finish_item()。<br>接下来sequence中的item将穿过sequencer到达driver一侧，这个重要节点标志着sequencer第一次充当通信桥梁的角色已经完成。</li>
<li>driver在得到新的item后，会提取有效的数据信息，将其驱动到与DUT连接的接口上面。在完成驱动后，driver通过item_done()告知sequence已经完成数据传送，而sequence在获取该消息后，则表示driver与sequence双方完成了这一次item的握手传输。在这次传递中，driver可以选择将RSP作为状态返回值传递给sequence，而sequence也可以选择调用get_response(RSP)等待从driver一侧获取返回的数据对象。</li>
</ul>
<h1 id="12-Sequence-和-Sequencer"><a href="#12-Sequence-和-Sequencer" class="headerlink" title="12. Sequence 和 Sequencer"></a>12. Sequence 和 Sequencer</h1><p>sequencer就是组件，和driver，monitor一起被封装到同一个agent，在agent中和driver建立连接</p>
<p>sequence就是激励源，利用trans的内部约束和sequence中定义的外部约束，create_item(bus_trans::get_type(), m_sequencer, “req”)</p>
<p>item和sequence都是挂载到sequencer上的，item在sequence的body方法中创建时，挂载到m_sequencer，如上</p>
<p>如果底层的sequence在顶层的sequence创建，同样可以调用宏挂载到m_sequencer（<code>cseq.start(m_sequencer, this);</code>），也就是和顶层挂载到同一个sequencer上，此时顶层seq在test类中挂载到sequencer组件时，顶层seq内的所有底层seq同样实现挂载</p>
<p>可以在顶层seq对底层的seq进行配置，如</p>
<ul>
<li><p>随机化创建：<code>uvm_do_with(seq, {freq == 150;})</code></p>
</li>
<li><p>设置sequencer的仲裁器（<code>m_sequencer.set_arbitration(UVM_SEQ_ARB_STRICT_FIFO);</code>）</p>
</li>
<li>设置底层seq的优先级：<code>`uvm_do_pri_with(seq1, 500, {base == 10;})</code></li>
</ul>
<p><strong>sequence和item发送实例</strong></p>
<p>sequence 只需要在test中装载到sequencer中，sequence类中就可以直接使用sequencer句柄“m_sequencer”，包括sequence类中实例化的低层sequence，也可以装载到该句柄</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> bus_trans <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="meta">`uvm_object_utils_begin(bus_trans)</span></span><br><span class="line">		<span class="meta">`uvm_field_int(data, UVM_ALL_ON)</span></span><br><span class="line">	<span class="meta">`uvm_object_utils_end</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> child_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	<span class="meta">`uvm_object_utils(child_seq);</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		uvm_sequence_item tmp;</span><br><span class="line">		bus_trans req, rsp;</span><br><span class="line">		tmp = create_item(bus_trans::get_type(), m_sequencer, <span class="string">"req"</span>);</span><br><span class="line">		<span class="keyword">void</span>'(<span class="built_in">$cast</span>(req, tmp));</span><br><span class="line">		start_item(req);</span><br><span class="line">		req<span class="variable">.randomize</span> <span class="keyword">with</span> &#123;data == <span class="number">10</span>;&#125;;</span><br><span class="line">		finish_item(req);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> top_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	<span class="meta">`uvm_object_utils(top_seq)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		uvm_sequence_item tmp;</span><br><span class="line">		child_seq cseq;</span><br><span class="line">		bus_trans req;</span><br><span class="line">		<span class="comment">//create child sequence and items</span></span><br><span class="line">		cseq = child_seq::type_id::create(<span class="string">"cseq"</span>);</span><br><span class="line">		tmp = create_item(bus_trans<span class="variable">.get_type</span>(), m_sequencer, <span class="string">"req"</span>);</span><br><span class="line">		<span class="comment">//send child sequence via start()</span></span><br><span class="line">		cseq<span class="variable">.start</span>(m_sequencer, <span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//send sequence item</span></span><br><span class="line">		<span class="keyword">void</span>'(<span class="built_in">$cast</span>(req, tmp));</span><br><span class="line">		start_item(req);</span><br><span class="line">		req<span class="variable">.randomize</span> <span class="keyword">with</span> &#123;data == <span class="number">20</span>;&#125;;</span><br><span class="line">		finish_item(req);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> sequencer <span class="keyword">extends</span> uvm_sequencer;</span><br><span class="line">	<span class="meta">`uvm_component_utils(sequencer)</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> driver <span class="keyword">extends</span> uvm_driver;</span><br><span class="line">	<span class="meta">`uvm_component_utils(driver)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		REQ tmp;</span><br><span class="line">		bus_trans req;</span><br><span class="line">		<span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">			seq_item_port<span class="variable">.get_next_item</span>(tmp);</span><br><span class="line">			<span class="keyword">void</span>'(<span class="built_in">$cast</span>(req, tmp));</span><br><span class="line">			<span class="meta">`uvm_info("DRV", $sformatf("got a item \n %s", req.sprint()), UVM_LOW)</span></span><br><span class="line">			seq_item_port<span class="variable">.item_done</span>();</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> env <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	sequencer sqr;</span><br><span class="line">	driver drv;</span><br><span class="line">	<span class="meta">`uvm_component_utils(env)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		sqr = sequencer::type_id::create(<span class="string">"sqr"</span>, <span class="keyword">this</span>);</span><br><span class="line">		drv = driver::type_id::create(<span class="string">"drv"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		drv<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sqr<span class="variable">.seq_item_export</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line">	env e;</span><br><span class="line">	<span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		e = env::type_id::create(<span class="string">"e"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		top_seq seq;</span><br><span class="line">		phase<span class="variable">.raise_objection</span>(phase);</span><br><span class="line">		seq = <span class="keyword">new</span>();</span><br><span class="line">		seq<span class="variable">.start</span>(e<span class="variable">.sqr</span>);</span><br><span class="line">		phase<span class="variable">.drop_objection</span>(phase);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h2 id="12-1-发送sequence-item方法解析"><a href="#12-1-发送sequence-item方法解析" class="headerlink" title="12.1 发送sequence/item方法解析"></a>12.1 发送sequence/item方法解析</h2><p>在这段代码中，主要使用了两种方法:</p>
<p>第一个方法：将<code>sequence</code>挂载到<code>sequencer</code>上</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uvm_sequence::start(uvm_sequencer_base_sequence, uvm_sequence_base_parent_sequence=<span class="literal">null</span>, <span class="keyword">int</span> this_priority=-<span class="number">1</span>, <span class="keyword">bit</span> call_pre_post=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在使用该方法的过程中，首先应该指明sequencer的句柄，如果该sequence是顶部的sequence，即没有更上层的sequence嵌套它，则它可以省略对第二个参数parent_sequence的指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三个参数的默认值是-1，会使得该sequence如果有parent_sequence会继承其优先级值，如果它是顶部(root)sequence，则其优先级会被自动设定为100。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四个参数默认值为1，默认uvm_sequence::pre_body()和uvm_sequence::post_body()两个方法会在uvm_sequence::body()的前后执行</span></span><br></pre></td></tr></table></figure>
<p>示例中<code>child_seq</code>被嵌套到<code>top_seq</code>中，继而在挂载时需要指定<code>parent_sequence</code>，而在<code>test</code>一层调用<code>top_seq</code>时，由于它是<code>root sequence</code>，则不需要再指定<code>parent sequence</code>。</p>
<p>第二种发送方法：item<code>挂载到</code>sequencer上</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uvm_sequence::start_item(uvm_sequence_item item, <span class="keyword">int</span> set_priority=-<span class="number">1</span>, uvm_sequencer_base_sequence=<span class="literal">null</span>);</span><br><span class="line">uvm_sequence::finish_item(uvm_sequence_item, <span class="keyword">int</span> set_priority=-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于start_item()，第三个参数需要注意是否将item挂载到“非当前parent sequence挂载的sequencer”上面，即如果将item和其parent sequence挂载到不同的sequencer上面，就需要指定这个参数。</span></span><br></pre></td></tr></table></figure>
<p>对于一个item的完整传送，sequence要在sequencer一侧获得通过权限，才可以顺利将item发送至driver。拆解这些步骤如下：</p>
<ul>
<li><p>创建item。</p>
</li>
<li><p>通过start_item()方法等待获得sequencer的授权许可，其后执行parent sequence的方法pre_do()。</p>
</li>
<li><p>对item进行随机化处理。</p>
</li>
<li><p>通过finish_item()方法在对item进行了随机化处理之后，执行parent sequence的mid_do()，以及调用uvm_sequencer::send_request()和</p>
<p>uvm_sequencer::wait_for_item_done()来将item发送至sequencer再完成与driver之间的握手。最后执行了parent_sequence的post_do()。</p>
</li>
</ul>
<p>这些完整的细节有两个部分需要注意：</p>
<ul>
<li>第一，<code>sequence</code>和<code>item</code>自身的优先级，可以决定什么时刻可以获取<code>sequencer</code>的授权。</li>
<li>第二，<code>parent sequence</code>的虚方法<code>pre_do()</code>、<code>mid_do()</code>、<code>post_do()</code>会发生在发送<code>item</code>的过程中间。</li>
</ul>
<p>对比start()方法和start_item()/finish_item()，首先要分清它们面向的挂载对象是不同的。在执行start()过程中，默认情况下会执行sequence的pre_body()和post_body()，但是如果start()的参数call_pre_post=0，那么就不会这样执行。</p>
<p><code>start()</code>方法的源代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub_seq<span class="variable">.pre_start</span>()				(<span class="keyword">task</span>)</span><br><span class="line">sub_seq<span class="variable">.pre_body</span>()				(<span class="keyword">task</span>)		<span class="keyword">if</span> call_pre_post=<span class="number">1</span></span><br><span class="line">	parent_seq<span class="variable">.pre_do</span>(<span class="number">0</span>)		(<span class="keyword">task</span>)		<span class="keyword">if</span> parent_sequence!=<span class="literal">null</span></span><br><span class="line">	parent_seq<span class="variable">.mid_do</span>(<span class="keyword">this</span>)		(func)		<span class="keyword">if</span> parent_sequence!=<span class="literal">null</span></span><br><span class="line">sub_seq<span class="variable">.body</span>()					(<span class="keyword">task</span>)		<span class="comment">//your stimulus code</span></span><br><span class="line">	parent_seq<span class="variable">.post_do</span>(<span class="keyword">this</span>)()	(func)		<span class="keyword">if</span> parent_sequence!=<span class="literal">null</span></span><br><span class="line">sub_seq<span class="variable">.post_body</span>()				(<span class="keyword">task</span>)		<span class="keyword">if</span> call_pre_post=<span class="number">1</span></span><br><span class="line">sub_seq<span class="variable">.post_start</span>()			(<span class="keyword">task</span>)</span><br></pre></td></tr></table></figure>
<p><code>start_item()/finish_item()</code>源代码如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021030215312947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>需要注意：</strong></p>
<ul>
<li><p>sequence也可以挂在到sequencer上，必须传入的是sequencer的句柄，这样在调用start_item()时，才能执行sequencer的wait_for_grant方法，send_request方法</p>
<p>等待仲裁的方法在只有一个类型的item传入的时候是立刻返回的，只有当多个sequence挂载的时候，才会需要仲裁；优先级高的先拿到sequencer句柄</p>
</li>
<li><p>通过sequencer的都是item，sequence只是挂载</p>
</li>
</ul>
<h2 id="12-2-发送序列的相关宏"><a href="#12-2-发送序列的相关宏" class="headerlink" title="12.2 发送序列的相关宏"></a>12.2 发送序列的相关宏</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210728194621.png" alt="在这里插入图片描述"></p>
<ul>
<li>只有sequence可以调用这些宏，test类中还是要循规蹈矩的用new创建sequence对象进行挂载</li>
<li>通过这些sequence/item宏，可以使用’uvm_do、’uvm_do_with来发送无论是sequence还是item。这种不区分对象是sequence还是item方式带来了不少便捷。不同的宏，可能会包含创建对象的过程，也可能不会创建对象。例如’uvm_do、’uvm_do_with会创建对象，而’uvm_send则不会创建对象，也不会将对象做随机处理，因此要了解它们各自包含的执行内容和顺序。</li>
</ul>
<p>示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> child_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		bus_trans req;</span><br><span class="line">		<span class="meta">`uvm_create(req)</span></span><br><span class="line">		<span class="meta">`uvm_rand_send_with(req, &#123;data == 10;&#125;)</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> top_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		child_seq cseq;</span><br><span class="line">		bus_trans req;</span><br><span class="line">		<span class="comment">//send child sequence via start()</span></span><br><span class="line">		<span class="meta">`uvm_do(cseq)</span></span><br><span class="line">		<span class="comment">//send sequence item</span></span><br><span class="line">		<span class="meta">`uvm_do_with(req, &#123;data == 20;&#125;)</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>child_seq：create（）+rand_send_with（） == uvm_do_with（）；</p>
<p>top_seq：可以看到代码被明显简化了：</p>
<p>底层squence（cseq）的实例化创建和装载只需要一句</p>
<p>item的创建和装载，随机化也就只需要一句</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cseq = child_seq::type_id::create(<span class="string">"cseq"</span>);</span><br><span class="line">tmp = create_item(bus_trans<span class="variable">.get_type</span>(), m_sequencer, <span class="string">"req"</span>);</span><br><span class="line"><span class="comment">//send child sequence via start()</span></span><br><span class="line">cseq<span class="variable">.start</span>(m_sequencer, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//send sequence item</span></span><br><span class="line"><span class="keyword">void</span>'(<span class="built_in">$cast</span>(req, tmp));</span><br><span class="line">start_item(req);</span><br><span class="line">req<span class="variable">.randomize</span> <span class="keyword">with</span> &#123;data == <span class="number">20</span>;&#125;;</span><br><span class="line">finish_item(req);</span><br></pre></td></tr></table></figure>
<p>无论sequence处于什么层次，都应该让sequence在test结束前执行完毕，还应该保留出一部分时间供DUT将所有发送的激励处理完毕，进入空闲状态才可以结束测试。</p>
<p>尽量避免使用fork_join_any或者fork_join_none来控制sequence的发送顺序。</p>
<p>因此如果想终止在后台运行的sequence线程而简单使用disable方式，就可能在不恰当的时间点上锁住sequencer。一旦sequencer被锁住而又无法释放，接下来也就无法</p>
<p>发送其它sequence，尽量在发送完item完成握手之后再终止sequence。</p>
<p>如果要使用fork_join方式，应该确保有方法可以让sequence线程在满足一些条件后停止发送item，否则只要有一个sequence线程无法停止，则整个fork_join无法退出。</p>
<h2 id="12-3-Sequencer的仲裁"><a href="#12-3-Sequencer的仲裁" class="headerlink" title="12.3 Sequencer的仲裁"></a>12.3 Sequencer的仲裁</h2><p><img src="https://img-blog.csdnimg.cn/20210302160513364.png" alt="在这里插入图片描述"></p>
<p>uvm_sequencer类自建了仲裁机制用来保证多个sequence在同时挂载到sequencer时，可以按照仲裁规则允许特定sequence中的item优先通过。在实际使用中，可以通过uvm_sequencer::set_arbitration(UVM_SEQ_ARB_TYPE val)函数来设置仲裁模式，这里的仲裁模式UVM_SEQ_ARB_TYPE 有下面几种值可以选择：</p>
<ul>
<li>UVM_SEQ_ARB_FIFO：默认模式。来自于sequences的发送请求，按照FIFO先进先出的方式被依次授权，和优先级没有关系。</li>
<li>UVM_SEQ_ARB_WEIGHTED：不同sequence的发送请求，将按照它们的优先级权重随机授权。</li>
<li>UVM_SEQ_ARB_RANDOM：不同的请求会被随机授权，而无视它们抵达顺序和优先级。</li>
<li>UVM_SEQ_ARB_STRICT_FIFO：不同的请求，会按照它们的优先级以及抵达顺序来依次授权，与优先级和抵达时间都有关系。</li>
<li>UVM_SEQ_ARB_STRICT_RANDOM：不同的请求，会按照它们的最高优先级随机授权，与抵达时间无关。</li>
<li>UVM_SEQ_ARB_USER：可以自定义仲裁方法user_priority_arbitration()来裁定哪个sequence的请求被优先授权。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> top_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		child_seq seq1, seq2, seq3;</span><br><span class="line">		m_sequencer<span class="variable">.set_arbitration</span>(UVM_SEQ_ARB_STRICT_FIFO);</span><br><span class="line">		<span class="keyword">fork</span></span><br><span class="line">			<span class="meta">`uvm_do_pri_with(seq1, 500, &#123;base == 10;&#125;)</span></span><br><span class="line">			<span class="meta">`uvm_do_pri_with(seq2, 500, &#123;base == 20;&#125;)</span></span><br><span class="line">			<span class="meta">`uvm_do_pri_with(seq3, 300, &#123;base == 30;&#125;)</span></span><br><span class="line">		<span class="keyword">join</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> sequencer <span class="keyword">extends</span> uvm_sequencer;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> bus_trans <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> data;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> child_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> base;</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		bus_trans req;</span><br><span class="line">		<span class="keyword">repeat</span>(<span class="number">2</span>) <span class="meta">`uvm_do_with(req, &#123;data inside &#123;[base:base+9]&#125;;&#125;)</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> driver <span class="keyword">extends</span> uvm_driver;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		REQ tmp;</span><br><span class="line">		bus_trans req;</span><br><span class="line">		<span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">			seq_item_port<span class="variable">.get_next_item</span>(tmp);</span><br><span class="line">			<span class="keyword">void</span>'(<span class="built_in">$cast</span>(req, tmp));</span><br><span class="line">			<span class="meta">`uvm_info("DRV", $sformatf("got a item %0d from parent sequence %s", req.data, req.get_parent_sequence().get_name()), UVM_LOW)</span></span><br><span class="line">			seq_item_port<span class="variable">.item_done</span>();</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> env <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	sequencer sqr;</span><br><span class="line">	driver drv;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		sqr = sequencer::type_id::create(<span class="string">"sqr"</span>, <span class="keyword">this</span>);</span><br><span class="line">		drv = driver::type_id::create(<span class="string">"drv"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		drv<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sqr<span class="variable">.seq_item_export</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line">	env e;</span><br><span class="line">	<span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		e = env::type_id::create(<span class="string">"e"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		top_seq seq;</span><br><span class="line">		phase<span class="variable">.raise_objection</span>(phase);</span><br><span class="line">		seq = <span class="keyword">new</span>();</span><br><span class="line">		seq<span class="variable">.start</span>(e<span class="variable">.sqr</span>);</span><br><span class="line">		phase<span class="variable">.drop_objection</span>(phase);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210302163325244.png" alt="在这里插入图片描述"></p>
<p>seq1、seq2、seq3在同一时刻发起传送请求，通过<code>&#39;uvm_do_prio_with</code>的宏，在发送sequence时可以传递优先级参数。由于将seq1与seq2设置为同样的高优先级，而seq3设置为较低的优先级，这样在随后的UVM_SEQ_ARB_STRICT_FIFO仲裁模式下，可以从输出结果看到，按照优先级高低和传送请求时间顺序，先将seq1和seq2中的item发送完毕，随后将seq3发送完。除了sequence遵循仲裁机制，在一些特殊情况下，有一些sequence需要有更高权限取得sequencer的授权来访问driver。例如在需要响应中断的情况下，用于处理中断的sequence应该有更高的权限来获得sequencer的授权。</p>
<h2 id="12-4-Sequencer的锁定机制"><a href="#12-4-Sequencer的锁定机制" class="headerlink" title="12.4 Sequencer的锁定机制"></a>12.4 Sequencer的锁定机制</h2><p>uvm_sequencer提供了两种锁定机制，分别通过lock()和grab()方法实现，这两种的方法区别在于：</p>
<ul>
<li>lock()与unlock()这一对方法可以为sequence提供排外的访问权限，但前提条件是，该sequence首先需要按照sequencer的仲裁机制获得授权。而一旦sequence获得授权，则无需担心权限被收回，只有该sequence主动解锁它的sequencer，才可以释放这一锁定的权限，lock()是一种阻塞任务，只有获得了权限才会返回。</li>
<li>grab()与ungrab()也可以为sequence提供排外的访问权限，而且它只需要在sequencer下一次授权周期时就可以无条件地获得权限。与lock方法相比，grab方法无视同一时刻内发起传送请求的其它sequence，而唯一可以阻止它的只有已经预先获得授权的其它lock或者grab的sequence。</li>
<li>如果sequence使用了lock()或者grab()方法，必须在sequence结束前调用unlock()或者ungrab()方法来释放权限，否则sequencer会进入死锁状态而无法继续为其余sequence授权。</li>
</ul>
<p>示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> bus_trans <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> child_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> lock_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		bus_trans req;</span><br><span class="line">		#<span class="number">10</span>ns;</span><br><span class="line">		m_sequencer<span class="variable">.lock</span>(<span class="keyword">this</span>);</span><br><span class="line">		<span class="meta">`uvm_info("LOCK", "get exclusive access by lock()", UVM_LOW)</span></span><br><span class="line">		<span class="keyword">repeat</span>(<span class="number">3</span>) #<span class="number">10</span>ns <span class="meta">`uvm_do_with(req, &#123;data inside &#123;[100:110]&#125;;&#125;)</span></span><br><span class="line">		m_sequencer<span class="variable">.unlock</span>(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> grab_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		bus_trans req;</span><br><span class="line">		#<span class="number">20</span>ns;</span><br><span class="line">		m_sequencer<span class="variable">.grab</span>(<span class="keyword">this</span>);</span><br><span class="line">		<span class="meta">`uvm_info("LOCK", "get exclusive access by grab()", UVM_LOW)</span></span><br><span class="line">		<span class="keyword">repeat</span>(<span class="number">3</span>) #<span class="number">10</span>ns <span class="meta">`uvm_do_with(req, &#123;data inside &#123;[200:210]&#125;;&#125;)</span></span><br><span class="line">		m_sequencer<span class="variable">.ungrab</span>(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> top_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		child_seq seq1, seq2, seq3;</span><br><span class="line">		lock_seq locks;</span><br><span class="line">		grab_seq grabs;</span><br><span class="line">		m_sequencer<span class="variable">.set_arbitration</span>(UVM_SEQ_ARB_STRICT_FIFO);</span><br><span class="line">		<span class="keyword">fork</span></span><br><span class="line">			<span class="meta">`uvm_do_pri_with(seq1, 500, &#123;base == 10;&#125;)</span></span><br><span class="line">			<span class="meta">`uvm_do_pri_with(seq2, 500, &#123;base == 20;&#125;)</span></span><br><span class="line">			<span class="meta">`uvm_do_pri_with(seq3, 300, &#123;base == 30;&#125;)</span></span><br><span class="line">			<span class="meta">`uvm_do_pri(locks, 300)</span></span><br><span class="line">			<span class="meta">`uvm_do(grabs)</span></span><br><span class="line">		<span class="keyword">join</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20210302202419345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>对于sequence locks，在10ns时它跟其它几个sequence一同向sequencer发起请求，按照仲裁模式，sequencer先后授权给seq1、seq2、seq3，最后才授权给locks。而locks在获得授权之后，就可以一直享有权限而无需担心权限被sequencer收回，locks结束前，需要通过unlock()方法返还权限。</p>
<p> 对于sequence grabs，尽管在20ns时就发起了请求权限（实际上seq1、seq2、seq3也在同一时刻发起了权限请求），而由于权限已经被locks占用，所以它也无权收回权限。因此只有当locks在40ns结束时，grabs才可以在sequencer没有被锁定的状态下获得权限，而grabs在此条件下获取权限是无视同一时刻发起请求的其它sequence的。同样的在grabs结束前，也应当通过ungrab()方法释放权限，防止sequencer的死锁行为。</p>
<h1 id="13-Sequence的层次化"><a href="#13-Sequence的层次化" class="headerlink" title="13. Sequence的层次化"></a>13. Sequence的层次化</h1><p>概述</p>
<p>就水平复用而言，在MCDF各个子模块的验证环境中，它指的是如何利用已有资源，完成高效的激励场景创建。而就垂直复用来看，它指的是在MCDF子系统验证中，可以完成结构复用和激励场景复用两个方面。无论是水平复用还是垂直复用，激励场景的复用很大程度上取决于如何设计sequence，使得底层的sequence实现合理的粒度，帮助完成水平复用，进一步依托于底层激励场景，最终可以实现底层到高层的垂直复用。</p>
<h2 id="13-1-Hierarchical-Sequence介绍"><a href="#13-1-Hierarchical-Sequence介绍" class="headerlink" title="13.1 Hierarchical Sequence介绍"></a>13.1 Hierarchical Sequence介绍</h2><p><img src="https://img-blog.csdnimg.cn/20210304194622343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 80%;" /></p>
<p>在验证MCDF的寄存器模块时，将SV验证环境进化到了UVM环境之后，关于测试寄存器模块的场景可以将其拆分为：</p>
<ul>
<li>设置时钟和复位</li>
<li>测试通道1的控制寄存器和只读寄存器</li>
<li>测试通道2的控制寄存器和只读寄存器</li>
<li>测试通道3的控制寄存器和只读寄存器</li>
</ul>
<p>上面的测试场景拆解下的<code>sequence</code>需要挂载的都是<code>reg_master_agent</code>中的<code>sequencer</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;CLKON, CLKOFF, RESET, WRREG, RDREG&#125; cmd_t;</span><br><span class="line"><span class="keyword">class</span> bus_trans <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">	<span class="keyword">rand</span> cmd_t cmd;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> addr;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">constraint</span> cstr&#123;</span><br><span class="line">		<span class="keyword">soft</span> addr == <span class="number">'h0</span>;</span><br><span class="line">		<span class="keyword">soft</span> data == <span class="number">'h0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> clk_rst_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> freq;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		bus_trans req;</span><br><span class="line">		<span class="meta">`uvm_do_with(req, &#123;cmd == CLKON; data == freq;&#125;)</span></span><br><span class="line">		<span class="meta">`uvm_do_with(req, &#123;cmd == RESET;&#125;)</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> reg_test_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">int</span> chnl;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		bus_trans req;</span><br><span class="line">		<span class="comment">//write and read test for WR register</span></span><br><span class="line">		<span class="meta">`uvm_do_with(req, &#123;cmd == WRREG; addr == chnl * 'h4;&#125;)</span></span><br><span class="line">		<span class="meta">`uvm_do_with(req, &#123;cmd == RDREG; addr == chnl * 'h4;&#125;)</span></span><br><span class="line">		<span class="comment">//read for the RD register</span></span><br><span class="line">		<span class="meta">`uvm_do_with(req, &#123;cmd == RDREG; addr == chnl * 'h4 + 'h10;&#125;)</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> top_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		clk_rst_seq clkseq;</span><br><span class="line">		reg_test_seq regseq0, regseq1, regseq2;</span><br><span class="line">		<span class="comment">//turn on clock with 150Mhz and assert reset</span></span><br><span class="line">		<span class="meta">`uvm_do_with(clkseq, &#123;freq == 150;&#125;)</span></span><br><span class="line">		<span class="comment">//test the register of channel0</span></span><br><span class="line">		<span class="meta">`uvm_do_with(regseq0, &#123;chnl == 0;&#125;)</span></span><br><span class="line">		<span class="comment">//test the register of channel1</span></span><br><span class="line">		<span class="meta">`uvm_do_with(regseq1, &#123;chnl == 1;&#125;)</span></span><br><span class="line">		<span class="comment">//test the register of channel2</span></span><br><span class="line">		<span class="meta">`uvm_do_with(regseq2, &#123;chnl == 2;&#125;)		</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> reg_master_sequencer <span class="keyword">extends</span> uvm_sequencer;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> reg_master_driver <span class="keyword">extends</span> uvm_driver;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		REQ tmp;</span><br><span class="line">		bus_trans req;</span><br><span class="line">		<span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">			seq_item_port<span class="variable">.get_next_item</span>(tmp);</span><br><span class="line">			<span class="keyword">void</span>'(<span class="built_in">$cast</span>(req, tmp));</span><br><span class="line">			<span class="meta">`uvm_info("DRV", $sformatf("got a item \n %s", req.sprint()), UVM_LOW)</span></span><br><span class="line">			seq_item_port<span class="variable">.item_done</span>();</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> reg_master_agent <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">	reg_master_sequencer sqr;</span><br><span class="line">	reg_master_driver drv;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		sqr = reg_master_sequencer::type_id::create(<span class="string">"sqr"</span>, <span class="keyword">this</span>);</span><br><span class="line">		drv = reg_master_driver::type_id::create(<span class="string">"drv"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		drv<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sqr<span class="variable">.seq_item_export</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>item类bus_trans包含了几个简单的域cmd、addr、data。在clk_rst_seq和reg_test_seq这两个底层的sequence在例化和传送item时，就通过随机化bus_trans中的域来实现不同的命令和数据内容。通过不同的数据内容的item，最终可以实现不同的测试目的。</p>
<p>在top_seq中，它就通过对clk_rst_seq和reg_test_seq这两个element sequence进行组合和随机化赋值，最终实现了一个完整的测试场景，即先打开时钟和完成复位，其后对寄存器模块中的寄存器完成读写测试。</p>
<p>所以如果将clk_rst_seq和reg_test_seq作为底层sequence，或者称之为element sequence，top_seq作为一个更高层的协调sequence，它本身也会容纳，并对它们进行协调和随机限制，通过将这些element sequence进行有机的调度，最终完成一个期望的测试场景。那么这样的top_seq就可以成为Hierarchical Sequence，它内部 可以包含多个sequence和item，而通过层层嵌套，最终完成测试序列的合理切分。验证时，有了粒度合适的element sequence，就会更容易在这些设计好的”轮子“上面，实现验证的加速过程。而水平复用，就非常依赖于hierarchical sequence的实现。</p>
<p><img src="https://img-blog.csdnimg.cn/20210304202309412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="13-2-virtual-sequence介绍"><a href="#13-2-virtual-sequence介绍" class="headerlink" title="13.2 virtual sequence介绍"></a>13.2 virtual sequence介绍</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210728213509.png" alt="image-20210728213509317" style="zoom: 67%;" /></p>
<p><strong>virtual sequencer</strong>：类似顶层路由，起到连接底层sequencer的作用，包含各个组件的sequencer句柄，通过左下角的这个virtual sequencer就可以找到各个组件的sequencer 。本身不传输item，不同和driver连接。所以需要在顶层的connect_phase对virtual sequencer和底层sequencer建立连接。</p>
<p>virtual sequence也是协调各个sequence，但hierarchical sequence面对的对象是同一个sequencer，即hierarchical sequence本身也会挂载到sequencer上面，而对于virtual sequence而言，它内部不同的sequence可以允许面向不同的sequencer种类。即承载了不同sequencer目标的sequence群落。</p>
<p>virtual sequence一般挂载到virtual sequencer上！！！</p>
<p>在MCDF子系统验证环境集成过程中，完成了前期的结构垂直复用，就需要考虑如何各个模块的element sequence和hierarchical sequence。对于更上层的环境，顶层的测试序列要协调的不再只是面向一个sequencer的sequence群，而是要面向多个sequencer的sequence群。面向单一的sequencer，可以通过uvm_sequence::start()来挂载root sequence，而在内部的child sequence则可以通过宏’uvm_do来实现。如果将各个模块环境的element sequence和hierarchical sequence都作为可以复用的sequence资源，那么就需要一个可以容纳各个sequence的容器来承载它们，同时也需要一个合适的routing sequencer来组织不同结构中的sequencer，这样的sequence和sequencer分别称之为virtual sequence和virtual sequencer。</p>
<p>virtual sequence可以承载不同目标sequencer的sequence群落，而组织协调这些sequence的方式则类似于高层次的hierarchical sequence。virtual sequence一般只会挂载到virtual sequencer上面。virtual sequencer与普通的sequencer相比有着很大的不同，它们起到了桥接其它sequencer的作用，即virtual sequencer是一个链接所有底层sequencer句柄的地方，它是一个中心化的路由器。同时virtual sequencer本身并不会传送item数据对象，因此virtual sequencer不需要与任何的driver进行TLM连接。所以UVM需要在顶层的connect阶段，做好virtual sequencer中各个sequencer句柄与底层sequencer实体对象的一一对接，避免句柄悬空。</p>
<p><strong>代码：</strong></p>
<p>virtual sequence中底层sequencer的挂载：和Hierarchical Sequence区别很明显</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`uvm_declare_p_sequencer(mcdf_virtual_sequencer)	//p_sequencer是一个uvm_sequencer的子类</span></span><br><span class="line"><span class="meta">`uvm_do_on(fmt_seq, p_sequencer.fmt_sqr)</span></span><br></pre></td></tr></table></figure>
<p>m_sequencer：uvm_sequencer的实例句柄</p>
<p>p_sequencer：自己声明的uvm_sequencer子类mcdf_virtual_sequencer的句柄</p>
<p>问：为啥之前的sequencer也继承的uvm_sequencer，都直接用了m_sequencer，这里就要用宏转成p_sequencer？</p>
<p>virtual_sequencer中定义了底层的sequencer，父类句柄m_sequencer访问不到，这里的宏默认做了一个类型转换，p_sequencer就可以访问到底层sqr</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> mcdf_normal_seq <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">	<span class="meta">`uvm_object_utils(mcdf_normal_seq)</span></span><br><span class="line">	<span class="meta">`uvm_declare_p_sequencer(mcdf_virtual_sequencer)	//p_sequencer是一个uvm_sequencer的子类</span></span><br><span class="line">	<span class="comment">//这一行的宏相当于，定义了mcdf_virtual_sequencer、p_sequencer，然后$(p_sequencer, mcdf_virtual_sequencer)做了转换，完成了父类句柄到子类句柄的转换，然后就可以访问子类所有的成员变量，进而实现路由功能</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> body();</span><br><span class="line">		clk_rst_seq clk_seq;</span><br><span class="line">		reg_cfg_seq cfg_seq;</span><br><span class="line">		data_trans_seq data_seq;</span><br><span class="line">		fmt_slv_cfg_seq fmt_seq;</span><br><span class="line">		<span class="comment">//配置formatter slave agent</span></span><br><span class="line">		<span class="meta">`uvm_do_on(fmt_seq, p_sequencer.fmt_sqr)</span></span><br><span class="line">		<span class="comment">//打开时钟并完成复位</span></span><br><span class="line">		<span class="meta">`uvm_do_on(clk_seq, p_sequencer.cr_sqr)</span></span><br><span class="line">		<span class="comment">//配置MCDF寄存器</span></span><br><span class="line">		<span class="meta">`uvm_do_on(cfg_seq, p_sequencer.reg_sqr)</span></span><br><span class="line">		<span class="comment">//传递channel数据包</span></span><br><span class="line">		<span class="keyword">fork</span></span><br><span class="line">			<span class="meta">`uvm_do_on(data_seq, p_sequencer.chnl_sqr0)</span></span><br><span class="line">			<span class="meta">`uvm_do_on(data_seq, p_sequencer.chnl_sqr1)</span></span><br><span class="line">			<span class="meta">`uvm_do_on(data_seq, p_sequencer.chnl_sqr2)</span></span><br><span class="line">		<span class="keyword">join</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> mcdf_virtual_sequencer <span class="keyword">extends</span> uvm_sequencer;</span><br><span class="line">	cr_master_sequencer cr_sqr;</span><br><span class="line">	reg_master_sequencer reg_sqr;</span><br><span class="line">	chnl_master_sequencer chnl_sqr;</span><br><span class="line">	chnl_master_sequencer chnl_sqr;</span><br><span class="line">	chnl_master_sequencer chnl_sqr;</span><br><span class="line">	fmt_slave_sequencer fmt_sqr;</span><br><span class="line">	<span class="meta">`uvm_component_utils(mcdf_virtual_sequencer)</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> mcdf_env <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	cr_master_agent cr_agt;</span><br><span class="line">	reg_master_agent reg_agt;</span><br><span class="line">	chnl_master_agent chnl_agt0;</span><br><span class="line">	chnl_master_agent chnl_agt1;</span><br><span class="line">	chnl_master_agent chnl_agt2;</span><br><span class="line">	fmt_slave_agent fmt_agt;</span><br><span class="line">	mcdf_virtual_sequencer virt_sqr;</span><br><span class="line">	<span class="meta">`uvm_component_utils(mcdf_env)</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		cr_agt = cr_master_agent::type_id::create(<span class="string">"cr_agt"</span>, <span class="keyword">this</span>);</span><br><span class="line">		reg_agt = reg_master_agent::type_id::create(<span class="string">"reg_agt"</span>, <span class="keyword">this</span>);</span><br><span class="line">		chnl_agt0 = chnl_master_agent::type_id::create(<span class="string">"chnl_agt0"</span>, <span class="keyword">this</span>);</span><br><span class="line">		chnl_agt1 = chnl_master_agent::type_id::create(<span class="string">"chnl_agt1"</span>, <span class="keyword">this</span>);</span><br><span class="line">		chnl_agt2 = chnl_master_agent::type_id::create(<span class="string">"chnl_agt2"</span>, <span class="keyword">this</span>);</span><br><span class="line">		fmt_agt = fmt_slave_agent::type_id::create(<span class="string">"fmt_agt"</span>, <span class="keyword">this</span>);</span><br><span class="line">		virt_sqr = mcdf_virtual_sequencer::type_id::create(<span class="string">"virt_sqr"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		virt_sqr<span class="variable">.cr_sqr</span> = cr_agt<span class="variable">.sqr</span>;</span><br><span class="line">		virt_sqr<span class="variable">.reg_sqr</span> = reg_agt<span class="variable">.sqr</span>;</span><br><span class="line">		virt_sqr<span class="variable">.chnl_sqr</span> = chnl_agt<span class="variable">.sqr</span>;</span><br><span class="line">		virt_sqr<span class="variable">.chnl_sqr</span> = chnl_agt<span class="variable">.sqr</span>;</span><br><span class="line">		virt_sqr<span class="variable">.chnl_sqr</span> = chnl_agt<span class="variable">.sqr</span>;</span><br><span class="line">		virt_sqr<span class="variable">.fmt_sqr</span> = fmt_agt<span class="variable">.sqr</span>;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line">	mcdf_env e;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		mcdf_normal_seq seq;</span><br><span class="line">		phase<span class="variable">.raise_objection</span>(phase);</span><br><span class="line">		seq = <span class="keyword">new</span>();</span><br><span class="line">		seq<span class="variable">.start</span>(e<span class="variable">.virt_sqr</span>);</span><br><span class="line">		phase<span class="variable">.drop_objection</span>(phase);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h1 id="14-寄存器模概览"><a href="#14-寄存器模概览" class="headerlink" title="14. 寄存器模概览"></a>14. 寄存器模概览</h1><h2 id="14-1-寄存器模型概览"><a href="#14-1-寄存器模型概览" class="headerlink" title="14.1 寄存器模型概览"></a>14.1 寄存器模型概览</h2><ul>
<li>寄存器是模块之间互相交谈的窗口，一方面可以通过读出寄存器的状态，获取硬件当前的状况，另外一方面也可以通过配置寄存器，使得寄存器工作在一定的模式下。在验证的过程中，寄存器的验证也排在了验证清单的前列，因为只有首先保证寄存器的功能正确，才会使得硬件与硬件之间的交谈是“语义一致”的。如果寄存器配置结果与寄存器配置内容不同，那么硬件无法工作在想要的模式下，同时寄存器也可能无法正确反映硬件的状态。</li>
<li>硬件中的各个功能模块可以由处理器来配置功能以及访问状态，而与处理器的对话即是通过寄存器的读写来实现的。</li>
<li>寄存器的硬件实现是通过触发器，而每一个比特位的触发器都对应着寄存器的功能描述。一个寄存器一般由32个比特位构成，将单个寄存器拆分之后，又可以分为多个域(field)，不同的域往往代表着某一项独立的功能。单个的域可能有多个比特位构成，也可能由单一比特位构成（如reg的en，prio，length，），这取决于该域的功能模式可配置的数量。而不同的域，对于外部的读写而言，又大致可以分为WO(只写)，RO(只读)和RW(读写)，除了这些常见的操作属性以外，还有一些特殊行为(quirky)的寄存器，例如读后擦除模式(clean-on-read，RC)，只写一次模式(write-one-to-set，W1S)。</li>
</ul>
<p>对于MCDF的寄存器模块描述，将0x00功能寄存器和0x10状态寄存器位用图来表示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210305144035371.png" alt="在这里插入图片描述"></p>
<p>通常来讲，一个寄存器有32位宽，寄存器按照地址索引的关系是按字对齐的，上图中的寄存器有多个域，每个域的属性也可以不相同，reserved域表示的是该域所包含的比特位暂时保留以作日后功能的扩展使用，而对保留域的读写不起任何作用，即无法写入而且读出值也是它的复位值。上面的这些寄存器按照地址排列，即可构成寄存器列表，称之为寄存器块，实际上，<strong>寄存器块除了包含寄存器，也可以包含存储器</strong>，因为它们的属性都近乎读写功能，以及表示为同外界通信的接口。</p>
<p>如果将这些寄存器有机的组合在一起，MCDF的寄存器功能模块即可由这样一个register block来表示：<br><img src="https://img-blog.csdnimg.cn/20210305144754918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Nzk0MDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>一个寄存器可以由多个域构成，而单个域可以包含多个比特位，一个功能模块中的多个寄存器可以组团构成一个寄存器模型。上面的图中除了包含了DUT的寄存器模块(由硬件实现)，还有属于验证环境的寄存器模型。<strong>这两个模块包含的寄存器信息是高度一致的</strong>，属于验证环境的寄存器模型也可以抽象出一个层次化的寄存器列表，该列表所包含的地址、域、属性等信息都与硬件一侧的寄存器内容一致。<strong>对于功能验证而言，可以将总线访问寄存器的方式抽象为寄存器模型访问的方式，这种方式使得寄存器后期的地址修改(例如基地址更改)或者域的添加都不会对已有的激励构成影响</strong>，从而提高已有测试序列的复用性。</p>
<h2 id="14-2-中心化管理方式"><a href="#14-2-中心化管理方式" class="headerlink" title="14.2 中心化管理方式"></a>14.2 中心化管理方式</h2><p><img src="https://img-blog.csdnimg.cn/20210305145852301.png" alt="在这里插入图片描述"></p>
<p>通过软件建立寄存器模型的方法要保证与硬件寄存器的内容属性保持一致，这离不开一份中心化管理的寄存器描述文件。寄存器描述文档使用了结构化的文档描述方式，这也是为什么可以通过XML或者Excel(CSV)等数据结构化的方式来实现寄存器的功能描述。</p>
<p>通过数据结构化的存储方式，可以在硬件和软件开发过程中以不同方式来使用寄存器描述文档：</p>
<ul>
<li>系统工程师会撰写并维护寄存器描述文档，而后归置到中心化存储路径供其他工程师开发使用。</li>
<li>硬件工程师会利用寄存器描述文件生成寄存器硬件模块(包含各个寄存器的硬件实现和总线访问模块)。</li>
<li>验证工程师会利用寄存器描述文件来生成UVM寄存器模型，以供验证过程中的激励使用、寄存器测试和功能覆盖率收集。</li>
<li>软件工程师会利用该文件生成用于软件开发的寄存器配置的头文件，从而提高软件开发的可维护性。</li>
</ul>
<h2 id="14-3-寄存器模型构建"><a href="#14-3-寄存器模型构建" class="headerlink" title="14.3 寄存器模型构建"></a>14.3 寄存器模型构建</h2><h3 id="1-常用类"><a href="#1-常用类" class="headerlink" title="1. 常用类"></a>1. 常用类</h3><p>在构建UVM寄存器模型的过程中，需要用到如下与模型构建相关的类和它们的功能：</p>
<p><img src="https://img-blog.csdnimg.cn/2021030515125374.png" alt="img"></p>
<ul>
<li><p>uvm_reg_field：类似mcdf的refmod中对于域的枚举，每一个枚举内容都对于1个寄存器的对应bit位</p>
</li>
<li><p>uvm_reg：类似这里的struct，包含多个枚举变量的信息</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">bit</span>[<span class="number">2</span>:<span class="number">0</span>] len;</span><br><span class="line">    <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] prio;</span><br><span class="line">    <span class="keyword">bit</span> en;</span><br><span class="line">    <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] avail;</span><br><span class="line">  &#125; mcdf_reg_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RW_LEN, RW_PRIO, RW_EN, RD_AVAIL&#125; mcdf_field_t;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h3><p>ctrl_reg：读写寄存器</p>
<ul>
<li>object类型，且ref_field声明了rand</li>
<li>声明的uvm_reg_field不需要注册！！！</li>
<li>build（）方法：uvm_reg预定义，类似build_phase，对各个field进行创建，和配置</li>
</ul>
<p>stat_reg：只读寄存器</p>
<p>mcdf_rgm（uvm_reg_block）：包含所有的reg和reg_map</p>
<ul>
<li><p>uvm_reg_map：在map中传入基地址，再添加寄存器reg和相应的偏移地址</p>
</li>
<li><p>为什么上层的uvm_rgm的build方法中，要调用下层的reg的build方法，而不是像component在build_phase中创建时就会自动加载下层的build_phase方法？</p>
<p>因为component有顶层uvm_root的支持，允许自动调用</p>
</li>
<li><p>为什么uvm_reg_block中的reg句柄也声明了rand？</p>
<p>最终还是为了对reg中的rand变量进行随机化</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ctrl_reg <span class="keyword">extends</span> uvm_reg;</span><br><span class="line">	<span class="meta">`uvm_object_utils(ctrl_reg)</span></span><br><span class="line">	uvm_reg_field reserved;</span><br><span class="line">	<span class="keyword">rand</span> uvm_reg_field pkt_len;</span><br><span class="line">	<span class="keyword">rand</span> uvm_reg_field prio_level;</span><br><span class="line">	<span class="keyword">rand</span> uvm_reg_field chnl_en;</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="string">"ctrl_reg"</span>);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.new</span>(name, <span class="number">32</span>, UVM_NO_COVERAGE);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">function</span> build();</span><br><span class="line">		reserved = uvm_reg_field::type_id::create(<span class="string">"reserved"</span>);</span><br><span class="line">		pkt_len = uvm_reg_field::type_id::create(<span class="string">"pkt_len"</span>);</span><br><span class="line">		prio_level = uvm_reg_field::type_id::create(<span class="string">"prio_level"</span>);</span><br><span class="line">		chnl_en = uvm_reg_field::type_id::create(<span class="string">"chnl_en"</span>);</span><br><span class="line">		reserved<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">26</span>, <span class="number">6</span>, <span class="string">"RO"</span>, <span class="number">0</span>, <span class="number">26'h0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		pkt_len<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">"RW"</span>, <span class="number">0</span>, <span class="number">3'h0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		prio_level<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">"RW"</span>, <span class="number">0</span>, <span class="number">2'h3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		chnl_en<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">"RW"</span>, <span class="number">0</span>, <span class="number">1'h0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> stat_reg <span class="keyword">extends</span> uvm_reg;</span><br><span class="line">	<span class="meta">`uvm_object_utils(stat_reg)</span></span><br><span class="line">	uvm_reg_field reserved;</span><br><span class="line">	<span class="keyword">rand</span> uvm_reg_field fifo_avail;</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="string">"stat_reg"</span>);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.new</span>(name, <span class="number">32</span>, UVM_NO_COVERAGE);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">function</span> build();</span><br><span class="line">		reserved = uvm_reg_field::type_id::create(<span class="string">"reserved"</span>);</span><br><span class="line">		fifo_avail = uvm_reg_field::type_id::create(<span class="string">"fifo_avail"</span>);</span><br><span class="line">		reserved<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="string">"RO"</span>, <span class="number">0</span>, <span class="number">24'h0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		fifo_avail<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="string">"RO"</span>, <span class="number">0</span>, <span class="number">8'h0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> mcdf_rgm <span class="keyword">extends</span> uvm_reg_block;</span><br><span class="line">	<span class="meta">`uvm_object_utils(mcdf_rgm)</span></span><br><span class="line">	<span class="keyword">rand</span> ctrl_reg chnl0_ctrl_reg;</span><br><span class="line">	<span class="keyword">rand</span> ctrl_reg chnl1_ctrl_reg;</span><br><span class="line">	<span class="keyword">rand</span> ctrl_reg chnl2_ctrl_reg;</span><br><span class="line">	<span class="keyword">rand</span> ctrl_reg chnl0_stat_reg;</span><br><span class="line">	<span class="keyword">rand</span> ctrl_reg chnl1_stat_reg;</span><br><span class="line">	<span class="keyword">rand</span> ctrl_reg chnl2_stat_reg;</span><br><span class="line">	uvm_reg_map map;</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="string">"mcdf_rgm"</span>);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.new</span>(name, UVM_NO_COVERAGE);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">function</span> build();</span><br><span class="line">		chnl0_ctrl_reg = ctrl_reg::type_id::create(<span class="string">"chnl0_ctrl_reg"</span>);</span><br><span class="line">		chnl0_ctrl_reg<span class="variable">.configure</span>(<span class="keyword">this</span>);</span><br><span class="line">		chnl0_ctrl_reg<span class="variable">.build</span>();</span><br><span class="line">		chnl1_ctrl_reg = ctrl_reg::type_id::create(<span class="string">"chnl1_ctrl_reg"</span>);</span><br><span class="line">		chnl1_ctrl_reg<span class="variable">.configure</span>(<span class="keyword">this</span>);</span><br><span class="line">		chnl1_ctrl_reg<span class="variable">.build</span>();</span><br><span class="line">		chnl2_ctrl_reg = ctrl_reg::type_id::create(<span class="string">"chnl2_ctrl_reg"</span>);</span><br><span class="line">		chnl2_ctrl_reg<span class="variable">.configure</span>(<span class="keyword">this</span>);</span><br><span class="line">		chnl2_ctrl_reg<span class="variable">.build</span>();</span><br><span class="line">		chnl0_stat_reg = ctrl_reg::type_id::create(<span class="string">"chnl0_stat_reg"</span>);</span><br><span class="line">		chnl0_stat_reg<span class="variable">.configure</span>(<span class="keyword">this</span>);</span><br><span class="line">		chnl0_stat_reg<span class="variable">.build</span>();</span><br><span class="line">		chnl1_stat_reg = ctrl_reg::type_id::create(<span class="string">"chnl1_stat_reg"</span>);</span><br><span class="line">		chnl1_stat_reg<span class="variable">.configure</span>(<span class="keyword">this</span>);</span><br><span class="line">		chnl1_stat_reg<span class="variable">.build</span>();</span><br><span class="line">		chnl2_stat_reg = ctrl_reg::type_id::create(<span class="string">"chnl2_stat_reg"</span>);</span><br><span class="line">		chnl2_stat_reg<span class="variable">.configure</span>(<span class="keyword">this</span>);</span><br><span class="line">		chnl2_stat_reg<span class="variable">.build</span>();</span><br><span class="line">		<span class="comment">//map name, offset, number of bytes, endianess</span></span><br><span class="line">		map = create_map(<span class="string">"map"</span>, <span class="number">'h0</span>, <span class="number">4</span>, UVM_LITTLE_ENDIAN);</span><br><span class="line">		map<span class="variable">.add_reg</span>(chnl0_ctrl_reg, <span class="number">32'h00000000</span>, <span class="string">"RW"</span>);</span><br><span class="line">		map<span class="variable">.add_reg</span>(chnl1_ctrl_reg, <span class="number">32'h00000004</span>, <span class="string">"RW"</span>);</span><br><span class="line">		map<span class="variable">.add_reg</span>(chnl2_ctrl_reg, <span class="number">32'h00000008</span>, <span class="string">"RW"</span>);</span><br><span class="line">		map<span class="variable">.add_reg</span>(chnl0_stat_reg, <span class="number">32'h00000010</span>, <span class="string">"RO"</span>);</span><br><span class="line">		map<span class="variable">.add_reg</span>(chnl1_stat_reg, <span class="number">32'h00000014</span>, <span class="string">"RO"</span>);</span><br><span class="line">		map<span class="variable">.add_reg</span>(chnl2_stat_reg, <span class="number">32'h00000018</span>, <span class="string">"RO"</span>);</span><br><span class="line">		lock_model();</span><br><span class="line">	<span class="keyword">endfunction</span>	</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>关于寄存器建模的基本要点和顺序：</p>
<ul>
<li><p>在定义单个寄存器时，需要将寄存器的各个域整理出来，在创建之后还应当通过uvm_reg_field::configure()函数来进一步配置各自属性（<strong>包括reserve域</strong>）。</p>
</li>
<li><p>在定义uvm_reg_block时，需要注意reg_block与uvm_mem、uvm_reg以及uvm_reg_map的包含关系。首先uvm_reg和uvm_mem分别对应着硬件中独立的寄存器或者存储，而<strong>一个uvm_reg_block可以用来模拟一个功能模块的寄存器模型，其中可以容纳多个uvm_reg和uvm_mem实例</strong>，其次<strong>map的作用</strong>一方面用来表示寄存器和存储对应的<strong>偏移地址</strong>，同时由于一个reg_block可以包含多个map，各个map可以分别对应不同总线或者不同地址段。在reg_block中创建了各个uvm_reg之后，需要调用uvm_reg::configure()去配置各个uvm_reg实例的属性。</p>
</li>
<li><p>因为uvm_reg_map也会在uvm_reg_block中例化，在例化之后需要通过uvm_reg_map::add_reg()函数来添加各个uvm_reg对应的偏移地址和访问属性等。只有规定了这些属性，才可以在稍后的前门访问(frontdoor)中给出正确的地址。</p>
</li>
<li><p>uvm_reg_block可以对更大的系统做寄存器建模，<strong>这意味着uvm_reg_block之间也可以存在层次关系</strong>，上层uvm_reg_block的uvm_reg_map可以添加子一级</p>
<p>uvm_reg_block的uvm_reg_map，用来构建更全局的“版图”，继而通过uvm_reg_block与uvm_reg_map之间的层次关系来构建更系统的寄存器模型。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210729164055.png" alt="image-20210729164055372"></p>
</li>
</ul>
<h1 id="15-寄存器模型集成"><a href="#15-寄存器模型集成" class="headerlink" title="15. 寄存器模型集成"></a>15. 寄存器模型集成</h1><p><strong>从上节给的寄存器模型流程图中我们可以看到，接下来需要考虑选择与DUT寄存器接口一致的总线UVC，该UVC会提供硬件级别的访问方式。</strong></p>
<p><strong>要完成一次硬件级别的总线传输，往往需要考虑给出地址、数据队列、访问方式等，而寄存器模型可以使得硬件级别的抽象级可以上升到寄存器级别。</strong></p>
<p>将抽象级上升到寄存器级别的好处：</p>
<ul>
<li>以往写的由具体地址来指定的寄存器，将由寄存器名称来替代，同时寄存器模型<a href="http://bbs.eetop.cn/forum-185-1.html" target="_blank" rel="noopener">封装</a>的一些函数使得可以对域做直接操作，这一升级使得转变后的测试序列更易读。</li>
<li>伴随着项目变化，无论寄存器基地址如何变化，以寄存器级别实现的配置序列都要比以硬件级别的序列可维护性更好。</li>
</ul>
<p>我的理解：</p>
<p>硬件级别就是对interface的直接操作；寄存器模型的使用让这一行为变的间接，测试序列更易读，可维护性更好！</p>
<h2 id="15-1-总线UVC的实现"><a href="#15-1-总线UVC的实现" class="headerlink" title="15.1 总线UVC的实现"></a>15.1 总线UVC的实现</h2><p>就是现有的实验中的通过interface对reg的操作</p>
<ul>
<li>MCDF访问寄存器的总线接口时序较为简单。控制寄存器接口首先需要在每一个时钟解析<code>cmd</code>。</li>
<li>当<code>cmd</code>为<strong>写指令</strong>时，即需要把数据<code>cmd_data_in</code>写入到<code>cmd_addr</code>对应的寄存器中。</li>
<li>当<code>cmd</code>为<strong>读指令</strong>时，即需要从<code>cmd_addr</code>对应的寄存器中读出数据，在下一个周期，<code>cmd_addr</code>对应的寄存器数据被输送至<code>cmd_data_out</code>接口。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> mcdf_bus_trans <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] cmd;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>] wdata;</span><br><span class="line">	<span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>] rdata;</span><br><span class="line">	<span class="meta">`uvm_object_utils_begin(mcdf_bus_trans)</span></span><br><span class="line">		...</span><br><span class="line">	<span class="meta">`uvm_object_utils_end</span></span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> mcdf_bus_sequencer <span class="keyword">extends</span> uvm_sequencer;</span><br><span class="line">	<span class="keyword">virtual</span> mcdf_if vif;</span><br><span class="line">	<span class="meta">`uvm_component_utils(mcdf_bus_sequencer)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">if</span>(!uvm_config_db<span class="variable">#(virtual mcdf_if)::get(this, "", "vif", vif))</span> <span class="keyword">begin</span></span><br><span class="line">			<span class="meta">`uvm_error("GETVIF", "no virtual interface is assigned")</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> mcdf_bus_monitor <span class="keyword">extends</span> uvm_monitor;</span><br><span class="line">	<span class="keyword">virtual</span> mcdf_if vif;</span><br><span class="line">	uvm_analysis_port<span class="variable">#(mcdf_bus_trans)</span> ap;</span><br><span class="line">	<span class="meta">`uvm_component_utils(mcdf_bus_monitor)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">if</span>(!uvm_config_db<span class="variable">#(virtual mcdf_if)::get(this, "", "vif", vif))</span> <span class="keyword">begin</span></span><br><span class="line">			<span class="meta">`uvm_error("GETVIF", "no virtual interface is assigned")</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		ap = <span class="keyword">new</span>(<span class="string">"ap"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">			mon_trans();</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> mon_trans();</span><br><span class="line">		mcdf_bus_trans t;</span><br><span class="line">		@(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">		<span class="keyword">if</span>(vif<span class="variable">.cmd</span> == <span class="meta">`WRITE) begin</span></span><br><span class="line">			t = <span class="keyword">new</span>();</span><br><span class="line">			t<span class="variable">.cmd</span> = <span class="meta">`WRITE;</span></span><br><span class="line">			t<span class="variable">.addr</span> = vif<span class="variable">.addr</span>;</span><br><span class="line">			t<span class="variable">.wdata</span> = vif<span class="variable">.wdata</span>;</span><br><span class="line">			ap<span class="variable">.write</span>(t);</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(vif<span class="variable">.cmd</span> == <span class="meta">`READ) begin</span></span><br><span class="line">			t = <span class="keyword">new</span>();</span><br><span class="line">			t<span class="variable">.cmd</span> = <span class="meta">`READ;</span></span><br><span class="line">			t<span class="variable">.addr</span> = vif<span class="variable">.addr</span>;</span><br><span class="line">			<span class="keyword">fork</span></span><br><span class="line">				<span class="keyword">begin</span></span><br><span class="line">					@(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">					#<span class="number">10</span>ns;</span><br><span class="line">					t<span class="variable">.rdata</span> = vif<span class="variable">.rdata</span>;</span><br><span class="line">					ap<span class="variable">.write</span>(t);</span><br><span class="line">				<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">join_none</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> mcdf_bus_driver <span class="keyword">extends</span> uvm_driver;</span><br><span class="line">	<span class="keyword">virtual</span> mcdf_if vif;</span><br><span class="line">	<span class="meta">`uvm_component_utils(mcdf_bus_driver)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		<span class="keyword">if</span>(!uvm_config_db<span class="variable">#(virtual mcdf_if)::get(this, "", "vif", vif))</span> <span class="keyword">begin</span></span><br><span class="line">			<span class="meta">`uvm_error("GETVIF", "no virtual interface is assigned")</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		REQ tmp;</span><br><span class="line">		mcdf_bus_trans req, rsp;</span><br><span class="line">		reset_listener();</span><br><span class="line">		<span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">			seq_item_port<span class="variable">.get_next_item</span>(tmp);</span><br><span class="line">			<span class="keyword">void</span>'(<span class="built_in">$cast</span>(req, tmp));</span><br><span class="line">			<span class="meta">`uvm_info("DRV", $sformatf("got a item \n %s", req.sprint()), UVM_LOW)</span></span><br><span class="line">			<span class="keyword">void</span>'(<span class="built_in">$cast</span>(rsp, req<span class="variable">.clone</span>()));</span><br><span class="line">			rsp<span class="variable">.set_sequence_id</span>(req<span class="variable">.get_sequence_id</span>());</span><br><span class="line">			rsp<span class="variable">.set_transaction_id</span>(req<span class="variable">.get_transaction_id</span>());</span><br><span class="line">			driver_bus(rsp);</span><br><span class="line">			seq_item_port<span class="variable">.item_done</span>(rsp);</span><br><span class="line">			<span class="meta">`uvm_info("DRV", $sformatf("sent a item \n %s", req.sprint()), UVM_LOW)</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> reset_listener();</span><br><span class="line">		<span class="keyword">fork</span></span><br><span class="line">			<span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">				@(<span class="keyword">negedge</span> vif<span class="variable">.rstn</span>) driver_idle();</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">join_none</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> drive_bus(mcdf_bus_trans t);</span><br><span class="line">		<span class="keyword">case</span>(t<span class="variable">.cmd</span>)</span><br><span class="line">			<span class="meta">`WRITE: drive_write(t);</span></span><br><span class="line">			<span class="meta">`READ:  drive_read(t);</span></span><br><span class="line">			<span class="meta">`IDLE:  drive_idle(t);</span></span><br><span class="line">			<span class="keyword">default</span>: <span class="meta">`uvm_error("DRIVE", "invalid mcdf command type received!")</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> drive_write(mcdf_bus_trans t);</span><br><span class="line">		@(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">		vif<span class="variable">.cmd</span> &lt;= t<span class="variable">.cmd</span>;</span><br><span class="line">		vif<span class="variable">.addr</span> &lt;= t<span class="variable">.addr</span>;</span><br><span class="line">		vif<span class="variable">.wdata</span> &lt;= t<span class="variable">.wdata</span>;</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> drive_read(mcdf_bus_trans t);</span><br><span class="line">		@(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">		vif<span class="variable">.cmd</span> &lt;= t<span class="variable">.cmd</span>;</span><br><span class="line">		vif<span class="variable">.addr</span> &lt;= t<span class="variable">.addr</span>;</span><br><span class="line">		@(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">		#<span class="number">10</span>ns;</span><br><span class="line">		t<span class="variable">.rdata</span> = vif<span class="variable">.rdata</span>;</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> drive_idle(<span class="keyword">bit</span> is_sync=<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(is_sync) @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">		@(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">		vif<span class="variable">.cmd</span> &lt;= <span class="number">'h0</span>;</span><br><span class="line">		vif<span class="variable">.addr</span> &lt;= <span class="number">'h0</span>;</span><br><span class="line">		vif<span class="variable">.wdata</span> &lt;= <span class="number">'h0</span>;</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> mcdf_bus_agent <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">	mcdf_bus_driver driver;</span><br><span class="line">	mcdf_bus_sequencer sequencer;</span><br><span class="line">	mcdf_bus_monitor monitor;</span><br><span class="line">	<span class="meta">`uvm_component_utils(mcdf_bus_agent)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		driver = mcdf_bus_driver::type_id::create(<span class="string">"driver"</span>, <span class="keyword">this</span>);</span><br><span class="line">		sequencer = mcdf_bus_sequencer::type_id::create(<span class="string">"sequencer"</span>, <span class="keyword">this</span>);</span><br><span class="line">		monitor = mcdf_bus_monitor::type_id::create(<span class="string">"monitor"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		driver<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sequencer<span class="variable">.seq_item_export</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>示例中囊括了<code>mcdf_bus_agent</code>的所有组件，包括<code>sequence item</code>、<code>sequencer</code>、<code>driver</code>、<code>monitor</code>和<code>agent</code>：</p>
<ul>
<li><code>mcdf_bus_trans</code>包括了可随机化的数据成员<code>cmd</code>、<code>addr</code>、<code>wdata</code>和不可随机化的<code>rdata</code>。<code>rdata</code>之所以没有声明为<code>rand</code>类型，是因为它应从总线读出或者观察，不应随机化。</li>
<li><code>mcdf_bus_monitor</code>会观测总线，其后通过<code>analysis port</code>写出到目标<code>analysis</code>组件。</li>
<li><code>mcdf_bus_driver</code>主要实现了总线驱动和复位功能，通过模块化的方法<code>reset_listener()</code>、<code>driver_bus()</code>、<code>drive_write()</code>、<code>drive_read()</code>、<code>drive_idle()</code>可以解析三种命令模式<code>IDLE</code>、<code>WRITE</code>、<code>READ</code>，并且在<code>READ</code>模式下，将读回的数据通过<code>item_done(rsp)</code>写回到<code>sequencer</code>和<code>sequence</code>一侧。‘</li>
</ul>
<p>本质上就是对于接口的驱动（driver，将数据放到接口）和检测（monitor，从接口采集数据）过程</p>
<h2 id="15-2-adapter"><a href="#15-2-adapter" class="headerlink" title="15.2 adapter"></a>15.2 adapter</h2><p><img src="https://gitee.com/biongd/img/raw/master/img/20210729193421.png" alt="image-20210729193420950" style="zoom: 67%;" /></p>
<p>实现从rgm的reg中获取到的uvm_reg_item转化为个之前通过外部sequence挂载到SQR上的bus_seq_item</p>
<p><strong>这里的predictor是干嘛的？</strong></p>
<p>BUS agent对dut的操作，此时硬件的寄存器的信息应该被软件模型预测到，只有这样refmod才能进行打包操作</p>
<p>mcdf中的refmod，里面的模拟寄存器通过do_update_reg（）方法，通过reg_monitor检测到的数据对3个reg进行更新；</p>
<p>predictor的功能类似，同样是获取到monitor检测到的bus_transaction，和图中的bus_seq_item是一致的。一旦获取到adapter句柄，就可以转为uvm_reg_bus_on</p>
<p>对软件模型中的寄存器信息进行修改</p>
<p><strong>除此之外还有一种预测方式</strong></p>
<p>不使用predictor，只需要BUS_agent左半边的通路，也就是在输出bus_seq_item时就默认会对dut的寄存器进行配置，依此作为预测！！</p>
<p>但是这种方法有缺陷，比如状态寄存器的值就无法预测</p>
<p>对应的方法见15.2中adapter的集成的实例代码中：<code>rgm.map.set_auto_predict();</code></p>
<h3 id="Adapter的实现"><a href="#Adapter的实现" class="headerlink" title="Adapter的实现"></a>Adapter的实现</h3><p>在具备了MCDF总线UVC之后，需要实现<code>adapter</code>。每一个总线对应的<code>adapter</code>所完成的桥接功能即是在<code>uvm_reg_bus_op</code>和总线<code>transaction</code>之间的转换，在开发某一个总线<code>adapter</code>类型时，需要实现下面几点：</p>
<ul>
<li><code>uvm_reg_bus_op</code>与总线<code>transaction</code>中各自的数据映射。</li>
<li>实现<code>reg2bus()</code>和<code>bus2reg()</code>两个函数(预定义，必须实现)，这两个函数实现了两种<code>transaction</code>的数据映射。</li>
<li>如果总线支持<code>byte</code>访问，可以使能<code>supports_byte_enable</code>；如果总线UVC要返回<code>response</code>数据，则应当使能<code>provides_response</code>。<code>mcdf_bus_driver</code>在读数时会将读回的数据填入到<code>RSP</code>并返回至<code>sequencer</code>，因此需要在<code>adapter</code>中使能<code>provides_responses</code>。由此使得<code>bus2reg()</code>函数调用时得到的数据是总线返回时的<code>transaction</code>，如果总线UVC不支持返回<code>RSP</code>(没有调用<code>put_response(RSP)</code>或者<code>item_done(RSP)</code>)，那么不应该置此位，否则<code>adapter</code>将会使得验证环境挂起。</li>
</ul>
<p>代码实例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> reg2mcdf_adapter <span class="keyword">extends</span> uvm_reg_adapter;</span><br><span class="line">	<span class="meta">`uvm_object_utils(reg2mcdf_adapter)</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name=<span class="string">"mcdf_bus_trans"</span>);</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">		provides_response = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> uvm_sequence_item reg2bus(<span class="keyword">const</span> <span class="keyword">ref</span> uvm_reg_bus_op rw);</span><br><span class="line">		mcdf_bus_trans t = mcdf_bus_trans::type_id::create(<span class="string">"t"</span>);</span><br><span class="line">		t<span class="variable">.cmd</span> = (rw<span class="variable">.kind</span> == UVM_WRITE) ? <span class="meta">`WRITE : `READ;</span></span><br><span class="line">		t<span class="variable">.addr</span> = rw<span class="variable">.addr</span>;</span><br><span class="line">		t<span class="variable">.wdata</span> = rw<span class="variable">.data</span>;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> bus2reg(uvm_sequence_item bus_item, <span class="keyword">ref</span> uvm_reg_bus_op rw);</span><br><span class="line">		mcdf_bus_trans t;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">$cast</span>(t, bus_item)) <span class="keyword">begin</span></span><br><span class="line">			<span class="meta">`uvm_fatal("NOT_MCDF_BUS_TYPE", "Provided bus_item is not of the correct type")</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		rw<span class="variable">.kind</span> = (t<span class="variable">.cmd</span> == <span class="meta">`WRITE) ? UVM_WRITE : UVM_READ;</span></span><br><span class="line">		rw<span class="variable">.kind</span> = t<span class="variable">.addr</span>;</span><br><span class="line">		rw<span class="variable">.data</span> = (t<span class="variable">.cmd</span> == <span class="meta">`WRITE) ? t.wdata : t.rdata;</span></span><br><span class="line">		rw<span class="variable">.status</span> = UVM_IS_OK;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><code>uvm_reg_bus_op</code>类的成员变量：</p>
<p><img src="https://img-blog.csdnimg.cn/20210305203720293.png" alt="img"></p>
<p>该类在构建函数中使能了<code>provides_response</code>，这是因为<code>mcdf_bus_driver</code>在发起总线访问之后会将<code>RSP</code>一并返回至<code>sequencer</code>。<code>reg2bus()</code>完成的桥接场景是，如果在寄存器级别做了操作，那么寄存器级别操作的信息<code>uvm_reg_bus_op</code>会被记录，同时调用<code>uvm_reg_adapter::reg2bus()</code>函数。在完成了将<code>uvm_reg_bus_op</code>的信息映射到<code>mcdf_bus_trans</code>之后，函数将<code>mcdf_bus_trans</code>实例返回。而在返回<code>mcdf_bus_trans</code>之后，该实例将通过<code>mcdf_bus_sequencer</code>传入到<code>mcdf_bus_driver</code>。这里的<code>transaction</code>传输是后台隐式调用的。</p>
<p>寄存器无论读写，都应当知道总线操作后的状态返回，对于读操作时，也需要知道总线返回的读数据，因此<code>uvm_reg_adapter::bus2reg()</code>即是从<code>mcdf_bus_driver()</code>将数据写回至<code>mcdf_bus_sequence</code>，而一直保持监听的<code>reg2mcdf_adapter</code>一旦从<code>sequencer</code>获取了<code>RSP(mcdf_bus_trans)</code>之后，就将自动调用<code>bus2reg()</code>函数。<code>bus2reg()</code>函数的功能与<code>reg2bus()</code>相反，完成了从<code>mcdf_bus_trans</code>到<code>uvm_reg_bus_op</code>的内容映射。在完成映射之后，更新的<code>uvm_reg_bus_op</code>数据最终返回至寄存器操作场景层。对于寄存器操作，无论读操作还是写操作，都需要经历调用<code>reg2bus()</code>，继而发起总线事务，而在完成事务发回反馈之后，又需要调用<code>bus2reg()</code>，将总线的数据返回至寄存器操作层面。</p>
<h2 id="15-2-Adapter的集成"><a href="#15-2-Adapter的集成" class="headerlink" title="15.2 Adapter的集成"></a>15.2 Adapter的集成</h2><p>在具备了寄存器模型<code>mcdf_rgm</code>、总线UVC <code>mcdf_bus_agent</code>和桥接<code>reg2mcdf_adapter</code>之后，就需要考虑如何将<code>adapter</code>集成到验证环境中去：</p>
<ul>
<li>对于<code>mcdf_rgm</code>的集成，倾向于顶层传递的方式，即最终从test层传入寄存器模型句柄。这种方式有利于验证环境<code>mcdf_bus_env</code>的闭合性，在后期不同<code>test</code>如果要对<code>rgm</code>做不同的配置，都可以在顶层例化，而后通过<code>uvm_config_db</code>来传递。</li>
<li>寄存器模型在创建之后，还需要显式调用<code>build()</code>函数。而<code>uvm_reg_block</code>是<code>uvm_object</code>类型，因此其预定义的<code>build()</code>函数并不会自动执行，还需要单独调用。</li>
<li>在顶层环境的<code>connect</code>阶段中，还需要将寄存器模型的<code>map</code>组件与<code>bus sequencer</code>和<code>adapter</code>连接。这样才能将<code>map</code>(寄存器信息)、<code>sequencer</code>（总线侧激励驱动）和<code>adapter</code>(寄存器级别和硬件总线级别的桥接)关联在一起。也只有通过这一步，<code>adapter</code>的桥接功能才可以工作。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> mcdf_bus_env <span class="keyword">extends</span> uvm_env;</span><br><span class="line">	mcdf_bus_agent;</span><br><span class="line">	mcdf_rgm rgm;</span><br><span class="line">	reg2mcdf_adapter reg2mcdf;</span><br><span class="line">	<span class="meta">`uvm_component_utils(mcdf_bus_env)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		agent = mcdf_bus_agent::type_id::create(<span class="string">"agent"</span>, <span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span>(!uvm_config_db<span class="variable">#(mcdf_rgm)::get(this, "", "rgm", rgm))</span> <span class="keyword">begin</span></span><br><span class="line">			<span class="meta">`uvm_info("GETRGM", "no top-down RGM handle is assigned", UVM_LOW)</span></span><br><span class="line">			rgm = mcdf_rgm::type_id::create(<span class="string">"rgm"</span>, <span class="keyword">this</span>);</span><br><span class="line">			<span class="meta">`uvm_info("NEWRGM", "created rgm instance locally", UVM_LOW)</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="comment">/*rgm.build()会创建各个uvm_reg，进而对uvm_reg作config，</span></span><br><span class="line"><span class="comment">		还会调用各个uvm_reg中的build()，去例化每个uvm_reg中的field，去配置各个field*/</span></span><br><span class="line">		rgm<span class="variable">.build</span>();</span><br><span class="line">		rgm<span class="variable">.map</span><span class="variable">.set_auto_predict</span>();</span><br><span class="line">		reg2mcdf = reg2mcdf::type_id::create(<span class="string">"reg2mcdf"</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">		rgm<span class="variable">.map</span><span class="variable">.set_sequencer</span>(agent<span class="variable">.sequencer</span>, reg2mcdf);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> test1 <span class="keyword">extends</span> uvm_test;</span><br><span class="line">	mcdf_rgm rgm;</span><br><span class="line">	mcdf_bus_env env;</span><br><span class="line">	<span class="meta">`uvm_component_utils(test1)</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">		rgm = mcdf_rgm::type_id::create(<span class="string">"rgm"</span>, <span class="keyword">this</span>);</span><br><span class="line">		uvm_config_db<span class="variable">#(mcdf_rgm)::set(this, "env*", "rgm", rgm)</span>;</span><br><span class="line">		env = mcdf_bus_env::type_id::create(<span class="string">"env"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h2 id="15-3-访问方式"><a href="#15-3-访问方式" class="headerlink" title="15.3 访问方式"></a>15.3 访问方式</h2><p>利用寄存器模型，可以更方便地对寄存器做操作，分为两种访问寄存器的方式，即前门访问和后门访问。</p>
<ul>
<li>前门访问，指的是在寄存器模型上做的读写操作，最终会通过总线UVC来实现总线上的物理时序访问，因此是真实的物理操作。</li>
<li>后门访问，指的是利用UVM DPI（uvm_hdl_read()、uvm_hdl_deposit()），将寄存器的操作直接作用到DUT内的寄存器变量，而不通过物理总线访问。</li>
</ul>
<h3 id="前门访问"><a href="#前门访问" class="headerlink" title="前门访问"></a>前门访问</h3><p>前门访问的示例中的<code>sequence</code>继承于<code>uvm_reg_sequence</code>。<code>uvm_reg_sequence</code>除了具备一般<code>uvm_sequence</code>的预定义方法外，还具有跟寄存器操作相关的方法。</p>
<ul>
<li>第一种即<code>uvm_reg::read()/write()</code>。传递时需要注意将参数<code>path</code>指定为<code>UVM_FRONTDOOR</code>。<code>uvm_reg::read()/write()</code>方法可传入的参数较多，除了<code>status</code>和<code>value</code>两个参数需要传入，其它参数如果不指定，可采用默认值。</li>
<li>第二种即<code>uvm_reg_sequence::read_reg()/write_reg()</code>。在使用时，也需要将<code>path</code>指定为<code>UVM_FRONTDOOR</code>。</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210729205101.png" alt="image-20210729205100956" style="zoom:67%;" /> </p>
<h3 id="后门访问"><a href="#后门访问" class="headerlink" title="后门访问"></a>后门访问</h3><ul>
<li>进行后门访问时，用户首先确保寄存器模型在建立时，是否将各个寄存器映射到了DUT一侧的HDL路径。</li>
</ul>
<p>例码中通过uvm_reg_block::add_hdl_path()，将寄存器模型关联到了DUT一端，而通过uvm_reg::add_hdl_path_slice完成了将寄存器模型各个寄存器成员与HDL一侧的地址映射。例如在稍后对寄存器SLV0_RW_REG进行后门访问时，UVM  DPI函数会通过寄存器HDL路径“reg_backdoor_access.dut.regs[0]”映射到正确的寄存器位置，继而对其进行读值或者修改。另外，寄存器模型build()函数最后一句，以lock_model()结尾，该函数的功能是结束地址映射关系，并且保证模型不会被其它用户修改。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210729210221.png" alt="image-20210729210221441" style="zoom:80%;" /></p>
<p>在寄存器模型完成了HDL路径映射后，我们才可以利用uvm_reg或者uvm_reg_sequence自带的方法进行后门访问，下面仍然给出一段后门访问的例码。类似于前门访问，后门访问也有几类方法提供：</p>
<ul>
<li>uvm_reg::read()/write()，在调用该方法时需要注明UVM_BACKDOOR的访问方式。</li>
<li>uvm_reg_sequence::read_reg()/write_reg()，在使用时也需要注明UVM_BACKDOOR的访问方式。</li>
<li>另外，uvm_reg::peek()/poke()两个方法，也分别对应了读取寄存器（peek）和修改寄存器（poke）两种操作，而用户无需指定访问方式尾UVM_BACKDOOR，因为这两个方法本来就只针对于后门访问。</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20210729210130.png" alt="image-20210729210130260" style="zoom:80%;" /></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E5%AD%97IC/" rel="tag"># 数字IC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/10/06/IC%E9%AA%8C%E8%AF%81-%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B/" rel="next" title="实验过程">
                <i class="fa fa-chevron-left"></i> 实验过程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/06/IC%E9%AA%8C%E8%AF%81-verilog/" rel="prev" title="verilog基础">
                verilog基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="xujunjie'blog" />
            
              <p class="site-author-name" itemprop="name">xujunjie'blog</p>
              <p class="site-description motion-element" itemprop="description">使一个人有限的生命更加有效也即等于延长了人的生命</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-UVM概念"><span class="nav-text">1. UVM概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UVM类库地图"><span class="nav-text">UVM类库地图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UVM组件"><span class="nav-text">UVM组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UVM环境-phase机制"><span class="nav-text">UVM环境-phase机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂机制"><span class="nav-text">工厂机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#覆盖方法"><span class="nav-text">覆盖方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-核心基类UVM-object"><span class="nav-text">2. 核心基类UVM-object</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#域的自动化-（Field-Automation）"><span class="nav-text">域的自动化 （Field Automation）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心方法"><span class="nav-text">核心方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局对象"><span class="nav-text">全局对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#比较"><span class="nav-text">比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打印"><span class="nav-text">打印</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打包和解包"><span class="nav-text">打包和解包</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-phase机制"><span class="nav-text">3. phase机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#建立仿真环境"><span class="nav-text">建立仿真环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uvm仿真结束"><span class="nav-text">uvm仿真结束</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-config机制"><span class="nav-text">4.config机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#interface传递"><span class="nav-text">interface传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#object传递"><span class="nav-text">object传递</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-消息（message）管理"><span class="nav-text">5. 消息（message）管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-消息方法"><span class="nav-text">5.1 消息方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-消息处理"><span class="nav-text">5.2 消息处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#uvm-report-handler和uvm-report-server"><span class="nav-text">uvm_report_handler和uvm_report_server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回调函数"><span class="nav-text">回调函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-消息的创建"><span class="nav-text">5.3 消息的创建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-UVM结构回顾"><span class="nav-text">6. UVM结构回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-uvm-top"><span class="nav-text">6.1 uvm_top</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-uvm-test"><span class="nav-text">6.2 uvm_test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-构建环境的主要组件"><span class="nav-text">6.3 构建环境的主要组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-uvm-component"><span class="nav-text">6.4 uvm_component</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-MCDF顶层验证方案"><span class="nav-text">7. MCDF顶层验证方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-reg-env"><span class="nav-text">7.1 reg_env</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-chnl-env"><span class="nav-text">7.2 chnl_env</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-arb-env"><span class="nav-text">7.3 arb_env</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-fmt-env"><span class="nav-text">7.4 fmt_env</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-环境集成方案一"><span class="nav-text">7.5 环境集成方案一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-环境集成方案二"><span class="nav-text">7.6 环境集成方案二</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-总结"><span class="nav-text">7.7 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-方案1和方案2的区别"><span class="nav-text">1. 方案1和方案2的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-UVM的环境复用相较于SV的优势"><span class="nav-text">2. UVM的环境复用相较于SV的优势</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-环境构建的四要素"><span class="nav-text">8. 环境构建的四要素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-自闭性"><span class="nav-text">8.1 自闭性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-回归创建"><span class="nav-text">8.2 回归创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-通信端口连接"><span class="nav-text">8.3 通信端口连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-顶层配置"><span class="nav-text">8.4 顶层配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-环境元素分类"><span class="nav-text">8.5 环境元素分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成员变量"><span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子组件（固定，条件，引用）"><span class="nav-text">子组件（固定，条件，引用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子对象"><span class="nav-text">子对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-TML通信"><span class="nav-text">9. TML通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-通信概论"><span class="nav-text">9.1 通信概论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#端口使用"><span class="nav-text">端口使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-单向通信"><span class="nav-text">9.2 单向通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-双向通信"><span class="nav-text">9.3 双向通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#transport"><span class="nav-text">transport</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-多向通信"><span class="nav-text">9.4 多向通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-通信管道-插盘"><span class="nav-text">9.5 通信管道-插盘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UVM-TLM-FIFO"><span class="nav-text">UVM_TLM_FIFO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Analysis-Port"><span class="nav-text">Analysis Port</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLM-Analysis-FIFO（继承与tlm-fifo）"><span class="nav-text">TLM Analysis FIFO（继承与tlm_fifo）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request-amp-Response通信管道"><span class="nav-text">Request &amp; Response通信管道</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-Sequence-和-Item"><span class="nav-text">10. Sequence 和 Item</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-Item"><span class="nav-text">10.1 Item</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-Sequence"><span class="nav-text">10.2 Sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扁平类"><span class="nav-text">扁平类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#层次类"><span class="nav-text">层次类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-Sequencer和driver"><span class="nav-text">11. Sequencer和driver</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-端口和方法"><span class="nav-text">11.1 端口和方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-item传输实例"><span class="nav-text">11.2 item传输实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-通信时序"><span class="nav-text">11.3 通信时序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-Sequence-和-Sequencer"><span class="nav-text">12. Sequence 和 Sequencer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-发送sequence-item方法解析"><span class="nav-text">12.1 发送sequence&#x2F;item方法解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-发送序列的相关宏"><span class="nav-text">12.2 发送序列的相关宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-Sequencer的仲裁"><span class="nav-text">12.3 Sequencer的仲裁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-Sequencer的锁定机制"><span class="nav-text">12.4 Sequencer的锁定机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-Sequence的层次化"><span class="nav-text">13. Sequence的层次化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-Hierarchical-Sequence介绍"><span class="nav-text">13.1 Hierarchical Sequence介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-virtual-sequence介绍"><span class="nav-text">13.2 virtual sequence介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-寄存器模概览"><span class="nav-text">14. 寄存器模概览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-寄存器模型概览"><span class="nav-text">14.1 寄存器模型概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-中心化管理方式"><span class="nav-text">14.2 中心化管理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-寄存器模型构建"><span class="nav-text">14.3 寄存器模型构建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-常用类"><span class="nav-text">1. 常用类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例代码"><span class="nav-text">示例代码:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点："><span class="nav-text">注意点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-寄存器模型集成"><span class="nav-text">15. 寄存器模型集成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1-总线UVC的实现"><span class="nav-text">15.1 总线UVC的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-adapter"><span class="nav-text">15.2 adapter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Adapter的实现"><span class="nav-text">Adapter的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-Adapter的集成"><span class="nav-text">15.2 Adapter的集成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-3-访问方式"><span class="nav-text">15.3 访问方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前门访问"><span class="nav-text">前门访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后门访问"><span class="nav-text">后门访问</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xujunjie'blog</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>


  
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
