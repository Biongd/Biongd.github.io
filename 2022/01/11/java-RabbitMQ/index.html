<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java," />










<meta name="description" content="MQ全称为Message Queue，即消息队列。“消息队列”是在消息的传输过程中保存消息的容器。它是典型的：生产者、消费者模型。这里来学习一种常用的消息队列RabbitMQ">
<meta property="og:type" content="article">
<meta property="og:title" content="java-RabbitMQ详解">
<meta property="og:url" content="http://yoursite.com/2022/01/11/java-RabbitMQ/index.html">
<meta property="og:site_name" content="悦来客栈">
<meta property="og:description" content="MQ全称为Message Queue，即消息队列。“消息队列”是在消息的传输过程中保存消息的容器。它是典型的：生产者、消费者模型。这里来学习一种常用的消息队列RabbitMQ">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221637.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221630.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221623.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221615.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221608.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221602.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221555.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221550.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221541.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221533.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221527.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221518.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221512.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221505.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221500.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111161047.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221451.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221444.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221436.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221430.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221422.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221415.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221404.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221401.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221353.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221350.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221341.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111165142.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111165136.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111165129.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221327.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221321.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221313.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111220824.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221252.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221928.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111222310.png">
<meta property="og:image" content="https://gitee.com/biongd/img/raw/master/img/20220111222336.png">
<meta property="article:published_time" content="2022-01-11T02:27:02.000Z">
<meta property="article:modified_time" content="2022-01-11T14:32:23.138Z">
<meta property="article:author" content="xujunjie&#39;blog">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/biongd/img/raw/master/img/20220111221637.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","display_updated":true,"offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2022/01/11/java-RabbitMQ/"/>





  <title>java-RabbitMQ详解 | 悦来客栈</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">悦来客栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">learn and better</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/11/java-RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xujunjie'blog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="悦来客栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java-RabbitMQ详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
              
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-11T10:27:02+08:00">
                2022-01-11
              </time>
            
            
                <span class="post-updated">
                     &nbsp; | &nbsp; 更新于
                     <time itemprop="dateUpdated" datetime="2022-01-11T22:32:23+08:00" content="2022-01-11">
                          2022-01-11
                     </time>
                 </span>
             

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%AD%A6%E4%B9%A0-JVM-spring-Maven-IDEA-web-%E9%9B%86%E5%90%88-%E6%95%B0%E7%BB%84-String%E4%B8%93%E9%A2%98-%E5%89%8D%E7%AB%AF-web%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80-redis-%E6%A6%82%E5%BF%B5/" itemprop="url" rel="index">
                    <span itemprop="name">java学习-JVM.spring.Maven.IDEA.web.集合/数组/String专题.前端.web实战.基础.redis.概念.</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>MQ全称为Message Queue，即消息队列。“消息队列”是在消息的传输过程中保存消息的容器。它是典型的：生产者、消费者模型。这里来学习一种常用的消息队列RabbitMQ</p>
<a id="more"></a>
<h1 id="1-认识RabbitMQ"><a href="#1-认识RabbitMQ" class="headerlink" title="1. 认识RabbitMQ"></a>1. 认识RabbitMQ</h1><p>在介绍RabbitMQ之前，我们先来看下面一个电商项目的场景：</p>
<ol>
<li>商品的原始数据保存在数据库中，增删改查都在数据库中完成。</li>
<li>搜索服务数据来源是索引库（Elasticsearch），如果数据库商品发生变化，索引库数据不能及时更新。</li>
<li>商品详情做了页面静态化处理，静态页面数据也不会随着数据库商品更新而变化。</li>
</ol>
<p>如果我们在后台修改了商品的价格，搜索页面和商品详情页显示的依然是旧的价格，这样显然不对。该如何解决？  </p>
<p>我们可能会想到这么做：</p>
<pre><code>方案1：每当后台对商品做增删改操作，同时修改索引库数据及更新静态页面。

方案2：搜索服务和商品页面静态化服务对外提供操作接口，后台在商品增删改后，调用接口。 
</code></pre><p> 这两种方案都有个严重的问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的独立原则。</p>
<p>这时，我们就会采用另外一种解决办法，那就是消息队列！ </p>
<p>​    商品服务对商品增删改以后，无需去操作索引库和静态页面，只需向MQ发送一条消息（比如包含商品id的消息），也不关心消息被谁接收。 搜索服务和静态页面服务监听MQ，接收消息，然后分别去处理索引库和静态页面（根据商品id去更新索引库和商品详情静态页面）。 </p>
<h2 id="1-1-什么是消息队列"><a href="#1-1-什么是消息队列" class="headerlink" title="1.1 什么是消息队列"></a>1.1 什么是消息队列</h2><p>MQ全称为Message Queue，即消息队列。“消息队列”是在消息的传输过程中保存消息的容器。它是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。</p>
<p>1、任务异步处理：</p>
<p>高并发环境下，由于来不及同步处理，请求往往会发生堵塞，比如说，大量的insert，update之类的请求同时到达MySQL，直接导致无数的行锁表锁，甚至最后请求会堆积过多，从而触发too many connections错误。通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。减少了应用程序的响应时间。</p>
<p>2、应用程序解耦合：</p>
<p>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p>
<h2 id="1-2-AMQP和JMS"><a href="#1-2-AMQP和JMS" class="headerlink" title="1.2 AMQP和JMS"></a>1.2 AMQP和JMS</h2><p>MQ是消息通信的模型，并发具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。</p>
<p><strong>两者间的区别和联系：</strong></p>
<p>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</p>
<p>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</p>
<p>JMS规定了两种消息模型；而AMQP的消息模型更加丰富</p>
<h2 id="1-3-常见MQ产品"><a href="#1-3-常见MQ产品" class="headerlink" title="1.3 常见MQ产品"></a>1.3 常见MQ产品</h2><p>ActiveMQ：基于JMS</p>
<p>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</p>
<p>RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会</p>
<p>Kafka：分布式消息系统，高吞吐量</p>
<h2 id="1-4-RabbitMQ的工作原理"><a href="#1-4-RabbitMQ的工作原理" class="headerlink" title="1.4 RabbitMQ的工作原理"></a>1.4 RabbitMQ的工作原理</h2><p>下图是RabbitMQ的基本结构：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221637.png" alt="img"></p>
<p><strong>组成部分说明：</strong></p>
<p>Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue<br>Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。<br>Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的<br>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送<br>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。</p>
<p><strong>生产者发送消息流程：</strong></p>
<p>1、生产者和Broker建立TCP连接。</p>
<p>2、生产者和Broker建立通道。</p>
<p>3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。</p>
<p>4、Exchange将消息转发到指定的Queue（队列）</p>
<p><strong>消费者接收消息流程：</strong></p>
<p>1、消费者和Broker建立TCP连接</p>
<p>2、消费者和Broker建立通道</p>
<p>3、消费者监听指定的Queue（队列）</p>
<p>4、当有消息到达Queue时Broker默认将消息推送给消费者。</p>
<p>5、消费者接收到消息。</p>
<p>6、ack回复</p>
<h1 id="2-RabbitMq-的搭建流程"><a href="#2-RabbitMq-的搭建流程" class="headerlink" title="2. RabbitMq 的搭建流程"></a>2. RabbitMq 的搭建流程</h1><h2 id="2-1-准备工作—安装Erlang"><a href="#2-1-准备工作—安装Erlang" class="headerlink" title="2.1 准备工作—安装Erlang"></a>2.1 准备工作—安装Erlang</h2><p> 配置Erlang环境(c++)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make gcc gcc-c++ kernel-devel m4 ncurses ncurses-devel openssl-devel perl</span><br></pre></td></tr></table></figure>
<p>从Erlang Solution安装（推荐）到官网 <a href="http://erlang.org/download/" target="_blank" rel="noopener">http://erlang.org/download/</a> 下载最新包，这里使用otp_src_21.1.tar.gz </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/erlang</span><br><span class="line"><span class="built_in">cd</span> /data/erlang/</span><br><span class="line">wget http://erlang.org/download/otp_src_21.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>下载速度比较慢.，建议先下载到本地，再上传到服务器</p>
<p>下载完后解压</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxf otp_src_21.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>安装编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> otp_src_21.1 </span><br><span class="line">./configure --prefix=/data/erlang/erlang; make; make install</span><br></pre></td></tr></table></figure>
<p>安装好后</p>
<p>修改/etc/profile文件:  vi /etc/profile</p>
<p>增加环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set erlang environment</span></span><br><span class="line">ERLANG_HOME=/data/erlang/erlang</span><br><span class="line">PATH=ERLANG_HOME/bin:PATH</span><br><span class="line"><span class="built_in">export</span> ERLANG_HOME</span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
<p>刷新配置:  source /etc/profile</p>
<p>测试：执行erl，看是否能打开eshell，用“halt().”退出，注意后面的“.”点号，那是erlang的结束符</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221630.png" alt="img"></p>
<h2 id="2-2-安装-RabbitMq及过程错误解决"><a href="#2-2-安装-RabbitMq及过程错误解决" class="headerlink" title="2.2 安装 RabbitMq及过程错误解决"></a>2.2 安装 RabbitMq及过程错误解决</h2><p>先建立一个工作目录，并下载安装包，</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/rabbitMq</span><br><span class="line"><span class="built_in">cd</span> /data/rabbitMq/</span><br></pre></td></tr></table></figure>
</blockquote>
<p>官网最新安装包下载链接： <a href="http://www.rabbitmq.com/releases/rabbitmq-server/" target="_blank" rel="noopener">http://www.rabbitmq.com/releases/rabbitmq-server/</a> </p>
<p>github 下载链接：<a href="https://github.com/rabbitmq/rabbitmq-server/releases" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-server/releases</a></p>
<p>网速好的可通过如下命令行下载</p>
<blockquote>
<p><code>wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.8/rabbitmq-server-generic-unix-3.7.8.tar.xz</code></p>
</blockquote>
<p>下载完成后，开始解压</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz -d rabbitmq-server-generic-unix-3.7.8.tar.xz</span><br><span class="line">tar -xvf rabbitmq-server-generic-unix-3.7.8.tar</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221623.png" alt="img"></p>
<p>接下来配置 rabbitmq 的环境变量（这个跟上面的erlang配置以及java的环境变量差不多）</p>
<blockquote>
<p><code>vi /etc/profile</code></p>
</blockquote>
<p>设置环境变量，一般新增的，直接放在文档最后面就行，方便查找修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_BIN=/data/rabbitMq/rabbitmq_server-3.7.8/sbin</span><br><span class="line"> PATH=PATH:PATH:RABBITMQ_BIN</span><br><span class="line"> <span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
<p>/etc/profile 效果如下图： </p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221615.png" alt="img"></p>
<p>执行以下命令，使得PATH路径更新，rabbitMQ安装成功。 </p>
<blockquote>
<p><code>source /etc/profile</code></p>
</blockquote>
<p>开启管理界面及配置</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management  <span class="comment">#启动管理界面</span></span><br><span class="line">vim /data/rabbitMq/rabbitmq_server-3.7.8/ebin/rabbit.app</span><br><span class="line"><span class="comment"># 比如修改密码，配置等，例如looppack_users中的《“guest”》，只保留guest</span></span><br><span class="line">rabbitmq-server -detached   <span class="comment">#后台运行rabbitmq</span></span><br></pre></td></tr></table></figure>
<p>rabbitmq 基本操作命令，更多命令可参考 <a href="https://blog.csdn.net/noonebirdyou/article/details/54645755" target="_blank" rel="noopener">RabbitMQ基础操作命令</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server on                  <span class="comment"># 添加开机启动RabbitMQ服务</span></span><br><span class="line">rabbitmq-server start               <span class="comment"># 启动服务</span></span><br><span class="line">rabbitmq-server status            <span class="comment"># 查看服务状态</span></span><br><span class="line">rabbitmq-server stop               <span class="comment"># 停止服务</span></span><br></pre></td></tr></table></figure>
<p>访问链接： <a href="http://127.0.0.1:15672/" target="_blank" rel="noopener">http://127.0.0.1:15672/</a>  说明启动成功。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221608.png" alt="img"></p>
<p>此时，如果通过外部访问，需要考虑防火墙设置。</p>
<p>本篇是Centos 7.X 所以要设置 firewalld ， 如果是Centos 6.X 要设置 iptables</p>
<p>两种操作，第一种：开放端口供外界访问（推荐，因接近实际搭建涉及的问题）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --zone=public --add-port=4369/tcp --permanent    #erlang发现端口4369</span></span><br><span class="line"><span class="comment"># firewall-cmd --zone=public --add-port=5672/tcp --permanent    #默认client端通信端口5672</span></span><br><span class="line"><span class="comment"># firewall-cmd --zone=public --add-port=15672/tcp --permanent    #默认server管理端口15672</span></span><br><span class="line"><span class="comment"># firewall-cmd --zone=public --add-port=25672/tcp --permanent    #默认server间内部通信口25672</span></span><br></pre></td></tr></table></figure>
<p>端口配置好后，重启防火墙，使其生效</p>
<blockquote>
<p>systemctl restart firewalld</p>
</blockquote>
<p>方法二：直接关闭防火墙。</p>
<blockquote>
<p>systemctl stop firewalld</p>
<p>更多防火墙问题 <a href="https://blog.csdn.net/u014799292/article/details/51264462" target="_blank" rel="noopener">linux-Centos-7-64位：3、 firewalld 配置</a></p>
<p>由于guest用户被限制，只能通过localhost访问，因此我们需要新建一个用户，并授予管理员权限。 </p>
<p>新建一个用户名为admin,密码为admin的用户，并授予管理员（administrator）权限。</p>
<p>方法一：命令行创建</p>
<blockquote>
<pre><code class="lang-bash">rabbitmqctl add_user admin admin123
rabbitmqctl set_user_tags admin administrator
</code></pre>
<p>方法二：登录控制台创建 <a href="http://127.0.0.1:15672/" target="_blank" rel="noopener">http://127.0.0.1:15672/</a> </p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221602.png" alt="img"></p>
<p>搭建完成。</p>
<p>记得，此时创建的 admin用户只有登录管理界面权限，没有操作权限：“No access”，如需开启权限有两种方式：</p>
<p>1，界面操作</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221555.png" alt="img"></p>
<p>设置权限</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221550.png" alt="img"></p>
<p>保存即可。</p>
<p>2、命令行形式</p>
<p>通过命令授权</p>
<p>语法： set_permissions [-p <vhostpath>] <user> <conf> <write> <read></p>
<p>执行： rabbitmqctl set permissions -p / admin .<em> .</em> .* 完成对admin的授权,然后启动项目就正常了</p>
<p>正常权限界面如下：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221541.png" alt="img"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="3-基本模式"><a href="#3-基本模式" class="headerlink" title="3. 基本模式"></a>3. 基本模式</h1><p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221533.png" alt="img"></p>
<p>在上图的模型中，有以下概念：</p>
<pre><code>P：生产者，也就是要发送消息的程序

C：消费者：消息的接受者，会一直等待消息到来。

queue：消息队列，图中红色部分。可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。 
</code></pre><h2 id="3-1-生产者"><a href="#3-1-生产者" class="headerlink" title="3.1 生产者"></a>3.1 生产者</h2><p>新建一个maven工程，添加amqp-client依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>连接工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立与RabbitMQ的连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">"192.168.1.103"</span>);</span><br><span class="line">        <span class="comment">//端口</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置账号信息，用户名、密码、vhost</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">"/kavito"</span>);<span class="comment">//设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</span></span><br><span class="line">        factory.setUsername(<span class="string">"kavito"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">// 通过工厂获取连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 3、声明（创建）队列</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 4、消息内容</span></span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        <span class="comment">// 向指定的队列中发送消息</span></span><br><span class="line">        <span class="comment">//参数：String exchange, String routingKey, BasicProperties props, byte[] body</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细：</span></span><br><span class="line"><span class="comment">         * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为""）</span></span><br><span class="line"><span class="comment">         * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</span></span><br><span class="line"><span class="comment">         * 3、props，消息的属性</span></span><br><span class="line"><span class="comment">         * 4、body，消息内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭通道和连接(资源关闭最好用try-catch-finally语句处理)</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221527.png" alt="img"></p>
<p>web管理页面：服务器地址/端口号 （本地：<a href="http://127.0.0.1:15672" target="_blank" rel="noopener">127.0.0.1:15672</a>，默认用户及密码：guest guest）</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221518.png" alt="img"></p>
<p>点击队列名称，进入详情页，可以查看消息：</p>
<h2 id="3-2-消费者接收消息"><a href="#3-2-消费者接收消息" class="headerlink" title="3.2 消费者接收消息"></a>3.2 消费者接收消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//实现消费方法</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当接收到消息后此方法将被调用</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 信封，通过envelope</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties 消息属性</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body 消息内容</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//交换机</span></span><br><span class="line">                String exchange = envelope.getExchange();</span><br><span class="line">                <span class="comment">//消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</span></span><br><span class="line">                <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认。</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean autoAck, Consumer callback</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细：</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</span></span><br><span class="line"><span class="comment">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221512.png" alt="img"></p>
<p>再看看队列的消息,已经被消费了</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221505.png" alt="img"></p>
<p>消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印.</p>
<h1 id="4-WorkQueues模式"><a href="#4-WorkQueues模式" class="headerlink" title="4. WorkQueues模式"></a>4. WorkQueues模式</h1><p>工作队列或者<strong>竞争消费者</strong>模式</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221500.png" alt="img"></p>
<p>work queues与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息，但是一个消息只能被一个消费者获取。</p>
<p>这个消息模型在Web应用程序中特别有用，可以处理短的HTTP请求窗口中无法处理复杂的任务。</p>
<p>接下来我们来模拟这个流程：</p>
<p>P：生产者：任务的发布者</p>
<p>C1：消费者1：领取任务并且完成任务，假设完成速度较慢（模拟耗时）</p>
<p>C2：消费者2：领取任务并且完成任务，假设完成速度较快</p>
<h2 id="4-1-生产者"><a href="#4-1-生产者" class="headerlink" title="4.1 生产者"></a>4.1 生产者</h2><blockquote>
<blockquote>
<p>生产者循环发送50条消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 循环发布任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String message = <span class="string">"task .. "</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"> </span><br><span class="line">            Thread.sleep(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h2 id="4-2-消费者1"><a href="#4-2-消费者1" class="headerlink" title="4.2 消费者1"></a>4.2 消费者1</h2><blockquote>
<blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//实现消费方法</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">                <span class="comment">//模拟任务耗时1s</span></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认。</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
</blockquote>
<h2 id="4-3-消费者2"><a href="#4-3-消费者2" class="headerlink" title="4.3 消费者2"></a>4.3 消费者2</h2><blockquote>
<blockquote>
<blockquote>
<p>代码与消费者1基本类似，只是消费者2没有设置消费耗时时间。</p>
<p>接下来，两个消费者一同启动，然后发送50条消息：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111161047.png" alt="1"></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221451.png" alt="无标题"></p>
<p>可以发现，两个消费者各自消费了不同25条消息，这就实现了任务的分发。   </p>
<p>刚才的实现有何问题</p>
<ol>
<li><p>消费者1比消费者2的效率要低，一次任务的耗时较长</p>
</li>
<li><p>然而两人最终消费的消息数量是一样的</p>
</li>
<li><p>消费者2大量时间处于空闲状态，消费者1一直忙碌</p>
</li>
</ol>
<p>现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。</p>
<p>怎么实现呢？</p>
<p>通过 BasicQos 方法设置prefetchCount = 1。这样RabbitMQ就会使得每个Consumer在同一个时间点最多处理1个Message。换句话说，在接收到该Consumer的ack前，他它</p>
<p>不会将新的Message分发给它。相反，它会将其分派给不是仍然忙碌的下一个Consumer。</p>
<p>值得注意的是：prefetchCount在手动ack的情况下才生效，自动ack不生效。<br><img src="https://gitee.com/biongd/img/raw/master/img/20220111221444.png" alt="无标题"></p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="5-订阅模式"><a href="#5-订阅模式" class="headerlink" title="5. 订阅模式"></a>5. 订阅模式</h1><p>说明下：</p>
<ol>
<li><p>一个生产者多个消费者</p>
</li>
<li><p>每个消费者都有一个自己的队列</p>
</li>
<li><p>生产者没有将消息直接发送给队列，而是发送给exchange(交换机、转发器)</p>
</li>
<li><p>每个队列都需要绑定到交换机上</p>
</li>
<li><p>生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者消费</p>
<p>例子：注册-&gt;发邮件、发短信</p>
</li>
</ol>
<p>X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p>
<p>Exchange类型有以下几种：</p>
<p>Fanout：广播，将消息交给所有绑定到交换机的队列</p>
<p>Direct：定向，把消息交给符合指定routing key 的队列</p>
<p>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</p>
<p>Header：header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。</p>
<p>Header模式不展开了，感兴趣可以参考这篇文章<a href="https://blog.csdn.net/zhu_tianwei/article/details/40923131" target="_blank" rel="noopener">https://blog.csdn.net/zhu_tianwei/article/details/40923131</a></p>
<p>Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h2 id="5-1-Publish-subscribe发布与订阅模型"><a href="#5-1-Publish-subscribe发布与订阅模型" class="headerlink" title="5.1 Publish/subscribe发布与订阅模型"></a>5.1 <strong>Publish/subscribe发布与订阅模型</strong></h2><p>（交换机类型：<strong>Fanout，也称为广播 </strong>）</p>
<p>模型示意图 ：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221436.png" alt="img"></p>
<h3 id="5-1-1-生产者"><a href="#5-1-1-生产者" class="headerlink" title="5.1.1 生产者"></a>5.1.1 生产者</h3><p>和前面两种模式不同：</p>
<ul>
<li>1） 声明Exchange，不再声明Queue</li>
<li>2） 发送消息到Exchange，不再发送到Queue</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_fanout_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"注册成功！！"</span>;</span><br><span class="line">        <span class="comment">// 发布消息到Exchange</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [生产者] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-消费者1-（注册成功发给短信服务）"><a href="#5-1-2-消费者1-（注册成功发给短信服务）" class="headerlink" title="5.1.2 消费者1 （注册成功发给短信服务）"></a>5.1.2 消费者1 （注册成功发给短信服务）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"fanout_exchange_queue_sms"</span>;<span class="comment">//短信队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_fanout_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [短信服务] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-3-消费者2（注册成功发给邮件服务）"><a href="#5-1-3-消费者2（注册成功发给邮件服务）" class="headerlink" title="5.1.3 消费者2（注册成功发给邮件服务）"></a>5.1.3 消费者2（注册成功发给邮件服务）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"fanout_exchange_queue_email"</span>;<span class="comment">//邮件队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_fanout_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [邮件服务] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们运行两个消费者，然后发送1条消息：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221430.png" alt="img"></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221422.png" alt="img"></p>
<p>思考：</p>
<p>1、publish/subscribe与work queues有什么区别。</p>
<p>区别：</p>
<p>1）work queues不用定义交换机，而publish/subscribe需要定义交换机。</p>
<p>2）publish/subscribe的生产方是面向交换机发送消息，work queues的生产方是面向队列发送消息(底层使用默认交换机)。</p>
<p>3）publish/subscribe需要设置队列和交换机的绑定，work queues不需要设置，实际上work queues会将队列绑定到默认的交换机 。</p>
<p>相同点：</p>
<p>所以两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。</p>
<p>2、实际工作用 publish/subscribe还是work queues。</p>
<p>建议使用 publish/subscribe，发布订阅模式比工作队列模式更强大（也可以做到同一队列竞争），并且发布订阅模式可以指定自己专用的交换机。</p>
<h2 id="5-2-Routing-路由模型"><a href="#5-2-Routing-路由模型" class="headerlink" title="5.2 Routing 路由模型"></a>5.2 Routing 路由模型</h2><p>Routing模型示意图：</p>
<p> <img src="https://gitee.com/biongd/img/raw/master/img/20220111221415.png" alt="img"></p>
<p>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p>
<p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p>
<p>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</p>
<p>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p>
<p>接下来看代码：</p>
<h3 id="5-2-1-生产者"><a href="#5-2-1-生产者" class="headerlink" title="5.2.1 生产者"></a>5.2.1 生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_direct_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 消息内容，</span></span><br><span class="line">        String message = <span class="string">"注册成功！请短信回复[T]退订"</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：sms，只有短信服务能接收到消息</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"sms"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-消费者1"><a href="#5-2-2-消费者1" class="headerlink" title="5.2.2 消费者1"></a>5.2.2 消费者1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"direct_exchange_queue_sms"</span>;<span class="comment">//短信队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_direct_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"sms"</span>);<span class="comment">//指定接收发送方指定routing key为sms的消息</span></span><br><span class="line">        <span class="comment">//channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "email");</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [短信服务] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-3-消费者2"><a href="#5-2-3-消费者2" class="headerlink" title="5.2.3 消费者2"></a>5.2.3 消费者2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"direct_exchange_queue_email"</span>;<span class="comment">//邮件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_direct_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"email"</span>);<span class="comment">//指定接收发送方指定routing key为email的消息</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [邮件服务] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发送sms的RoutingKey，发现结果：只有指定短信的消费者1收到消息了</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221404.png" alt="img"></p>
<h2 id="5-3-Topics-通配符模式"><a href="#5-3-Topics-通配符模式" class="headerlink" title="5.3 Topics 通配符模式"></a>5.3 Topics 通配符模式</h2><p>Topics模型示意图：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221401.png" alt="img"></p>
<p>每个消费者监听自己的队列，并且设置带统配符的routingkey,生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。</p>
<p>Routingkey一般都是有一个或者多个单词组成，多个单词之间以“.”分割，例如：inform.sms</p>
<p>通配符规则：</p>
<h1 id="：匹配一个或多个词"><a href="#：匹配一个或多个词" class="headerlink" title="：匹配一个或多个词"></a>：匹配一个或多个词</h1><p>*：匹配不多不少恰好1个词</p>
<p>举例：</p>
<p>audit.#：能够匹配audit.irs.corporate 或者 audit.irs</p>
<p>audit.*：只能匹配audit.irs</p>
<p>从示意图可知，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的Routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。</p>
<p>我们创建了三个绑定：Q1绑定了“<em>.orange.</em>”，Q2绑定了“.<em>.</em>.rabbit”和“lazy.＃”。</p>
<p>Q1匹配所有的橙色动物。</p>
<p>Q2匹配关于兔子以及懒惰动物的消息。</p>
<p> 下面做个小练习，假如生产者发送如下消息，会进入哪个队列：</p>
<p>quick.orange.rabbit       Q1 Q2   routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2</p>
<p>lazy.orange.elephant    Q1 Q2</p>
<p>quick.orange.fox           Q1</p>
<p>lazy.pink.rabbit              Q2  (值得注意的是，虽然这个routingKey与Q2的两个bindingKey都匹配，但是只会投递Q2一次)</p>
<p>quick.brown.fox            不匹配任意队列，被丢弃</p>
<p>quick.orange.male.rabbit   不匹配任意队列，被丢弃</p>
<p>orange         不匹配任意队列，被丢弃</p>
<p>下面我们以指定Routing key=”quick.orange.rabbit”为例，验证上面的答案</p>
<h3 id="5-3-1-生产者"><a href="#5-3-1-生产者" class="headerlink" title="5.3.1 生产者"></a>5.3.1 生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_topic_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为topic</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"这是一只行动迅速的橙色的兔子"</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key为：quick.orange.rabbit</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"quick.orange.rabbit"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [动物描述：] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-消费者1"><a href="#5-3-2-消费者1" class="headerlink" title="5.3.2 消费者1"></a>5.3.2 消费者1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"topic_exchange_queue_Q1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_topic_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅所有的橙色动物</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"*.orange.*"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-3-消费者2"><a href="#5-3-3-消费者2" class="headerlink" title="5.3.3 消费者2"></a>5.3.3 消费者2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"topic_exchange_queue_Q2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_topic_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅关于兔子以及懒惰动物的消息</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"*.*.rabbit"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"lazy.＃"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者2] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果C1、C2是都接收到消息了：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221353.png" alt="img"></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221350.png" alt="img"></p>
<h1 id="6-Spring整合RabbitMQ"><a href="#6-Spring整合RabbitMQ" class="headerlink" title="6. Spring整合RabbitMQ"></a>6. Spring整合RabbitMQ</h1><h2 id="6-1-生产者"><a href="#6-1-生产者" class="headerlink" title="6.1 生产者"></a>6.1 生产者</h2><ol>
<li><p>创建消息生产者项目：spring_rabbitmq_producer</p>
</li>
<li><p>添加依赖　</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写spring整合rabbitmq配置文件：spring-rabbitmq-producer.xml </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 配置连接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">　　 <span class="attr">host</span>=<span class="string">"127.0.0.1"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">port</span>=<span class="string">"5672"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">username</span>=<span class="string">"pomelo"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">password</span>=<span class="string">"pomelo"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">virtual-host</span>=<span class="string">"/pomelo"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 配置队列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"myQueue"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.配置rabbitAdmin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. 配置topic类型exchange；队列绑定到交换机 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:topic-exchange</span> <span class="attr">name</span>=<span class="string">"myExchange"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">"myQueue"</span> <span class="attr">pattern</span>=<span class="string">"msg.#"</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:topic-exchange</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 5. 配置消息对象json转换类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jsonMessageConverter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.support.converter.Jackson2JsonMessageConverter"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 6. 配置RabbitTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">id</span>=<span class="string">"rabbitTemplate"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">exchange</span>=<span class="string">"myExchange"</span></span></span><br><span class="line"><span class="tag">　　 <span class="attr">message-converter</span>=<span class="string">"jsonMessageConverter"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发消息测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pomelo.producer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">　　　　<span class="comment">//创建spring容器</span></span><br><span class="line">　　　　ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-rabbitmq-producer.xml"</span>);</span><br><span class="line">　　　　<span class="comment">//从容器中获取对象</span></span><br><span class="line">　　　　RabbitTemplate template = context.getBean(RabbitTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">　　　　<span class="comment">// 发送消息</span></span><br><span class="line">　　　　Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">　　　　map.put(<span class="string">"email"</span>,<span class="string">"550731230@qq.com"</span>);</span><br><span class="line">　　　　template.convertAndSend(<span class="string">"msg.email"</span>,map);</span><br><span class="line">　　　　context.close();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-2-消费者"><a href="#6-2-消费者" class="headerlink" title="6.2 消费者"></a>6.2 消费者</h2><ol>
<li><p>创建消费者项目：spring_rabbitmq_consumer</p>
</li>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写消息监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pomelo.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">　　<span class="meta">@Override</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">try</span> &#123;</span><br><span class="line">　　　　　　JsonNode jsonNode = MAPPER.readTree(message.getBody());</span><br><span class="line">　　　　　　String email = jsonNode.get(<span class="string">"email"</span>).asText();</span><br><span class="line">　　　　　　System.out.println(<span class="string">"获取队列中消息："</span> + email);</span><br><span class="line">　　　　&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">　　　　　　e.printStackTrace();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写spring整合rabbitmq配置文件：spring-rabbitmq-consumer.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. springIOC注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.pomelo.listener"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 配置连接工厂 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">host</span>=<span class="string">"127.0.0.1"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">port</span>=<span class="string">"5672"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">username</span>=<span class="string">"pomelo"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">password</span>=<span class="string">"pomelo"</span></span></span><br><span class="line"><span class="tag">　　<span class="attr">virtual-host</span>=<span class="string">"/pomelo"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. 配置队列名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"myQueue"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4.配置rabbitAdmin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 5.配置监听 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">"emailMessageListener"</span> <span class="attr">queue-names</span>=<span class="string">"myQueue"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行项目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pomelo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">　　　　ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-rabbitmq-consumer.xml"</span>);</span><br><span class="line">　　　　System.in.read();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="7-SpringBoot整合RabbitMQ"><a href="#7-SpringBoot整合RabbitMQ" class="headerlink" title="7. SpringBoot整合RabbitMQ"></a>7. SpringBoot整合RabbitMQ</h1><p>搭建SpringBoot环境</p>
<p>同样创建两个工程 mq-rabbitmq-producer和mq-rabbitmq-consumer</p>
<ol>
<li><p>添加AMQP的启动器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在application.yml中添加RabbitMQ的配置：  </p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span>  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mq-rabbitmq-producer</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">kavito</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">virtualHost:</span> <span class="string">/kavito</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">10000ms</span></span><br><span class="line">        <span class="attr">max-interval:</span> <span class="string">300000ms</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">exchange:</span> <span class="string">topic.exchange</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>属性说明： </p>
<p>template：有关<code>AmqpTemplate</code>的配置</p>
<p>retry：失败重试</p>
<p>enabled：开启失败重试</p>
<p>initial-interval：第一次重试的间隔时长</p>
<p>max-interval：最长重试间隔，超过这个间隔将不再重试</p>
<p>multiplier：下次重试间隔的倍数，此处是2即下次重试间隔是上次的2倍</p>
<p>exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个</p>
<p>publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试</p>
<p>当然如果consumer只是接收消息而不发送，就不用配置template相关内容。  </p>
</li>
<li><p>定义RabbitConfig配置类，配置Exchange、Queue、及绑定交换机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_EMAIL = <span class="string">"queue_email"</span>;<span class="comment">//email队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_SMS = <span class="string">"queue_sms"</span>;<span class="comment">//sms队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">"topic.exchange"</span>;<span class="comment">//topics类型交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTINGKEY_EMAIL=<span class="string">"topic.#.email.#"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTINGKEY_SMS=<span class="string">"topic.#.sms.#"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="meta">@Bean</span>(EXCHANGE_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">exchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//durable(true) 持久化，mq重启之后交换机还在</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="keyword">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明email队列</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   new Queue(QUEUE_EMAIL,true,false,false)</span></span><br><span class="line"><span class="comment">     *   durable="true" 持久化 rabbitmq重启的时候不需要创建新的队列</span></span><br><span class="line"><span class="comment">     *   auto-delete 表示消息队列没有在使用时将被自动删除 默认是false</span></span><br><span class="line"><span class="comment">     *   exclusive  表示该消息队列是否只在当前connection生效,默认是false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(QUEUE_EMAIL)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">emailQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_EMAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明sms队列</span></span><br><span class="line">    <span class="meta">@Bean</span>(QUEUE_SMS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">smsQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_SMS);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//ROUTINGKEY_EMAIL队列绑定交换机，指定routingKey</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingEmail</span><span class="params">(@Qualifier(QUEUE_EMAIL)</span> Queue queue,</span></span><br><span class="line"><span class="function">                                @<span class="title">Qualifier</span><span class="params">(EXCHANGE_NAME)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(ROUTINGKEY_EMAIL).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ROUTINGKEY_SMS队列绑定交换机，指定routingKey</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingSMS</span><span class="params">(@Qualifier(QUEUE_SMS)</span> Queue queue,</span></span><br><span class="line"><span class="function">                              @<span class="title">Qualifier</span><span class="params">(EXCHANGE_NAME)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(ROUTINGKEY_SMS).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="7-1-生产者-mq-rabbitmq-producer"><a href="#7-1-生产者-mq-rabbitmq-producer" class="headerlink" title="7.1 生产者(mq-rabbitmq-producer)"></a>7.1 生产者(mq-rabbitmq-producer)</h2><p>为了方便测试，我直接把生产者代码放工程测试类：发送routing key是”topic.sms.email”的消息，那么mq-rabbitmq-consumer下那些监听的（与交换机(topic.exchange)绑定，并且订阅的routingkey中匹配了”topic.sms.email”规则的） 队列就会收到消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsgByTopics</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数：</span></span><br><span class="line"><span class="comment">         * 1、交换机名称</span></span><br><span class="line"><span class="comment">         * 2、routingKey</span></span><br><span class="line"><span class="comment">         * 3、消息内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            String message = <span class="string">"恭喜您，注册成功！userid="</span>+i;</span><br><span class="line">            rabbitTemplate.convertAndSend(RabbitmqConfig.EXCHANGE_NAME,<span class="string">"topic.sms.email"</span>,message);</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试类发送5条消息： </p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221341.png" alt="img"></p>
<p>web管理界面： 可以看到已经创建了交换机以及queue_email、queue_sms 2个队列，并且向这两个队列分别发送了5条消息</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111165142.png" alt="img"></p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111165136.png" alt="img"></p>
<h2 id="7-2-消费者-mq-rabbitmq-consumer"><a href="#7-2-消费者-mq-rabbitmq-consumer" class="headerlink" title="7.2 消费者(mq-rabbitmq-consumer)"></a>7.2 消费者(mq-rabbitmq-consumer)</h2><p>编写一个监听器组件，通过注解配置消费者队列，以及队列与交换机之间绑定关系。（也可以像生产者那样通过配置类配置）</p>
<p>在SpringAmqp中，对消息的消费者进行了封装和抽象。一个JavaBean的方法，只要添加@RabbitListener注解，就可以成为了一个消费者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//监听邮件队列</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            value = <span class="meta">@Queue</span>(value = <span class="string">"queue_email"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(</span><br><span class="line">                    value = <span class="string">"topic.exchange"</span>,</span><br><span class="line">                    ignoreDeclarationExceptions = <span class="string">"true"</span>,</span><br><span class="line">                    type = ExchangeTypes.TOPIC</span><br><span class="line">            ),</span><br><span class="line">            key = &#123;<span class="string">"topic.#.email.#"</span>,<span class="string">"email.*"</span>&#125;))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rece_email</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" [邮件服务] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//监听短信队列</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            value = <span class="meta">@Queue</span>(value = <span class="string">"queue_sms"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(</span><br><span class="line">                    value = <span class="string">"topic.exchange"</span>,</span><br><span class="line">                    ignoreDeclarationExceptions = <span class="string">"true"</span>,</span><br><span class="line">                    type = ExchangeTypes.TOPIC</span><br><span class="line">            ),</span><br><span class="line">            key = &#123;<span class="string">"topic.#.sms.#"</span>&#125;))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rece_sms</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" [短信服务] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性说明： </p>
<p>@Componet：类上的注解，注册到Spring容器<br>@RabbitListener：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性：</p>
<p>bindings：指定绑定关系，可以有多个。值是@QueueBinding的数组。@QueueBinding包含下面属性：</p>
<p>value：这个消费者关联的队列。值是@Queue，代表一个队列</p>
<p>exchange：队列所绑定的交换机，值是@Exchange类型</p>
<p>key：队列和交换机绑定的RoutingKey，可指定多个</p>
<p>启动mq-rabbitmq-comsumer项目:</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111165129.png" alt="img"></p>
<h1 id="8-高级特性"><a href="#8-高级特性" class="headerlink" title="8. 高级特性"></a>8. 高级特性</h1><h1 id="8-1-投递消息机制"><a href="#8-1-投递消息机制" class="headerlink" title="8.1 投递消息机制"></a>8.1 投递消息机制</h1><h3 id="8-1-1-Confirm确认消息"><a href="#8-1-1-Confirm确认消息" class="headerlink" title="8.1.1 Confirm确认消息"></a>8.1.1 Confirm确认消息</h3><ul>
<li><p>消息确认，是指生产者消息投递后，如果Broker收到消息，则会给生产者一个应答</p>
</li>
<li><p>生产者进行接收应答，用来确定这条消息是否正常的发送到Broker，这种方式也是消息的可靠性投递的核心保障</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221327.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>生成者发送消息与监听confirm是异步的。</strong></p>
</li>
</ul>
<p>如何实现Confirm确认消息？</p>
<ol>
<li>在channel上开启确认模式:channel.confirmSelect()</li>
<li>在channel上添加监听：addConfirmListener，监听成功和失败的返回结果，根据具体返回结果对消息进行重发或日志记录等</li>
</ol>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConn();</span><br><span class="line">        <span class="comment">//1. 通过connection创建一个Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//2.指定消息确认模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        String exchangeName = <span class="string">"test_confirm_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"confirm.save"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 通过Channel发送数据</span></span><br><span class="line">        String message = <span class="string">"Hello from Producer"</span>;</span><br><span class="line">        channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 添加一个确认监听</span></span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//成功的情况 deliveryTag:消息的唯一标签；</span></span><br><span class="line">                System.out.println(<span class="string">"——get ack——"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//失败的情况</span></span><br><span class="line">                System.out.println(<span class="string">"——have no  ack——"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭掉就没confirm了</span></span><br><span class="line">        <span class="comment">// CloseTool.closeElegantly(channel,connection);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConn();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 通过connection创建一个Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">"test_confirm_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"confirm.save"</span>;</span><br><span class="line">        String queueName = <span class="string">"test_confirm_queue"</span>;</span><br><span class="line">        <span class="comment">//2. 声明一个exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName,<span class="string">"topic"</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//3. 声明一个队列</span></span><br><span class="line">        channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//4. 绑定</span></span><br><span class="line">        channel.queueBind(queueName,exchangeName,routingKey);</span><br><span class="line">        <span class="comment">//5. 创建消费者</span></span><br><span class="line">        QueueingConsumer queueingConsumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        <span class="comment">//6. 设置Channel</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="keyword">true</span>,queueingConsumer);</span><br><span class="line">        <span class="comment">//7. 获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//nextDelivery 会阻塞直到有消息过来</span></span><br><span class="line">            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"收到:"</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-1-2-return返回消息"><a href="#8-1-2-return返回消息" class="headerlink" title="8.1.2 return返回消息"></a>8.1.2 return返回消息</h3><ul>
<li>Return Listener用于处理一些不可路由消息</li>
<li>生产者指定Exchange和RoutingKey，将消息投递到某个队列，然后消费者监听队列，进行消息处理</li>
<li>但在某些情况下，在发送消息时，若当前的exchange不存在或指定的路由key路由失败，这时，如果需要监听这种不可达的消息，则要使用return listener</li>
</ul>
<p><strong>return 消息机制</strong></p>
<p>在基础API中有一个关键的配置项：</p>
<ul>
<li><code>Mandatory</code> : 若为true,则监听器会接收到路由不可达的消息，然后进行后粗处理 ；若为false，则broker端自动删除该消息</li>
</ul>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221321.png" alt="在这里插入图片描述"></p>
<p>发送端发送了一条消息，但是没有发现Exchange，则可通过return listener监听这些消息</p>
<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MQ_HOST = <span class="string">"192.168.222.101"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MQ_VHOST = <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MQ_PORT = <span class="number">5672</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建一个ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(MQ_HOST);<span class="comment">//配置host</span></span><br><span class="line">        connectionFactory.setPort(MQ_PORT);<span class="comment">//配置port</span></span><br><span class="line">        connectionFactory.setVirtualHost(MQ_VHOST);<span class="comment">//配置vHost</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 通过连接工厂创建连接</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3. 通过connection创建一个Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        String exchange = <span class="string">"test_return_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"return.save"</span>;</span><br><span class="line">        String routingKeyError = <span class="string">"abc.save"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 通过Channel发送数据</span></span><br><span class="line">        String message = <span class="string">"Hello Return Message"</span>;</span><br><span class="line"></span><br><span class="line">        channel.addReturnListener((replyCode, replyText, exchange1, routingKey1, properties, body) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"——handle return——"</span>);</span><br><span class="line">            System.out.println(<span class="string">"replyCode:"</span> + replyCode);</span><br><span class="line">            System.out.println(<span class="string">"replyText:"</span> + replyText);</span><br><span class="line">            System.out.println(<span class="string">"exchange1:"</span> + exchange1);</span><br><span class="line">            System.out.println(<span class="string">"routingKey1:"</span> + routingKey1);</span><br><span class="line">            System.out.println(<span class="string">"properties:"</span> + properties);</span><br><span class="line">            System.out.println(<span class="string">"body:"</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mandatory : true</span></span><br><span class="line">        <span class="comment">//channel.basicPublish(exchange,routingKey,true,null,message.getBytes());</span></span><br><span class="line">        channel.basicPublish(exchange,routingKeyError,<span class="keyword">true</span>,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConn();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 通过connection创建一个Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchange = <span class="string">"test_return_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"return.#"</span>;</span><br><span class="line">        String queueName = <span class="string">"test_return_queue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 声明一个exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchange,<span class="string">"topic"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//3. 声明一个队列</span></span><br><span class="line">        channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//4. 绑定</span></span><br><span class="line">        channel.queueBind(queueName,exchange,routingKey);</span><br><span class="line">        <span class="comment">//5. 创建消费者</span></span><br><span class="line">        QueueingConsumer queueingConsumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        <span class="comment">//6. 设置Channel</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="keyword">true</span>,queueingConsumer);</span><br><span class="line">        <span class="comment">//7. 获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//nextDelivery 会阻塞直到有消息过来</span></span><br><span class="line">            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"收到:"</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当生产端执行channel.basicPublish(exchange,routingKey,true,null,message.getBytes());消息能发送成功，也可以从消费端看到打印</p>
<p>当执行channel.basicPublish(exchange,routingKeyError,true,null,message.getBytes());消息发送失败，因为路由失败了嘛，生产端能看到如下打印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">——handle <span class="keyword">return</span>——</span><br><span class="line">replyCode:<span class="number">312</span></span><br><span class="line">replyText:NO_ROUTE</span><br><span class="line">exchange1:test_return_exchange</span><br><span class="line">routingKey1:abc.save</span><br><span class="line">properties:#contentHeader&lt;basic&gt;(content-type=null, content-encoding=null, headers=null, delivery-mode=null, priority=null, correlation-id=null, reply-to=null, expiration=null, message-id=null, timestamp=null, type=null, user-id=null, app-id=null, cluster-id=null)</span><br><span class="line">body:Hello Return Message</span><br></pre></td></tr></table></figure>
<p>若生产端将mandatory设为false,则ReturnListener不会进行回调</p>
<h2 id="8-2-consumer-ACK"><a href="#8-2-consumer-ACK" class="headerlink" title="8.2 consumer ACK"></a>8.2 consumer ACK</h2><p>在RabbitMQ中指代的是消费者收到消息后确认的一种行为，关注点在于消费者能否实际接收到MQ发送的消息。</p>
<p>其提供了三种确认方式：</p>
<ol>
<li>自动确认acknowledge=”none”：当消费者接收到消息的时候，就会自动给到RabbitMQ一个回执，告诉MQ我已经收到消息了，不在乎消费者接收到消息之后业务处理的成功与否。</li>
<li>手动确认acknowledge=”manual”：当消费者收到消息后，不会立刻告诉RabbitMQ已经收到消息了，而是等待业务处理成功后，通过调用代码的方式手动向MQ确认消息已经收到。当业务处理失败，就可以做一些重试机制，甚至让MQ重新向消费者发送消息都是可以的。</li>
<li>根据异常情况确认acknowledge=”auto”：该方式是通过抛出异常的类型，来做响应的处理（如重发、确认等布拉不拉布拉）。这种方式比较麻烦。</li>
</ol>
<p>当消息一旦被消费者接收到，会立刻自动向MQ确认接收，并将响应的message从RabbitMQ消息缓存中移除，但是在实际的业务处理中，会出现消息收到了，但是业务处理出现异常的情况，在自动确认的模式下，该条业务处理失败的message就相当于被丢弃了。如果设置了手动确认，则需要在业务处理完成之后，手动调用channel.basicAck()，手动的签收，如果业务处理失败，则手动调用channel.basicNack()方法拒收，并让MQ重新发送该消息。</p>
<p>如果不做任何关于acknowledge的配置，默认就是自动确认签收的。<br>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 功能描述: &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 〈测试Consumer Ack〉</span></span><br><span class="line"><span class="comment">     * @Param: []</span></span><br><span class="line"><span class="comment">     * @Return: void</span></span><br><span class="line"><span class="comment">     * @Author: LeoLee</span></span><br><span class="line"><span class="comment">     * @Date: 2020/11/7 21:12</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAck</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//        //消费者接收到该消息，解析到true，就模拟调用channel.basicAck确认签收消息</span></span><br><span class="line"><span class="comment">//        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME, "boot.test", "test msg send [true]");</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//消费者接收到该消息，解析到false，就模拟调用channel.basicNack，拒收消息，让MQ重发</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME, <span class="string">"boot.test"</span>, <span class="string">"test msg send [false]"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>消费者端打开Ack模式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">2002</span></span><br><span class="line"> </span><br><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: xxxxxxxxx</span><br><span class="line">    password: xxxxxxxxx</span><br><span class="line">    virtual-host: /LeoLee</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        acknowledge-mode: manual #消费者端确认模式:none自动确认 manual手动确认 auto通过抛出异常的类型，来做响应的处理</span><br><span class="line">        concurrency: 1 #当前监听的数量</span><br><span class="line">        max-concurrency: 5 #最大监听数量</span><br><span class="line">        retry:</span><br><span class="line">          enabled: true #是否支持重试</span><br><span class="line">          max-attempts: 4 #最大重试次数，默认为3</span><br></pre></td></tr></table></figure>
<p>消费者端创建一个listener并实现ChannelAwareMessageListener接口（其实也可以不实现该接口，只要@RabbitListener标记的方法，或者@RabbitListener标记的类+@RabbitHandler标记的方法的参数列表有[com.rabbitmq.client.Channel]和[org.springframework.amqp.core.Message]两个参数，都可以）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leolee.rabbitmq.MsgListener;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> AckListener</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Consumer Ack</span></span><br><span class="line"><span class="comment"> * 1.设置手动确认签收:acknowledge-mode: manual, retry.enabled: true #是否支持重试</span></span><br><span class="line"><span class="comment"> * 2.实现ChannelAwareMessageListener接口，ChannelAwareMessageListener是MessageListener的子接口</span></span><br><span class="line"><span class="comment"> * 3.如果消息接收并处理完成，调用channel.basicAck()向MQ确认签收</span></span><br><span class="line"><span class="comment"> * 4.如果消息接收但是业务处理失败，调用channel.basicNack()拒收，要求MQ重新发送</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LeoLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/11/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> V1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AckListener</span> <span class="keyword">implements</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"boot_queue"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">boolean</span> tag = <span class="keyword">new</span> String(message.getBody()).contains(<span class="string">"true"</span>);</span><br><span class="line">        System.out.println(<span class="string">"接收到msg:"</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        <span class="comment">//获取mes deliveryTag</span></span><br><span class="line">        <span class="keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">                System.out.println(<span class="string">"业务处理成功"</span>);</span><br><span class="line">                <span class="comment">//手动签收</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * deliveryTag：the tag from the received &#123;@link com.rabbitmq.client.AMQP.Basic.GetOk&#125; or &#123;@link com.rabbitmq.client.AMQP.Basic.Deliver&#125;</span></span><br><span class="line"><span class="comment">                 * multiple: ture确认本条消息以及之前没有确认的消息，false仅确认本条消息</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//模拟业务处理失败抛出异常</span></span><br><span class="line">                System.out.println(<span class="string">"业务处理失败"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"业务处理失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * deliveryTag：the tag from the received &#123;@link com.rabbitmq.client.AMQP.Basic.GetOk&#125; or &#123;@link com.rabbitmq.client.AMQP.Basic.Deliver&#125;</span></span><br><span class="line"><span class="comment">             * multiple: ture确认本条消息以及之前没有确认的消息，false仅确认本条消息</span></span><br><span class="line"><span class="comment">             * requeue: true该条消息重新返回MQ queue，MQ broker将会重新发送该条消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicNack(deliveryTag, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//也可以使用channel.basicReject(deliveryTag, requeue),它只能拒收单条消息</span></span><br><span class="line">            <span class="comment">//channel.basicReject(deliveryTag, true);</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用生产者测试类发送不同的消息给MQ</p>
<p>成功接收并手动确认后，MQ队列就删除了该消息的缓存：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221313.png" alt="img"></p>
<p>被拒绝的消息会一直发送：</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111220824.png" alt="img"></p>
<h2 id="8-3-消费端限流"><a href="#8-3-消费端限流" class="headerlink" title="8.3 消费端限流"></a>8.3 消费端限流</h2><p>RabbitMQ限流机制</p>
<p>RabbitMQ提供了QOS限流功能，在非自动确认消息的前提下，如果有一定数目的未被确认前，不消费新的消息。</p>
<p><strong><em>在消费端开启限流机制</em></strong></p>
<ol>
<li>把<code>channel.basicConsume(...)</code>方法的<code>autoAck</code>参数改为false</li>
<li>设置Qos</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">0</span>,<span class="number">1</span>,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> prefetchSize 消息的大小，设置为0不做任何限制</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> prefetchCount 每次消费消息数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> global  为true channel级别的限流，false 消费端限流</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchSize, <span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> global)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>生产端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="comment">//设置虚拟主机</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个链接</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String exchangeName=<span class="string">"test_qos_exchange"</span>;</span><br><span class="line">        String routeKey=<span class="string">"qos.test"</span>;</span><br><span class="line">        String msg=<span class="string">"RabbitMQ QOS message QOS test!"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            channel.basicPublish(exchangeName,routeKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>消费端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="comment">//设置虚拟主机</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">//创建链接</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        String exchangeName=<span class="string">"test_qos_exchange"</span>;</span><br><span class="line">        String exchangeType=<span class="string">"topic"</span>;</span><br><span class="line">        <span class="comment">//声明Exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName,exchangeType,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        String queueName=<span class="string">"test_qos_queue"</span>;</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        String routeKey=<span class="string">"qos.#"</span>;</span><br><span class="line">        <span class="comment">//绑定队列和交换机</span></span><br><span class="line">        channel.queueBind(queueName,exchangeName,routeKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置限流</span></span><br><span class="line">        channel.basicQos(<span class="number">0</span>,<span class="number">1</span>,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  把autoAck设置为false，限流才生效</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收到消息：："</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                    <span class="comment">//不批量签收</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果想看限流效果可先把消费端的这行代码<code>channel.basicAck(envelope.getDeliveryTag(),false);</code>先注释。<br> 在RabbitMQ控制台可以看到，有4条消息未被消费，一条消息等待签收确认。只有当前消息签收后，才消费剩余的消息</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221252.png" alt="在这里插入图片描述"></p>
<h2 id="8-4-TTL"><a href="#8-4-TTL" class="headerlink" title="8.4 TTL"></a>8.4 TTL</h2><p>TTL队列/消息</p>
<p>TTL是Time To Live的缩写, 也就是生存时间<br>RabbitMQ支持消息的过期时间, 在消息发送时可以进行指定<br>RabbitMQ支持队列的过期时间, 从消息入队列开始计算, 只要超过了队列的超时时间配置, 那么消息会自动清除</p>
<p>代码演示</p>
<p>消费者中设置队列超时时间为10秒, 启动之后关闭消费者<br>生产者发送两条消息, 一条消息不设置超时时间, 一条消息设置5秒后超时<br>启动生产者之后, 监控RabbitMQ控制台, 发现5秒后设置了消息超时时间的消息先超时清除, 然后10秒后另外一条消息也超时清除</p>
<p>配置文件</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111221928.png" alt="image-20220111221928714"></p>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qiyexue.api.ttl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建连接工厂, 设置属性</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.72.138"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用connection创建channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 通过channel发送消息</span></span><br><span class="line">        String msg = <span class="string">"hello rabbitmq!"</span>;</span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties();</span><br><span class="line">        Map&lt;String,Object&gt; headers = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        headers.put(<span class="string">"name"</span>, <span class="string">"七夜雪"</span>);</span><br><span class="line">        properties = properties.builder()</span><br><span class="line">                <span class="comment">// 设置编码为UTF8</span></span><br><span class="line">                .contentEncoding(<span class="string">"UTF-8"</span>)</span><br><span class="line">                <span class="comment">// 设置自定义Header</span></span><br><span class="line">                .headers(headers)</span><br><span class="line">                <span class="comment">// 设置消息失效时间</span></span><br><span class="line">                .expiration(<span class="string">"5000"</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置了消息超时时间为5秒, 5秒后消息自动删除</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, <span class="string">"test_ttl_queue"</span>, properties, msg.getBytes());</span><br><span class="line">        <span class="comment">// 没有设置消息存活时间,消息存活时间根据队列来决定</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, <span class="string">"test_ttl_queue"</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qiyexue.api.ttl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.QueueingConsumer.Delivery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建连接工厂, 设置属性</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.72.138"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用connection创建channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 声明(创建)一个队列</span></span><br><span class="line">        String queueName = <span class="string">"test_ttl_queue"</span>;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置队列超时时间为10秒</span></span><br><span class="line">        arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">10000</span>);</span><br><span class="line">        channel.queueDeclare(queueName,<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 创建消费者</span></span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 设置channel</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 7. 获取消息</span></span><br><span class="line">            Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(delivery.getBody()));</span><br><span class="line">            <span class="comment">// 获取head中内容</span></span><br><span class="line">            System.out.println(delivery.getProperties().getHeaders().get(<span class="string">"name"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-5-死信队列介绍"><a href="#8-5-死信队列介绍" class="headerlink" title="8.5 死信队列介绍"></a>8.5 死信队列介绍</h2><ul>
<li>死信队列：DLX，<code>dead-letter-exchange</code></li>
<li>利用DLX，当消息在一个队列中变成死信 <code>(dead message)</code> 之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX</li>
</ul>
<p>消息变成死信有以下几种情况:</p>
<ul>
<li>消息被拒绝(basic.reject / basic.nack)，并且requeue = false</li>
<li>消息TTL过期</li>
<li>队列达到最大长度</li>
</ul>
<p>死信处理过程:</p>
<ul>
<li>DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。</li>
<li>当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。</li>
<li>可以监听这个队列中的消息做相应的处理。</li>
</ul>
<h5 id="死信队列设置"><a href="#死信队列设置" class="headerlink" title="死信队列设置"></a>死信队列设置</h5><ol>
<li><p>首先需要设置死信队列的exchange和queue，然后进行绑定：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exchange: dlx.exchange</span><br><span class="line">Queue: dlx.queue</span><br><span class="line">RoutingKey: #</span><br><span class="line">#表示只要有消息到达了Exchange，那么都会路由到这个queue上</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后需要有一个监听，去监听这个队列进行处理</p>
</li>
<li><p>然后我们进行正常声明交换机、队列、绑定，只不过我们需要在队列加上一个参数即可：<code>arguments.put(&quot; x-dead-letter-exchange&quot;，&quot;dlx.exchange&quot;);</code>，这样消息在过期、requeue、 队列在达到最大长度时，消息就可以直接路由到死信队列！</p>
</li>
</ol>
<p>生产端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1 创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"192.168.43.157"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">//2 获取Connection</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3 通过Connection创建一个新的Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        String exchange = <span class="string">"test_dlx_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"dlx.save"</span>;</span><br><span class="line">        </span><br><span class="line">        String msg = <span class="string">"Hello RabbitMQ DLX Message"</span>;</span><br><span class="line">        </span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                .contentEncoding(<span class="string">"UTF-8"</span>)</span><br><span class="line">                .expiration(<span class="string">"10000"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        channel.basicPublish(exchange, routingKey, <span class="keyword">true</span>, properties, msg.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义消费端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"-----------consume message----------"</span>);</span><br><span class="line">        System.err.println(<span class="string">"consumerTag: "</span> + consumerTag);</span><br><span class="line">        System.err.println(<span class="string">"envelope: "</span> + envelope);</span><br><span class="line">        System.err.println(<span class="string">"properties: "</span> + properties);</span><br><span class="line">        System.err.println(<span class="string">"body: "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h6><ul>
<li>声明正常处理消息的交换机、队列及绑定规则</li>
<li>在正常交换机上指定死信发送的Exchange</li>
<li>声明死信交换机、队列及绑定规则</li>
<li>监听死信队列，进行后续处理，这里省略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"192.168.43.157"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        </span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 声明一个普通的交换机 和 队列 以及路由</span></span><br><span class="line">        String exchangeName = <span class="string">"test_dlx_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"dlx.#"</span>;</span><br><span class="line">        String queueName = <span class="string">"test_dlx_queue"</span>;</span><br><span class="line">        </span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">"topic"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//指定死信发送的Exchange</span></span><br><span class="line">        Map&lt;String, Object&gt; agruments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        agruments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"dlx.exchange"</span>);</span><br><span class="line">        <span class="comment">//这个agruments属性，要设置到声明队列上</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, agruments);</span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//要进行死信队列的声明</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">"dlx.exchange"</span>, <span class="string">"topic"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(<span class="string">"dlx.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">"dlx.queue"</span>, <span class="string">"dlx.exchange"</span>, <span class="string">"#"</span>);</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> MyConsumer(channel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="运行说明"><a href="#运行说明" class="headerlink" title="运行说明"></a>运行说明</h6><p>启动消费端，此时查看管控台，新增了两个Exchange，两个Queue。在<code>test_dlx_queue</code>上我们设置了DLX，也就代表死信消息会发送到指定的Exchange上，最终其实会路由到<code>dlx.queue</code>上。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111222310.png" alt="img"></p>
<p>此时关闭消费端，然后启动生产端，查看管控台队列的消息情况，<code>test_dlx_queue</code>的值为1，而<code>dlx_queue</code>的值为0。<br> 10s后的队列结果如图，由于生产端发送消息时指定了消息的过期时间为10s，而此时没有消费端进行消费，消息便被路由到死信队列中。</p>
<p><img src="https://gitee.com/biongd/img/raw/master/img/20220111222336.png" alt="img"></p>
<h2 id="8-6-延迟队列"><a href="#8-6-延迟队列" class="headerlink" title="8.6 延迟队列"></a>8.6 延迟队列</h2><p>延迟队列存储的对象肯定是对应的延迟消息，所谓”延迟消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。</p>
<p>场景一：在订单系统中，一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行一场处理。这是就可以使用延迟队列将订单信息发送到延迟队列。</p>
<p>场景二：用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时候就可以将用户指令发送到延迟队列，当指令设定的时间到了再将指令推送到只能设备。<br>RabbitMQ怎么实现延迟队列</p>
<p>AMQP协议，以及RabbitMQ本身没有直接支持延迟队列的功能，但是可以通过TTL和DLX模拟出延迟队列的功能。</p>
<p>TTL（Time To Live）</p>
<p>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter</p>
<p>RabbitMQ针对队列中的消息过期时间有两种方法可以设置。</p>
<ul>
<li>A: 通过队列属性设置，队列中所有消息都有相同的过期时间。</li>
<li>B: 对消息进行单独设置，每条消息TTL可以不同。</li>
</ul>
<p>如果同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。消息在队列的生存时间一旦超过设置的TTL值，就成为dead letter</p>
<p>DLX (Dead-Letter-Exchange)</p>
<p>RabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由。</p>
<ul>
<li>x-dead-letter-exchange：出现dead letter之后将dead letter重新发送到指定exchange</li>
<li>x-dead-letter-routing-key：指定routing-key发送</li>
</ul>
<p>队列出现dead letter的情况有：</p>
<ul>
<li>消息或者队列的TTL过期</li>
<li>队列达到最大长度</li>
<li>消息被消费端拒绝（basic.reject or basic.nack）并且requeue=false</li>
</ul>
<p>利用DLX，当消息在一个队列中变成死信后，它能被重新publish到另一个Exchange。这时候消息就可以重新被消费。</p>
<p>详细可以参考： RabbitMQ之死信队列</p>
<p><strong>实例</strong>：</p>
<p>首先建立2个exchange和2个queue：</p>
<pre><code>exchange_delay_begin：这个是producer端发送时调用的exchange, 将消息发送至queue_dealy_begin中。
queue_delay_begin: 通过routingKey=&quot;delay&quot;绑定exchang_delay_begin, 同时配置DLX=exchange_delay_done, 当消息变成死信时，发往exchange_delay_done中。
exchange_delay_done: 死信的exchange, 如果不配置x-dead-letter-routing-key则采用原有默认的routingKey，即queue_delay_begin绑定exchang_delay_beghin采用的“delay”。
queue_delay_done：消息在TTL到期之后，最终通过exchang_delay_done发送值此queue，消费端通过消费此queue的消息，即可以达到延迟的效果。
</code></pre><p>建立exchange和queue的代码（当然这里可以通过RabbitMQ的管理界面来实现，无需code相关代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">"exchange_delay_begin"</span>, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line">channel.exchangeDeclare(<span class="string">"exchange_delay_done"</span>, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"exchange_delay_done"</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"queue_delay_begin"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br><span class="line">channel.queueDeclare(<span class="string">"queue_delay_done"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">channel.queueBind(<span class="string">"queue_delay_begin"</span>, <span class="string">"exchange_delay_begin"</span>, <span class="string">"delay"</span>);</span><br><span class="line">channel.queueBind(<span class="string">"queue_delay_done"</span>, <span class="string">"exchange_delay_done"</span>, <span class="string">"delay"</span>);</span><br></pre></td></tr></table></figure>
<p>消费端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">channel.basicConsume(<span class="string">"queue_delay_done"</span>, <span class="keyword">false</span>, consumer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">    String msg = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">    System.out.println(<span class="string">"receive msg time:"</span> + <span class="keyword">new</span> Date() + <span class="string">", msg body:"</span> + msg);</span><br><span class="line">    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">builder.expiration(<span class="string">"60000"</span>);<span class="comment">//设置消息TTL</span></span><br><span class="line">builder.deliveryMode(<span class="number">2</span>);<span class="comment">//设置消息持久化</span></span><br><span class="line">AMQP.BasicProperties properties = builder.build();</span><br><span class="line"></span><br><span class="line">String message = String.valueOf(<span class="keyword">new</span> Date());</span><br><span class="line">channel.basicPublish(<span class="string">"exchange_delay_begin"</span>,<span class="string">"delay"</span>,properties,message.getBytes());</span><br></pre></td></tr></table></figure>
<p>在创建完exchange和queue之后，首先执行consumer端的代码，之后执行producer端的代码，待producer发送完毕之后，查看consumer端的输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receive msg time:Tue Feb <span class="number">14</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">19</span> CST <span class="number">2017</span>, msg body:Tue Feb <span class="number">14</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">19</span> CST <span class="number">2017</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/01/10/java-Nginx%E6%8B%94%E9%AB%98/" rel="next" title="java-Nginx拔高">
                <i class="fa fa-chevron-left"></i> java-Nginx拔高
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/01/12/java-ElasticSearch%E8%AF%A6%E8%A7%A3/" rel="prev" title="java-ElasticSearch详解">
                java-ElasticSearch详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="xujunjie'blog" />
            
              <p class="site-author-name" itemprop="name">xujunjie'blog</p>
              <p class="site-description motion-element" itemprop="description">使一个人有限的生命更加有效也即等于延长了人的生命</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-认识RabbitMQ"><span class="nav-text">1. 认识RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-什么是消息队列"><span class="nav-text">1.1 什么是消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-AMQP和JMS"><span class="nav-text">1.2 AMQP和JMS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-常见MQ产品"><span class="nav-text">1.3 常见MQ产品</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-RabbitMQ的工作原理"><span class="nav-text">1.4 RabbitMQ的工作原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-RabbitMq-的搭建流程"><span class="nav-text">2. RabbitMq 的搭建流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-准备工作—安装Erlang"><span class="nav-text">2.1 准备工作—安装Erlang</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-安装-RabbitMq及过程错误解决"><span class="nav-text">2.2 安装 RabbitMq及过程错误解决</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-基本模式"><span class="nav-text">3. 基本模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-生产者"><span class="nav-text">3.1 生产者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-消费者接收消息"><span class="nav-text">3.2 消费者接收消息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-WorkQueues模式"><span class="nav-text">4. WorkQueues模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-生产者"><span class="nav-text">4.1 生产者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-消费者1"><span class="nav-text">4.2 消费者1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-消费者2"><span class="nav-text">4.3 消费者2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-订阅模式"><span class="nav-text">5. 订阅模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Publish-subscribe发布与订阅模型"><span class="nav-text">5.1 Publish&#x2F;subscribe发布与订阅模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-生产者"><span class="nav-text">5.1.1 生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-消费者1-（注册成功发给短信服务）"><span class="nav-text">5.1.2 消费者1 （注册成功发给短信服务）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-消费者2（注册成功发给邮件服务）"><span class="nav-text">5.1.3 消费者2（注册成功发给邮件服务）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Routing-路由模型"><span class="nav-text">5.2 Routing 路由模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-生产者"><span class="nav-text">5.2.1 生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-消费者1"><span class="nav-text">5.2.2 消费者1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-消费者2"><span class="nav-text">5.2.3 消费者2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-Topics-通配符模式"><span class="nav-text">5.3 Topics 通配符模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#：匹配一个或多个词"><span class="nav-text">：匹配一个或多个词</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-生产者"><span class="nav-text">5.3.1 生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-消费者1"><span class="nav-text">5.3.2 消费者1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-消费者2"><span class="nav-text">5.3.3 消费者2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Spring整合RabbitMQ"><span class="nav-text">6. Spring整合RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-生产者"><span class="nav-text">6.1 生产者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-消费者"><span class="nav-text">6.2 消费者</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-SpringBoot整合RabbitMQ"><span class="nav-text">7. SpringBoot整合RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-生产者-mq-rabbitmq-producer"><span class="nav-text">7.1 生产者(mq-rabbitmq-producer)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-消费者-mq-rabbitmq-consumer"><span class="nav-text">7.2 消费者(mq-rabbitmq-consumer)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-高级特性"><span class="nav-text">8. 高级特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-1-投递消息机制"><span class="nav-text">8.1 投递消息机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-Confirm确认消息"><span class="nav-text">8.1.1 Confirm确认消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-return返回消息"><span class="nav-text">8.1.2 return返回消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-consumer-ACK"><span class="nav-text">8.2 consumer ACK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-消费端限流"><span class="nav-text">8.3 消费端限流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-TTL"><span class="nav-text">8.4 TTL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-死信队列介绍"><span class="nav-text">8.5 死信队列介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#死信队列设置"><span class="nav-text">死信队列设置</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#消费端"><span class="nav-text">消费端</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#运行说明"><span class="nav-text">运行说明</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-延迟队列"><span class="nav-text">8.6 延迟队列</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xujunjie'blog</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>


  
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
